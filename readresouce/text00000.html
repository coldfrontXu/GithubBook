<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta charset="UTF-8" />
  <link href="../css/flow0001.css" type="text/css" rel="stylesheet" />
  <title>GitHub入门与实践 (图灵程序设计丛书) 版权信息</title>
  <script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
  <script src='../Js/webreader3.js' language='javascript' type='text/javascript'></script>

  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=0.5,maximum-scale=1.5, user-scalable=yes" />
  <link rel="stylesheet" type="text/css" href="../css/webreader3.css" />
</head>

<body>
  <div class="WebReader">
    <div onclick="alert('廢除')" class="reader-to-vip c-pointer"></div>
    <div class="readertop" onclick="stopProp(event)">
      <div class="reader-setting"></div>
      <div Class="top-bottom">
        <div Class="top-bottom-inner">
          <div Class="menu-icon wd-same df justify-start">
            <div Class="df flex-column align-center c-pointer" onclick="menusfade(event)">
              <div Class="img-pic toc" style="background-image: url(../icons/menu.png);background-repeat: no-repeat;"
                id="toc"></div>
              <p> 目录</p>
            </div>
          </div>
          <div Class="top-prev wd-same df justify-start">
            <div Class="c-pointer df flex-column align-center"><img src="../icons/pre.png" id="prev" alt="" />
              <p> 上一章</p>
            </div>
          </div>
          <div Class="top_next wd-same df justify-start">
            <div Class="c-pointer df flex-column align-center"><a
                href="/GithubBook/readresouce/text00000.html" class="a_next"><img
                  src="../icons/next.png" id="next" alt="" /></a>
              <p> 下一章</p>
            </div>
          </div>
          <div Class="top-more">
            <div Class="c-pointer df flex-column align-center"><a  href="https://coldfrontXu.github.io"></a>
                <div Class="img-pic reader" id="reader"
                  style="background-image: url(../icons/reader.png);background-repeat: no-repeat;" alt=""></div>
              </a>
              <p Class="white-nowrap">更多图书</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="readermenu">
      <div id="tocmenulinks">
        <div class="menu-inner scroll-bar">
          <p class="menutop"><span>Table Of Contents</span></p>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html">版权信息</a></p>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_0">版权声明</a></p>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_1">译者序</a></p>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_2">序言</a></p>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_3">本书结构</a></p>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_4">第 1 章　欢迎来到GitHub的世界</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_5">1.1　什么是 GitHub</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_6">GitHub 公司与 octocat</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_7">并不只是 Git 仓库的托管服务</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_8">GitHub 的使用情况</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_9">1.2　使用 GitHub 会带来哪些变化</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_10">协作形式变化</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_1">……在开发者之间引发化学反应的 Pull Request</a>
                  </p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_2">……对特定用户进行评论</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_3">……GitHub Flavored Markdown</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_11">能看到更多其他团队的软件</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_12">与开源软件相同的开发模式</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_13">1.3　社会化编程</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_14">1.4　为什么需要社会化编程</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_15">不要闭目塞听，要接触不同的文化</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_16">会写代码的程序员更受青睐</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_17">GitHub 最大的特征是“面向人”</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_18">1.5　GitHub 提供的主要功能</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_19">Git 仓库</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_20">Organization</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_21">Issue</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_22">Wiki</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_23">Pull Request</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_24">1.6　小结</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_25">参考资料</a></p>
              </div>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_26">第 2 章　Git的导入</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_27">2.1　诞生背景</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_28">2.2　什么是版本管理</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_29">集中型与分散型</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_4">……集中型</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_5">……分散型</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_30">集中型与分散型哪个更好</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_31">2.3　安装</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_32">Mac 与 Linux</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_33">Windows</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_6">……组件的选择</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_7">……设置环境变量</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_8">……换行符的处理</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_9">……Git Bash</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_34">本书所用的环境</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_35">2.4　初始设置</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_36">设置姓名和邮箱地址</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_37">提高命令输出的可读性</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_38">2.5　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_39">第 3 章　使用GitHub的前期准备</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_40">3.1　使用前的准备</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_41">创建账户</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_42">设置头像</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_43">设置 SSH Key</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_44">添加公开密钥</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_45">使用社区功能</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_46">3.2　实际动手使用</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_47">创建仓库</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_10">……Repository name</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_11">……Description</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_12">……Public、Private</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_13">……Initialize this repository with
                      a README</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_14">……Add .gitignore</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_15">……Add a license</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_48">连接仓库</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_16">……README.md</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_17">……GitHub Flavored Markdown</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_49">公开代码</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_18">……clone 已有仓库</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_19">……编写代码</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_20">……提交</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_21">……进行 push</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_50">3.3　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_51">第 4 章　通过实际操作学习Git</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_52">4.1　基本操作</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_53">git init——初始化仓库</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_54">git status——查看仓库的状态</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_55">git add——向暂存区中添加文件</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_56">git commit——保存仓库的历史记录</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_22">……记述一行提交信息</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_23">……记述详细提交信息</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_24">……中止提交</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_25">……查看提交后的状态</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_57">git log——查看提交日志</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_26">……只显示提交信息的第一行</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_27">……只显示指定目录、文件的日志</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_28">……显示文件的改动</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_58">git diff——查看更改前后的差别</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_29">……查看工作树和暂存区的差别</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_30">……查看工作树和最新提交的差别</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_59">4.2　分支的操作</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_60">git branch——显示分支一览表</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_61">git checkout -b——创建、切换分支</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_31">……切换到 feature-A 分支并进行提交</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_32">……切换到 master 分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_33">……切换回上一个分支</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_62">特性分支</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_63">主干分支</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_64">git merge——合并分支</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_65">git log --graph——以图表形式查看分支</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_66">4.3　更改提交的操作</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_67">git reset——回溯历史版本</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_34">……回溯到创建 feature-A 分支前</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_35">……创建 fix-B 分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_36">……推进至 feature-A 分支合并后的状态</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_68">消除冲突</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_37">……查看冲突部分并将其解决</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_38">……提交解决后的结果</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_69">git commit --amend——修改提交信息</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_70">git rebase -i——压缩历史</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_39">……创建 feature-C 分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_40">……修正拼写错误</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_41">……更改历史</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_71">……合并至 master 分支</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_72">4.4　推送至远程仓库</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_73">git remote add——添加远程仓库</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_74">git push——推送至远程仓库</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_42">……推送至 master 分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_43">……推送至 master 以外的分支</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_75">4.5　从远程仓库获取</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_76">git clone——获取远程仓库</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_44">……获取远程仓库</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_45">……获取远程的 feature-D 分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_46">……向本地的 feature-D 分支提交更改</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_47">……推送 feature-D 分支</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_77">git pull——获取最新的远程仓库分支</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_78">4.6　帮助大家深入理解 Git 的资料</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_79">Pro Git</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_80">LearnGitBranching</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_81">tryGit</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_82">4.7　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_83">第 5 章　详细解说GitHub的功能</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_84">5.1　键盘快捷键</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_85">5.2　工具栏</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_86">关于 UI</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_48">……1 LOGO</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_49">……2 Notifications</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_50">……3 搜索窗口</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_51">……4 Explore</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_52">……5 Gist</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_53">……6 Blog</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_54">……7 Help</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_55">……8 头像、用户名</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_56">……9 Create a new...</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_57">……10 Account settings</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_58">……11 Sign out</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_87">5.3　控制面板</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_88">关于 UI</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_59">……1 News Feed</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_60">……2 Pull Requests</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_61">……3 Issues</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_62">……4 Stars</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_63">……5 Broadcast</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_64">……6 Repositories you contribute
                      to</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_65">……7 Your Repositories</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_89">5.4　个人信息</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_90">关于 UI</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_66">……1 用户信息</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_67">……2 Popular Repositories</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_68">……3 Repositories contributed
                      to</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_69">……4 Public contributions</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_70">……5 Contribution Activity</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_71">……6 Repositories</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_72">……7 Public Activity</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_91">5.5　仓库</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_92">关于 UI</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_73">……1 用户名（组织名）/仓库名</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_74">……2 Watch/Star/Fork</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_75">……3 Code</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_76">……4 Issue</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_77">……5 Pull Requests</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_78">……6 Wiki</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_79">……7 Pulse</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_80">……8 Graphs</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_81">……9 Network</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_82">……10 Settings</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_83">……11 SSH clone URL</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_84">……12 Clone in Desktop</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_85">……13 Download ZIP</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_86">……a commits</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_87">……b branches</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_88">……c releases</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_89">……d contributors</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_90">……e Compare and review</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_91">……f branch</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_92">……g path</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_93">……h Fork this project and Create a
                      new file</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_94">……i files</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_93">文件的相关操作</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_94">查看差别</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_95">……查看分支间的差别</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_96">……查看与几天前的差别</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_97">……查看与指定日期之间的差别</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_95">5.6　Issue</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_96">简洁且表现力丰富的描述方法</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_98">……语法高亮</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_99">……添加图片</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_97">添加标签以便整理</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_98">添加里程碑以便管理</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_99">Tasklist 语法</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_100">通过提交信息操作 Issue</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_100">……在相关 Issue 中显示提交</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_101">……Close Issue</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_101">将特定的 Issue 转换为 Pull Request</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_102">5.7　Pull Request</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_103">Conversation</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_104">Commits</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_105">Files Changed</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_106">5.8　Wiki</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_107">Pages</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_108">History</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_109">5.9　Pulse</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_110">active pull requests</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_111">active issue</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_112">commits</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_113">Releases published</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_114">Unresolved Conversations</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_115">5.10　Graphs</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_116">Contributors</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_117">Commit Activity</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_118">Punchcard</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_119">5.11　Network</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_120">5.12　Settings</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_121">Options</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_102">……1 Settings</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_103">……2 Features</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_104">……3 GitHub Pages</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_105">……4 Danger Zone</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_122">Collaborators</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_123">Webhooks and Services</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_124">Deploy Keys</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_125">5.13　Notifications</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_126">5.14　其他功能</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_127">GitHub Pages</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_128">GitHub Jobs</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_129">GitHub Enterprise</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_130">GitHub API</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_131">5.15　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_132">第 6 章　尝试Pull Request</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_133">6.1　Pull Request 的概要</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_134">什么是 Pull Request</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_135">Pull Request 的流程</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_136">6.2　发送 Pull Request 前的准备</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_137">查看要修正的源代码</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_138">Fork</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_139">clone</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_140">branch</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_106">……为何要在特性分支中进行作业</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_107">……确认分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_108">……创建特性分支</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_141">添加代码</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_142">提交修改</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_143">创建远程分支</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_144">6.3　发送 Pull Request</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_145">6.4　让 Pull Request 更加有效的方法</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_146">在开发过程中发送 Pull Request 进行讨论</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_147">明确标出“正在开发过程中”</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_148">不进行 Fork 直接从分支发送 Pull Request</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_149">6.5　仓库的维护</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_150">仓库的 Fork 与 clone</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_151">给原仓库设置名称</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_152">获取最新数据</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_153">6.6　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_154">第 7 章　接收Pull Request</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_155">7.1　采纳 Pull Request 的方法</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_156">7.2　采纳 Pull Request 前的准备</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_157">代码审查</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_158">查看图片的差别</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_109">……2-up</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_110">……Swipe</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_111">……Onion Skin</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_112">……Difference4</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_159">在本地开发环境中反映 Pull Request 的内容</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_113">……将接收方的本地仓库更新至最新状态</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_114">……获取发送方的远程仓库</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_115">……创建用于检查的分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_116">……合并</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_117">……删除分支</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_160">7.3　采纳 Pull Request</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_161">合并到主分支</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_162">push 修改内容</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_163">7.4　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_164">第 8 章　与GitHub相互协作的工具及服务</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_165">8.1　hub 命令</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_166">概要</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_167">安装</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_118">……安装</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_119">……确认运行情况</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_120">……设置别名</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_121">……实现 shell 上的功能补全</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_122">……~/.config/hub</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_168">命令</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_169">……hub clone</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_170">……hub remote add</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_123">……hub fetch</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_124">……hub cherry-pick</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_125">……hub fork</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_126">……hub pull-request</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_127">……hub checkout</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_128">……hub create</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_129">……hub push</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_130">……hub browse</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_131">……hub compare</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_171">8.2　Travis CI</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_172">概要</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_173">实际尝试</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_132">……编写配置文件</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_133">……检测配置文件是否有问题</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_134">……与 GitHub 集成</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_135">……将 Travis CI 的结果添加至
                      README.md</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_174">8.3　Coveralls</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_175">概要</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_176">安装</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_136">……注册</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_137">……添加对象仓库</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_138">……编写配置文件</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_139">……添加 gem</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_140">……查看报告</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_177">8.4　Gemnasium</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_178">8.5　Code Climate</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_179">8.6　Jenkins</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_180">概要</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_181">安装</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_182">创建 bot 账户</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_183">bot 账户的权限设置</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_141">……对象为个人账户时</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_142">……对象为 Organization 账户时</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_143">……检查设置</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_184">给 Jenkins 设置 SSH 密钥</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_144">……初次使用 Jenkins 时</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_145">……已经在使用 Jenkins 时</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_146">GitHub pull request builder
                      plugin 的安装</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_185">Git plugin 的设置</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_186">Github Pull Requests Builder 的设置</a>
                </p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_147">……Github server api URL</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_148">……Access Token</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_149">……Admin list</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_187">job 的创建与设置</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_150">……GitHub project</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_151">……源码管理</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_152">……构建触发器</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_153">……构建</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_188">通知结果</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_154">……测试执行中的状态</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_155">……Failed</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_156">……All is well</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_157">……commit status</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_189">通过评论进行控制</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_158">……执行任务</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_159">……添加至 White list</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_160">……重新执行任务</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_161">……变更指定评论</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_190">8.7　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_191">第 9 章　使用GitHub的开发流程</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_192">9.1　团队使用 GitHub 时的注意事项</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_193">一切从简</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_162">……项目管理工具与 GitHub 的区别</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_163">……项目管理工具与 GitHub 相异的原因</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_194">不 Fork 仓库的方法</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_195">9.2　GitHub Flow——以部署为中心的开发模式</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_196">9.3　GitHub Flow 的流程</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_197">随时部署，没有发布的概念</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_198">进行新的作业时要从 master 分支创建新分支</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_199">在新创建的分支中进行提交</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_200">定期 push</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_201">使用 Pull Request</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_202">务必让其他开发者进行审查</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_203">合并后立刻部署</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_204">9.4　实践 GitHub Flow 的前提条件</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_205">部署作业完全自动化</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_164">……使用部署工具</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_165">……通过 Web 界面进行部署的工具</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_166">……导入开发时的注意事项</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_206">重视测试</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_167">……让测试自动化</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_168">……编写测试代码，通过全部测试</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_169">……维护测试代码</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_207">9.5　模拟体验 GitHub Flow</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_208">Fizzbuzz 的说明</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_209">添加新功能</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_210">创建新的分支</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_170">……如果尚未 clone 仓库</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_171">……如果之前 clone 过仓库</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_172">……创建特性分支</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_211">实现新功能</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_212">创建 Pull Request</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_213">接收反馈</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_214">修正缩进</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_215">添加测试</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_216">培育 Pull Request</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_217">Pull Request 被合并</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_218">9.6　团队实践 GitHub Flow 时的几点建议</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_219">减小 Pull Request 的体积</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_220">准备可供试运行的环境</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_221">不要让 Pull Request 中有太多反馈</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_222">不要积攒 Pull Request</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_223">9.7　GitHub Flow 的小结</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_224">9.8　Git Flow——以发布为中心的开发模式</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_225">便于理解的标准流程</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_226">有时显得过于复杂</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_227">9.9　导入 Git Flow 前的准备</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_228">安装 git-flow</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_173">……Mac 下的安装</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_174">……Linux 下的安装</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_175">……确认运行状况</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_229">仓库的初始设置</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_176">……创建仓库</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_177">……进行 git flow 的初始设置</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_178">……在远程仓库中也创建 develop 分支</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_230">9.10　模拟体验 Git Flow</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_231">master 分支与 develop 分支的区别</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_179">……master 分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_180">……develop 分支</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_232">在 feature 中进行的工作</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_181">……创建分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_182">……在分支中进行作业</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_233">发送 Pull Request</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_234">通过代码审查提高代码质量</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_235">更新本地的 develop 分支</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_236">在 release 分支中进行的工作</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_183">……创建分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_184">……分支内的工作</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_185">……进行发布与合并</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_186">……查看版本标签</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_237">更新到远程仓库</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_238">在 hotfix 分支中进行的工作</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_187">……创建分支</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_188">……创建标签和进行发布</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_189">……从 hotfix 分支合并至 develop 分支</a>
                  </p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_239">9.11　Git Flow 的小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_240">第 10 章　将GitHub应用到企业</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_241">10.1　将世界标准的开发环境引入企业现场</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_242">企业引入 GitHub 的好处</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_243">使用 Organization</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_244">确认 Github 的安全性</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_245">注意维护时间</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_246">查看故障信息</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_247">10.2　GitHub Enterprise</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_248">概述</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_249">引入的好处</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_250">引入的弊端</a></p>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_251">适合引入 GitHub Enterprise 的几种情况</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_190">……源代码不可外传</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_191">……希望维护与故障时间可控</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_252">10.3　能实现 Git 托管的软件</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_253">10.4　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_254">附录 A　支持GitHub的GUI客户端</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_255">A.1　GitHub for Mac，GitHub for
                  Windows</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_256">A.2　SourceTree</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#nav_point_257">附录 B　通过Gist轻松实现代码共享</a></p>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_258">B.1　Gist 的特点</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_259">B.2　创建 Gist</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_260">UI 讲解</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_192">……1 Gist description...</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_193">……2 name this file...</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_194">……3 language</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_195">……4 ACE Editor</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_196">……5 文件</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_197">……6 Add another File</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_198">……7 Create Secret Gist</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_199">……8 Create Public Gist</a></p>
                </div>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_261">B.3　查看 Gist</a></p>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_262">Gist 的菜单</a></p>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_200">……1 Gist Detail</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_201">……2 Revisions</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_202">……3 Download Gist</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_203">……4 Clone this gist</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_204">……5 Embed this gist</a></p>
                </div>
                <div class="level_4">
                  <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_205">……6 Link to this gist</a></p>
                </div>
              </div>
              <div class="level_3">
                <p><a href="/GithubBook/readresouce/text00000.html#nav_point_263">文件的菜单</a></p>
              </div>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_264">B.4　Your Gists</a></p>
            </div>
            <div class="level_2">
              <p><a href="/GithubBook/readresouce/text00000.html#nav_point_265">B.5　小结</a></p>
            </div>
          </div>
          <div class="level_1">
            <p><a href="/GithubBook/readresouce/text00000.html#sigil_toc_id_206">看完了</a></p>
          </div>
          <p class="menubottom"></p>
        </div>
      </div>
    </div>
    <div class="readercontent">
      <div class="readercontent-inner">

        <h1 class="not-in-toc">版权信息</h1>
        <p>书名：GitHub入门与实践</p>
        <p>作者：［日］ 大塚弘记</p>
        <p>译者：支鹏浩　刘斌</p>
        <p>ISBN：978-7-115-39409-5</p>
        <p>
          <strong>本书由北京图灵文化发展有限公司发行数字版。版权所有，侵权必究。</strong>
        </p>
        <hr />
        <p>您购买的图灵电子书仅供您个人使用，未经授权，不得以任何方式复制和传播本书内容。</p>
        <p>我们愿意相信读者具有这样的良知和觉悟，与我们共同保护知识产权。</p>
        <p>如果购买者有侵权行为，我们可能对该用户实施包括但不限于关闭该帐号等维权措施，并可能追究法律责任。</p>
        <hr />
        <p>图灵社区会员 张海川（zhanghaichuan@ptpress.com.cn） 专享 尊重版权</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <p class="toc-level-1">
          <a href="/GithubBook/readresouce/text00000.html#nav_point_0">版权声明</a>
        </p>
        <p class="toc-level-1">
          <a href="/GithubBook/readresouce/text00000.html#nav_point_1">译者序</a>
        </p>
        <p class="toc-level-1">
          <a href="/GithubBook/readresoucetext00000.html#nav_point_2">序言</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_3">本书结构</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_4">第 1 章　欢迎来到GitHub的世界</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_5">1.1　什么是 GitHub</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_6">GitHub 公司与 octocat</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_7">并不只是 Git 仓库的托管服务</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_8">GitHub 的使用情况</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_9">1.2　使用 GitHub 会带来哪些变化</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_10">协作形式变化</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_11">能看到更多其他团队的软件</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_12">与开源软件相同的开发模式</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_13">1.3　社会化编程</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_14">1.4　为什么需要社会化编程</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_15">不要闭目塞听，要接触不同的文化</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_16">会写代码的程序员更受青睐</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_17">GitHub 最大的特征是“面向人”</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_18">1.5　GitHub 提供的主要功能</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_19">Git 仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_20">Organization</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_21">Issue</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_22">Wiki</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_23">Pull Request</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_24">1.6　小结</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_25">参考资料</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_26">第 2 章　Git的导入</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_27">2.1　诞生背景</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_28">2.2　什么是版本管理</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_29">集中型与分散型</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_30">集中型与分散型哪个更好</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_31">2.3　安装</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_32">Mac 与 Linux</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_33">Windows</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_34">本书所用的环境</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_35">2.4　初始设置</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_36">设置姓名和邮箱地址</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_37">提高命令输出的可读性</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_38">2.5　小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_39">第 3 章　使用GitHub的前期准备</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_40">3.1　使用前的准备</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_41">创建账户</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_42">设置头像</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_43">设置 SSH Key</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_44">添加公开密钥</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_45">使用社区功能</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_46">3.2　实际动手使用</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_47">创建仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_48">连接仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_49">公开代码</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_50">3.3　小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_51">第 4 章　通过实际操作学习Git</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_52">4.1　基本操作</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_53">git init——初始化仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_54">git status——查看仓库的状态</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_55">git add——向暂存区中添加文件</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_56">git commit——保存仓库的历史记录</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_57">git log——查看提交日志</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_58">git diff——查看更改前后的差别</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_59">4.2　分支的操作</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_60">git branch——显示分支一览表</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_61">git checkout -b——创建、切换分支</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_62">特性分支</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_63">主干分支</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_64">git merge——合并分支</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_65">git log --graph——以图表形式查看分支</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_66">4.3　更改提交的操作</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_67">git reset——回溯历史版本</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_68">消除冲突</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_69">git commit --amend——修改提交信息</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_70">git rebase -i——压缩历史</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_71">……合并至 master 分支</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_72">4.4　推送至远程仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_73">git remote add——添加远程仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_74">git push——推送至远程仓库</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_75">4.5　从远程仓库获取</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_76">git clone——获取远程仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_77">git pull——获取最新的远程仓库分支</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_78">4.6　帮助大家深入理解 Git 的资料</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_79">Pro Git</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_80">LearnGitBranching</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_81">tryGit</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_82">4.7　小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_83">第 5 章　详细解说GitHub的功能</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_84">5.1　键盘快捷键</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_85">5.2　工具栏</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_86">关于 UI</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_87">5.3　控制面板</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_88">关于 UI</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_89">5.4　个人信息</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_90">关于 UI</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_91">5.5　仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_92">关于 UI</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_93">文件的相关操作</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_94">查看差别</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_95">5.6　Issue</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_96">简洁且表现力丰富的描述方法</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_97">添加标签以便整理</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_98">添加里程碑以便管理</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_99">Tasklist 语法</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_100">通过提交信息操作 Issue</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_101">将特定的 Issue 转换为 Pull Request</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_102">5.7　Pull Request</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_103">Conversation</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_104">Commits</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_105">Files Changed</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_106">5.8　Wiki</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_107">Pages</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_108">History</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_109">5.9　Pulse</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_110">active pull requests</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_111">active issue</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_112">commits</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_113">Releases published</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_114">Unresolved Conversations</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_115">5.10　Graphs</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_116">Contributors</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_117">Commit Activity</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_118">Punchcard</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_119">5.11　Network</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_120">5.12　Settings</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_121">Options</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_122">Collaborators</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_123">Webhooks and Services</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_124">Deploy Keys</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_125">5.13　Notifications</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_126">5.14　其他功能</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_127">GitHub Pages</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_128">GitHub Jobs</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_129">GitHub Enterprise</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_130">GitHub API</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_131">5.15　小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_132">第 6 章　尝试Pull Request</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_133">6.1　Pull Request 的概要</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_134">什么是 Pull Request</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_135">Pull Request 的流程</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_136">6.2　发送 Pull Request 前的准备</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_137">查看要修正的源代码</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_138">Fork</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_139">clone</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_140">branch</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_141">添加代码</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_142">提交修改</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_143">创建远程分支</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_144">6.3　发送 Pull Request</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_145">6.4　让 Pull Request 更加有效的方法</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_146">在开发过程中发送 Pull Request 进行讨论</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_147">明确标出“正在开发过程中”</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_148">不进行 Fork 直接从分支发送 Pull Request</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_149">6.5　仓库的维护</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_150">仓库的 Fork 与 clone</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_151">给原仓库设置名称</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_152">获取最新数据</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_153">6.6　小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_154">第 7 章　接收Pull Request</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_155">7.1　采纳 Pull Request 的方法</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_156">7.2　采纳 Pull Request 前的准备</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_157">代码审查</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_158">查看图片的差别</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_159">在本地开发环境中反映 Pull Request 的内容</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_160">7.3　采纳 Pull Request</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_161">合并到主分支</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_162">push 修改内容</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_163">7.4　小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_164">第 8 章　与GitHub相互协作的工具及服务</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_165">8.1　hub 命令</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_166">概要</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_167">安装</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_168">命令</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_169">……hub clone</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_170">……hub remote add</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_171">8.2　Travis CI</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_172">概要</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_173">实际尝试</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_174">8.3　Coveralls</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_175">概要</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_176">安装</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_177">8.4　Gemnasium</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_178">8.5　Code Climate</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_179">8.6　Jenkins</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_180">概要</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_181">安装</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_182">创建 bot 账户</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_183">bot 账户的权限设置</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_184">给 Jenkins 设置 SSH 密钥</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_185">Git plugin 的设置</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_186">Github Pull Requests Builder 的设置</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_187">job 的创建与设置</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_188">通知结果</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_189">通过评论进行控制</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_190">8.7　小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_191">第 9 章　使用GitHub的开发流程</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_192">9.1　团队使用 GitHub 时的注意事项</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_193">一切从简</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_194">不 Fork 仓库的方法</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_195">9.2　GitHub Flow——以部署为中心的开发模式</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_196">9.3　GitHub Flow 的流程</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_197">随时部署，没有发布的概念</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_198">进行新的作业时要从 master 分支创建新分支</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_199">在新创建的分支中进行提交</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_200">定期 push</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_201">使用 Pull Request</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_202">务必让其他开发者进行审查</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_203">合并后立刻部署</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_204">9.4　实践 GitHub Flow 的前提条件</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_205">部署作业完全自动化</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_206">重视测试</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_207">9.5　模拟体验 GitHub Flow</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_208">Fizzbuzz 的说明</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_209">添加新功能</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_210">创建新的分支</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_211">实现新功能</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_212">创建 Pull Request</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_213">接收反馈</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_214">修正缩进</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_215">添加测试</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_216">培育 Pull Request</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_217">Pull Request 被合并</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_218">9.6　团队实践 GitHub Flow 时的几点建议</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_219">减小 Pull Request 的体积</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_220">准备可供试运行的环境</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_221">不要让 Pull Request 中有太多反馈</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_222">不要积攒 Pull Request</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_223">9.7　GitHub Flow 的小结</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_224">9.8　Git Flow——以发布为中心的开发模式</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_225">便于理解的标准流程</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_226">有时显得过于复杂</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_227">9.9　导入 Git Flow 前的准备</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_228">安装 git-flow</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_229">仓库的初始设置</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_230">9.10　模拟体验 Git Flow</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_231">master 分支与 develop 分支的区别</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_232">在 feature 中进行的工作</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_233">发送 Pull Request</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_234">通过代码审查提高代码质量</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_235">更新本地的 develop 分支</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_236">在 release 分支中进行的工作</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_237">更新到远程仓库</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_238">在 hotfix 分支中进行的工作</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_239">9.11　Git Flow 的小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_240">第 10 章　将GitHub应用到企业</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_241">10.1　将世界标准的开发环境引入企业现场</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_242">企业引入 GitHub 的好处</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_243">使用 Organization</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_244">确认 Github 的安全性</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_245">注意维护时间</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_246">查看故障信息</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_247">10.2　GitHub Enterprise</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_248">概述</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_249">引入的好处</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_250">引入的弊端</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_251">适合引入 GitHub Enterprise 的几种情况</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_252">10.3　能实现 Git 托管的软件</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_253">10.4　小结</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_254">附录 A　支持GitHub的GUI客户端</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_255">A.1　GitHub for Mac，GitHub for Windows</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_256">A.2　SourceTree</a>
        </p>
        <p class="toc-level-1"><a href="/GithubBook/readresouce/text00000.html#nav_point_257">附录 B　通过Gist轻松实现代码共享</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_258">B.1　Gist 的特点</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_259">B.2　创建 Gist</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_260">UI 讲解</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_261">B.3　查看 Gist</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_262">Gist 的菜单</a>
        </p>
        <p class="toc-level-3"><a href="/GithubBook/readresouce/text00000.html#nav_point_263">文件的菜单</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_264">B.4　Your Gists</a>
        </p>
        <p class="toc-level-2"><a href="/GithubBook/readresouce/text00000.html#nav_point_265">B.5　小结</a>
        </p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_0">
          <strong>版权声明</strong>
        </h1>
        <p>
          <em>GitHub JISSEN NYUMON</em>
          by Hiroki Otsuka
        </p>
        <p>Copyright © 2014 Hiroki Otsuka</p>
        <p>All rights reserved.</p>
        <p>Original Japanese edition published by Gijyutsu-Hyoron Co., Ltd., Tokyo</p>
        <p>　</p>
        <p>This Simplified Chinese language edition published by arrangement with Gijyutsu-Hyoron Co., Ltd., Tokyo in
          care of Tuttle-Mori Agency, Inc., Tokyo</p>
        <p>本书中文简体字版由 Gijyutsu-Hyoron Co., Ltd. 授权人民邮电出版社独家出版。未经出版者书面许可，不得以任何方式复制或抄袭本书内容。</p>
        <p>版权所有，侵权必究。</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_1">
          <strong>译者序</strong>
        </h1>
        <p>“开源”一词在我国 IT
          界已经出现了不少年头，但“社会化编程”想必没有多少人接触过。于是在阅读正文之前，容我越俎代庖替作者问一个问题：各位在狭小的空间里呆上一段时间之后，再出门时是否有一种豁然开朗的感觉？相信很多人的答案都是肯定的。对于对日外包出身的我来说，“社会化编程”就给了我这种感觉。或许外包行业在
          IT 界只是极端个例，但“让全世界码农看自己的代码”这种事，很多人恐怕想都不敢想吧。</p>
        <p>GitHub 正是这样一个平台，我们在这里可以与全世界的开源开发者交流代码或心得。如果您对某款开源软件的源代码感兴趣，如果您想为中意的软件出一份力，如果您自己编写了小程序却苦苦找不到人指点，如果您想跟慕名已久的 IT
          界明星（俗称“大神”）聊上几句，那么 GitHub 欢迎您。</p>
        <p>GitHub 的纯英文界面或许会令您望而却步，不过不用担心，本书秉承了日系技术书刊一贯的“手把手教学”风格，作者用亲切的语言，简明扼要的介绍，配以生动详实的示例为我们一步步讲解 GitHub
          的使用方法，带我们在实践中学习 GitHub。值得一提的是，本书配有一个供各位实践的网站，请感兴趣的读者务必一试。俗话说“读万卷书不如行万里路”，跟着作者一边实践一边阅读本书，相信各位会对这句话有一个更深刻的体会。
        </p>
        <p>有些读者可能要问了，代码是企业的财产，不能随便发到网上给别人看，那 GitHub 对工作又有什么意义呢？这一点作者自然考虑到了。GitHub
          面向社会化编程，我们所生活的是一个大社会，我们工作的企业同样是一个小社会，虽然不能强行导入“社会化编程”，但其管理模式仍然值得借鉴。所以如果您是企业的决策者，那么请在本书后半跟随作者一起探讨企业导入社会化编程的利弊，说不定能为您所在的企业带来新的利益。
        </p>
        <p>《GitHub 入门与实践》是国内比较少见的对 GitHub
          及社会化编程进行系统介绍的书籍。以往我们对于这方面知识，只能通过网络上零零散散的博客或技术文档进行片面了解，难以把握其全貌。各位读完这本书后相信能得到不少帮助。</p>
        <p>最后，对另一位帮忙搭建本书相关网站的译者以及图灵文化的各位编辑致以衷心的感谢，正是有了各位的共同努力，本书才得以出版。同时感谢正在阅读本书的您，有了您的支持，本书才能发挥其价值。</p>
        <p align="right">支鹏浩</p>
        <p align="right">2015 年 4 月 于北京</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_2">
          <strong>序言</strong>
        </h1>
        <p>当今世界有众多开发者在使用 GitHub 进行开发。本书旨在指导各位读者在开发现场如何使用 GitHub 进行高效开发。因此，书中除针对 GitHub 进行讲解外，也涉及了开发流程及相关辅助工具的解说。</p>
        <p>您在开发现场有没有遇到过以下几件事？</p>
        <ul>
          <li>
            <p>代码审查不到位，审查效率低下</p>
          </li>
          <li>
            <p>只有编程者本人能看懂的代码、可靠性不高的代码直接被部署至正式环境中</p>
          </li>
          <li>
            <p>因键入错误、理解错误而造成的低级代码错误导致 BUG 频繁出现</p>
          </li>
          <li>
            <p>没有机会和其他人互相交流代码，共享知识，相互学习、指正、改善</p>
          </li>
          <li>
            <p>没有一个简单高效、能在一天之内添加多个功能的开发流程</p>
          </li>
        </ul>
        <p>GitHub 为我们提供了解决这些问题的机会和功能，而本书则凝练了各种运用 GitHub 的诀窍。</p>
        <p>笔者曾为多家企业引入 GitHub，改善其开发流程。本书总结了这些经验，相信能为改善您的开发现场提供一些帮助。</p>
        <ul>
          <li>
            <p>
              <strong>……谢辞</strong>
            </p>
            <p>本书在编撰过程中得到了多方的大力支持。特此鸣谢 @yamanetoshi、增田贵士（@masutaka）、bakorer、山科佑贵、寺田涉、Tatsuma Murase、杉野康弘、泽义和（排名不分先后）。
            </p>
            <p>另外，长期以来，技术评论社的池田大树为本书的编辑与整理尽心尽力，在此由衷地表示感谢。</p>
          </li>
        </ul>
        <p align="right">2014 年 2 月　大塚弘记</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_3">
          <strong>本书结构</strong>
        </h1>
        <p>本书由 10 章及 2 个附录构成。</p>
        <p>　</p>
        <p>
          <strong>第 1 章：欢迎来到 GitHub 的世界</strong>
        </p>
        <p>讲解 GitHub 是什么，以及有哪些革新之处。在开源软件的世界中，GitHub 为开发者带来了革命性的社会化编程概念。在这里我们将会接触这一概念，并对其带来的优势与功能进行讲解。</p>
        <p>
          <strong>第 2 章：Git 的导入</strong>
        </p>
        <p>要使用 GitHub，离不开 Git 这一版本管理系统。本章将深入介绍关于 Git 的知识，加深各位对 Git 的理解，同时说明实际操作的相关流程。</p>
        <p>
          <strong>第 3 章：使用 GitHub 的前期准备</strong>
        </p>
        <p>使用 GitHub 需要开设账户（免费），因此我们将按照顺序为您讲解正式使用前需要进行的一系列设置。</p>
        <p>另外，本章还会讲解包括操作示例在内的，实际在 GitHub 上创建仓库并发布代码的相关流程。</p>
        <p>
          <strong>第 4 章：通过实际操作学习 Git</strong>
        </p>
        <p>在实际操作中学习使用 GitHub 时所必需掌握的 Git 的基本知识和操作方法。</p>
        <p>从最基本操作到多人开发时所需的复杂操作，读者都可以随着本章的讲解简单实践一番。</p>
        <p>
          <strong>第 5 章：详细解说 GitHub 的功能</strong>
        </p>
        <p>本章我们将以图配文，对 GitHub 的功能逐一进行讲解，同时还会详细解说其作为源代码查看器的功能，带您领略方便快捷的 UI。</p>
        <p>建议正在使用 GitHub 的开发者也读一读本章，您或许会发现一些将来能用到的小技巧。</p>
        <p>
          <strong>第 6 章：尝试 Pull Request</strong>
        </p>
        <p>Pull Request 是 GitHub 的代表功能，本章我们将带您亲自动手体会。请务必参考本书内容试着进行一次 Pull Request。</p>
        <p>
          <strong>第 7 章：接收 Pull Request</strong>
        </p>
        <p>站在仓库维护方的角度，教您在接到 Pull Request 之后应该如何考虑，如何判断，以及该进行哪些操作。</p>
        <p>
          <strong>第 8 章：与 GitHub 相互协作的工具及服务</strong>
        </p>
        <p>前半部分为您讲解通过 CLI 对 GitHub 进行操作时所需的 hub 命令。另外，在持续集成环境方面，将讲解可与 GitHub 结合使用的 Travis CI 及 Jenkins 的构建及设定方法。</p>
        <p>除此之外，本章还会介绍一些能够与 GitHub 共同使用的服务。</p>
        <p>
          <strong>第 9 章：使用 GitHub 的开发流程</strong>
        </p>
        <p>详细讲解以 GitHub 为中心进行开发的 GitHub Flow、Git Flow 两个开发流程。从两者共通的团队开发心得到各自开发流程的特征，都可以通过本章的讲解实际动手体会。</p>
        <p>
          <strong>第 10 章：将 GitHub 应用到企业</strong>
        </p>
        <p>总结在企业中采用 GitHub 时需要考虑的问题及一些有用的信息。安全保障、故障信息、事前需要考虑的问题、GitHub Enterprise 的讨论等，这些实际引入 GitHub
          时需要考虑或者了解的知识将在本章中进行讲解。</p>
        <p>
          <strong>附录 A ：辅助 GitHub 的 GUI 客户端</strong>
        </p>
        <p>团队中并不是每个人都对 CLI 得心应手。因此，我们为读者总结了辅助 GitHub 的 GUI 客户端的相关知识。</p>
        <p>
          <strong>附录 B ：通过 Gist 轻松实现代码共享</strong>
        </p>
        <p>Gist 能帮助开发者轻松与其他人共享简单的代码示例或日志，我们将在这部分对 Gist 进行讲解。利用 Gist 可以轻松管理日常的小代码片段。</p>
        <p>　</p>
        <blockquote>
          <p>本书内容以敝社《WEB+DB PRESS》Vol.69 的特辑《详解 GitHub——使用 Pull Request 打造高效率的软件开发》<span class="注释编号">1</span>
            为基础，进行大篇幅扩展与修正后作为图书出版。</p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          詳解 GitHub——Pull Request が織りなす効率的ソフトウェア開発，WEB+DB PRESS vol.69，技术评论社。——译者注
        </p>
        <p>　</p>
        <p>本书的操作示例是在以下环境中进行的。</p>
        <ul>
          <li>
            <p>OS X 10.9.1</p>
          </li>
          <li>
            <p>git 1.8.5.2</p>
          </li>
        </ul>
        <p>部分 Windows 相关解说中使用了 Windows 8。另外，GitHub 相关解说皆以 2014 年 2 月时的版本为基准。</p>
        <p>由于环境和时期不同，操作顺序、页面、运行结果可能会存在差异。</p>
        <p>本书中出现的示例仓库，现阶段主要由译者及尝试 Pull Request 的各位读者进行维护。但是在本书出版后，随着时间推移，可能会发生反应变慢甚至没有反应的情况。烦请参照第 7
          章的内容以及关于示例仓库的讲解，一同努力维护。</p>
        <p>对于您应用本书内容所产生的后果，本书作者、软件开发方及供应方、技术评论社、人民邮电出版社及译者概不负责，特在此声明。</p>
        <p>本书中提及的公司名、制品名，皆是各公司实际使用的注册商标或商标。在正文中并未添加™、©、®标志。</p>
        <p>关于本书的补充信息与勘误等，请参考以下网址。</p>
        <p>
          <a href="http://www.ituring.com.cn/book/1581">http://www.ituring.com.cn/book/1581</a>
        </p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_4">
          <strong>第 1 章　欢迎来到GitHub的世界</strong>
        </h1>
        <p>本章将为您讲解 GitHub 是什么，以及为什么全世界的开发者都在使用它。同时，还会带您一起考察 GitHub 为开源软件世界带来了怎样的变革。</p>
        <h2 id="nav_point_5">
          <strong>1.1　什么是 GitHub</strong>
        </h2>
        <p>GitHub 是为开发者提供 Git 仓库的托管服务。这是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。</p>
        <h3 id="nav_point_6">
          <strong>GitHub 公司与 octocat</strong>
        </h3>
        <p>GitHub 公司总部位于美国旧金山，拥有一只不知是章鱼还是猫的吉祥物 octocat（图 1.1）。图 1.2 中是被改编成各种造型的 octocat 们 <span class="注释编号">1</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a href="http://octodex.github.com/">http://octodex.github.com/</a>
        </p>
        <p class="图"><img src="Image00000.jpg" alt="" width="40%" style="width: 40%" />
        </p>
        <p class="p-img-title">
          <strong>图 1.1　octocat</strong>
        </p>
        <p class="图"><img src="Image00001.jpg" alt="" width="90%" style="width: 90%" />
        </p>
        <p class="p-img-title">
          <strong>图 1.2　octocats</strong>
        </p>
        <h3 id="nav_point_7">
          <strong>并不只是 Git 仓库的托管服务</strong>
        </h3>
        <p>GitHub 除提供 Git 仓库的托管服务外，还为开发者或团队提供了一系列功能，帮助其高效率、高品质地进行代码编写。这些功能将从下一章开始详细讲解。</p>
        <p>GitHub 的创始人之一 Chris Wanstrath 曾有个愿望，那就是能有一个 Git 仓库的托管服务让自己与朋友轻松分享代码，而这便成为了 GitHub 诞生的契机。不过，他也曾经表示：Git
          仓库的托管服务是 GitHub 项目的目标之一，这只是漫长路程上的一个点而已 <span class="注释编号">2</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a
            href="http://www.slideshare.net/rubymeetup/inside-github-with-chris-wanstrath">http://www.slideshare.net/rubymeetup/inside-github-with-chris-wanstrath</a>
        </p>
        <h3 id="nav_point_8">
          <strong>GitHub 的使用情况</strong>
        </h3>
        <p>截至 2013 年 12 月，GitHub 托管的仓库数已超过 1000 万 <span class="注释编号">3</span>
          。全世界每时每刻都有开发者在使用它。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          <a href="https://github.com/features/hosting">https://github.com/features/hosting</a>
        </p>
        <blockquote>
          <p>
            <strong>专栏：GitHub 与 Git 的区别</strong>
          </p>
          <p>在此讲解一下 GitHub 与 Git <span class="注释编号">4</span>
            的区别。GitHub 与 Git 是完全不同的两个东西。本书中，自始至终都以 GitHub 和 Git 的方式区分描述。</p>
          <p>在 Git 中，开发者将源代码存入名叫“Git 仓库”的资料库中并加以使用。而 GitHub 则是在网络上提供 Git 仓库的一项服务。</p>
          <p>也就是说，GitHub 上公开的软件源代码全都由 Git 进行管理。理解 Git，是熟练运用 GitHub 的关键所在。Git 的相关知识，我们将在第 2 章中为您详细讲解。</p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          <a href="http://git-scm.com">http://git-scm.com</a>
        </p>
        <h2 id="nav_point_9">
          <strong>1.2　使用 GitHub 会带来哪些变化</strong>
        </h2>
        <p>GitHub 的出现已使当今世界的软件开发现场发生了翻天覆地的变化。在这场可称之为革命的变革当中，中国也毫不例外地受到了影响。本章中，我们将简单介绍将 GitHub 导入日常开发后会带来哪些变化，供尚未正式使用
          GitHub 的开发者们加以了解。</p>
        <h3 id="nav_point_10">
          <strong>协作形式变化</strong>
        </h3>
        <p>此前，用于辅助多人协同工作的软件层出不穷，然而它们中的大部分又一个个退出了历史的舞台。在这类软件中，群件（Groupware）和 CRM（Customer Relationship
          Management，顾客关系管理）等脱颖而出，被全世界的商业人士所用。您所在的公司想必也导入了这类软件。</p>
        <p>但是，在以程序员为代表的软件开发者之间，一直都没有一个用来辅助多人协同编程的关键性软件。因此软件开发者们往往要将版本管理系统、BUG 跟踪系统、代码审查工具、邮件列表、IRC 等众多工具组合在一起，以实现多人协作。
        </p>
        <p>开发者们已对这种软件开发协作模式司空见惯，然而 GitHub 的出 现为其带来了巨大变化。下面，我们就来介绍 GitHub 的几项功能。</p>
        <h4 id="sigil_toc_id_1">
          <strong>……在开发者之间引发化学反应的 Pull Request</strong>
        </h4>
        <p>在 GitHub
          这个聚集了世界各地软件开发者的地方，有个在过去绝对是无法想象的事正在飞速地进行着——素未谋面的开发者们隔着半个地球的距离共同开发软件。我们不妨称之为开发者之间的化学反应吧。这种事成为可能，都要归功于一个名为 Pull
          Request 的功能（图 1.3）。</p>
        <p class="图"><img src="Image00002.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 1.3　Pull Request 的页面</strong>
        </p>
        <p>Pull Request 是指开发者在本地对源代码进行更改后，向 GitHub 中托管的 Git 仓库请求合并的功能。开发者可以在 Pull Request 上通过评论交流，例如“修正了
          BUG，可以合并一下吗？”以及“我试着做了这样一个新功能，可以合并一下吗？”等。通过这个功能，开发者可以轻松更改源代码，并公开更改的细节，然后向仓库提交合并请求。而且，如果请求的更改与项目的初衷相违，也可以选择拒绝合并。
        </p>
        <p>GitHub 的 Pull Request 不但能轻松查看源代码的前后差别，还可以对指定的一行代码进行评论（图 1.4）。通过这一功能，开发者们可以针对具体的代码进行讨论，使代码审查的工作变得前所未有地惬意。</p>
        <p class="图"><img src="Image00003.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 1.4　针对某行代码进行评论的实际截图</strong>
        </p>
        <h4 id="sigil_toc_id_2">
          <strong>……对特定用户进行评论</strong>
        </h4>
        <p>方便和快捷并不是 Pull Request 的专利。任务管理和 BUG 报告可以通过 Issue 进行交互。如果想让特定用户来看，只要用“@ 用户名”的格式书写，对方便会接到通知（Notifications）<span
            class="注释编号">5</span>
          ，查看 Issue（图 1.5）。由于也提供了 Wiki 功能，开发者可以轻松创建文档，进行公开、共享。Wiki 更新的历史记录也在 Git 中管理，可以让用户轻松更改。</p>
        <p class="注释内容">
          <span class="注释编号下">5</span>
          通知的相关知识将在第 5 章中详细讲解。
        </p>
        <p class="图"><img src="Image00004.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 1.5　写有“@ 用户名”的评论截图</strong>
        </p>
        <h4 id="sigil_toc_id_3">
          <strong>……GitHub Flavored Markdown</strong>
        </h4>
        <p>在 GitHub 上，用户所有用文字输入的功能都可以用 GitHub Flavored
          Markdown（GFM）语法进行描述。这个语法可以让标记变得简单，以此写出的评论与文档也会更容易理解。只记住一个语法便能在多种交流中使用，何乐而不为呢 <span class="注释编号">6</span>
          ？它还有一个很特别的功能，那就是可以在评论中添加文字表情，使用户间的交流更加顺利。</p>
        <p class="注释内容">
          <span class="注释编号下">6</span>
          第 3 章和第 5 章还会有 GFM 的相关讲解。
        </p>
        <p>随着 GitHub 的普及，正在有越来越多的服务开始兼容 Markdown 语法。</p>
        <blockquote>
          <p>
            <strong>专栏：还可以这样写 !!</strong>
          </p>
          <p>GitHub 中可使用的描述方法并不止“@ 用户名”一种。</p>
          <p>输入“@ 组织名”可以让属于该 Organization（组织）的所有成员收到通知 <span class="注释编号">7</span>
            。输入“@ 组织名 / 团队”可以让该团队的所有成员收到通知。这就是同时向多人发送通知的方法。</p>
          <p>输入“# 编号”，会连接到该仓库所对应的 Issue 编号。输入“用户名 / 仓库名 # 编号”则可以连接到指定仓库所对应的 Issue 编号。只要按照这类特定格式书写便会自动创建链接。</p>
          <p>多加利用上述这些功能，可以让交流更有效率。</p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">7</span>
          Organization 的详细内容将在第 10 章中进行讲解。
        </p>
        <h3 id="nav_point_11">
          <strong>能看到更多其他团队的软件</strong>
        </h3>
        <p>GitHub 快捷的环境为开发者带来的合作伙伴，并不只局限于自己团队内部。只要将感兴趣的仓库添加至 Watch 中，就可以在 News Feed 查 看该仓库的相关信息（图 1.6）。</p>
        <p class="图"><img src="Image00005.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 1.6　在 News Feed 中查看各仓库信息</strong>
        </p>
        <p>比如，将全公司共用代码库的仓库添加到 Watch 中，便能在第一时间掌握最新版本的新功能或 BUG 修正的信息。当然，您也可以参与到讨论中去，积极地提出意见。如有必要，还可以通过 Pull Request 提交代码。
        </p>
        <p>将隔壁团队正在开发的仓库添加到 Watch
          中，就可以每天查看他们都在开发什么功能。一旦发现有用的功能或者库，可以立刻运用到自己的开发团队。如果能进一步交流，分割出共用的库，从而建立起新的仓库，便成了不同开发者团队间协作的美谈。</p>
        <h3 id="nav_point_12">
          <strong>与开源软件相同的开发模式</strong>
        </h3>
        <p>将 GitHub 运用到企业中，便会带来与开源软件开发相同的开发模式。已经熟悉开源软件开发的开发者不必专门去学习企业独自采用的工具，就可以直接加入到开发行列。</p>
        <p>反过来说，只要在企业中运用 GitHub，即便是刚刚入职成为程序员的应届毕业生，也可以很快投身到开源软件开发的世界中。</p>
        <p>也就是说，开源软件世界的软件开发与企业内的软件开发将不再有隔阂。在某些企业中，这两者的区别恐怕就是仓库公开与否的区别了。</p>
        <h2 id="nav_point_13">
          <strong>1.3　社会化编程</strong>
        </h2>
        <p>GitHub 这一服务，为开源世界带来了社会化编程的概念。这一概念影响了全世界众多程序员，说其是软件开发方法的一次革命都不为过。在这里，我们将详细解说社会化编程的概念。</p>
        <p>您听过 SOCIAL CODING（以下称为社会化编程）这个词吗？如果没有，那么您见过图 1.7 的 LOGO 吗？</p>
        <p class="图"><img src="Image00006.jpg" alt="" width="43%" style="width: 43%" />
        </p>
        <p class="p-img-title">
          <strong>图 1.7　GitHub 曾经的 LOGO</strong>
        </p>
        <p>这是 GitHub<span class="注释编号">8</span>
          曾经使用过的 LOGO。上面附带着 SOCIAL CODING 这一副标题。2013 年 4 月起，GitHub 开始使用图 1.8 中的 LOGO。</p>
        <p class="注释内容">
          <span class="注释编号下">8</span>
          <a href="https://github.com/">https://github.com/</a>
        </p>
        <p class="图"><img src="Image00007.jpg" alt="" width="43%" style="width: 43%" />
        </p>
        <p class="p-img-title">
          <strong>图 1.8　GitHub 的新 LOGO</strong>
        </p>
        <p>GitHub 这一服务创造了社会化编程的概念。随着 GitHub 的出现，软件开发者们才真正意义上拥有了源代码。世界上任何人都可以比从前更加容易地获得源代码，将其自由更改并加以公开。如今，世界众多程序员都在通过
          GitHub 公开源代码，同时利用 GitHub 支持着自己日常的软件开发。</p>
        <p>在 GitHub
          出现之前，软件开发中只有一小部分人拥有更改源代码的权利，这个特权阶级掌握着开发的主导权。开发者在改写、发布源代码之外，往往需要花更多时间和精力去说服这个特权阶级。这导致了许多起初效率很高的流行软件越发保守化，最终被时代所抛弃。
        </p>
        <p>但是，GitHub 的出现为软件开发者的世界带来了真正意义上的“民主”，让所有人都平等地拥有了更改源代码的权利。这在软件开发领域是一场巨大的革命。而革命领导者 GitHub 的口号便是“社会化编程”。</p>
        <p>接下来，我们将深入理解引发这场革命的社会化编程，同时为您讲解其原动力——GitHub 这一服务的相关概要。GitHub 各个功能将在第 3 章之后为您详细介绍。</p>
        <h2 id="nav_point_14">
          <strong>1.4　为什么需要社会化编程</strong>
        </h2>
        <p>当今的 IT 业界已经没有了终身雇佣制，人才流动性日益增大。可以说，每个月我们都能在一些著名开发者的博客中看到这种现象：月末刚发布“辞职了”的消息，月初就又“入职了”。</p>
        <p>那么，如果您是程序员的面试官，两者之间您会选择哪一位呢？</p>
        <ul>
          <li>
            <p>能查看到以前所写代码的程序员 or 无法查看的程序员</p>
          </li>
          <li>
            <p>精通最新软件的程序员 or 不精通的程序员</p>
          </li>
          <li>
            <p>对语言或软件差异带来的不同文化有所理解的程序员 or 不理解的 程序员</p>
          </li>
        </ul>
        <p>为了不成为后一种程序员，理解社会化编程和 GitHub 至关重要。</p>
        <h3 id="nav_point_15">
          <strong>不要闭目塞听，要接触不同的文化</strong>
        </h3>
        <p>在工作中接触非公开代码的职业程序员们，更应该接触世界上的不同文化，拓展见闻。如果只在公司这一封闭的小世界中敲代码，往往在不知不觉间，手中的技术就变得陈腐不堪了。</p>
        <p>放眼世界，注意那些日新月异的源代码、技术、设计以及文化，会对自己编写的源代码及成果带来巨大影响。笔者自身也曾在知名框架的实现中受到启发，良好地实现了公司内部开发的软件。</p>
        <h3 id="nav_point_16">
          <strong>会写代码的程序员更受青睐</strong>
        </h3>
        <p>在软件开发行业中，Web 业界的变化尤其激烈，能实际编写源代码的程序员大受青睐。</p>
        <p>
          在过去，程序员只需有简单的编程经验，用人单位更重视其人品、协调性、管理能力。但如今，能踏踏实实编写出代码的职业程序员反而更受欢迎。这是由于近年来随着技术的不断发展，开发一项服务需要用到多种编程语言和技术，以求兼容多种硬件设备。在这种背景下，判断一个求职者能否编写项目所需的源代码，最切实可行的办法就是看他实际写出的东西。
        </p>
        <p>如今，GitHub 的出现已经让所有人平等拥有公开源代码的权利。看看 Facebook 或 Twitter 能了解一个人的品性，而看看 GitHub 就能了解一个程序员的实力。</p>
        <p>今后，进行社会化编程的程序员会越来越多，从而成为一种普遍现象。在不远的将来，应聘的成功与否将取决于您曾经编写过的代码。因此，面向全世界的代码公开必将越发重要。以编写代码为生的职业程序员们，更应该进行社会化编程。</p>
        <h3 id="nav_point_17">
          <strong>GitHub 最大的特征是“面向人”</strong>
        </h3>
        <p>这里讲解一下 GitHub 与单纯的仓库托管服务的不同之处，在笔者看来这是一个重点问题。</p>
        <p>GitHub 与以往的仓库托管服务最大的不同点，就在于它以人为中心。</p>
        <p>以往的仓库托管服务都是以项目为中心，每个项目就是一个信息封闭的世界。虽然能够知道一个仓库的管理者是谁，但这个管理者还在做哪些事，我们就不得而知了。</p>
        <p>GitHub 除项目之外，还可以把注意力集中到人身上。我们不但能阅览一个人公开的所有源代码，只要查看其控制面板中的 News Feed，还能知道他对哪些仓库感兴趣，什么时候做过提交等。一个人在 GitHub
          进行的开发是一目了然的 <span class="注释编号">9</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">9</span>
          控制面板的相关知识将在第 5 章中进行详细说明。
        </p>
        <p>您可以将注意力聚焦到感兴趣的人身上。他既可以是您崇拜已久的超级黑客，也可以是同校同学或公司的同事。</p>
        <p>能同时关注人与代码，是 GitHub 为我们带来的一个新的世界。</p>
        <h2 id="nav_point_18">
          <strong>1.5　GitHub 提供的主要功能</strong>
        </h2>
        <p>在 GitHub 上，有许多帮助开发者高效输出优质代码的功能。这里，我们就简单地为您说明这些功能。</p>
        <h3 id="nav_point_19">
          <strong>Git 仓库</strong>
        </h3>
        <p>一般情况下，我们可以免费建立任意个 GitHub 提供的 Git 仓库。但如果需要建立只对特定人物或只对自己公开的私有仓库，则需要依照套餐类型 <span class="注释编号">10</span>
          支付每月最低 7 美元的使用费。</p>
        <p class="注释内容">
          <span class="注释编号下">10</span>
          <a href="https://github.com/plans">https://github.com/plans</a>
        </p>
        <h3 id="nav_point_20">
          <strong>Organization</strong>
        </h3>
        <p>通常来说，个人使用时只要使用个人账户就足够了，但如果是公司，建议使用 Organization 账户。它的优点在于可以统一管理账户和权限，还能统一支付一些费用。</p>
        <p>如果只使用公开仓库，是可以免费创建 Organization 账户的。因此，如果是以交流群或 IT 小团体的形式进行软件开发时不妨试一试。组织或企业使用 GitHub 时需注意的地方将在第 10 章进行详细讲解。
        </p>
        <h3 id="nav_point_21">
          <strong>Issue</strong>
        </h3>
        <p>Issue 功能，是将一个任务或问题分配给一个 Issue 进行追踪和管理的功能。可以像 BUG 管理系统或 TiDD（Ticket-driven Development）的 Ticket 一样使用。在 GitHub
          上，每当进行我们即将讲解的 Pull Request，都会同时创建一个 Issue。</p>
        <p>每一个功能更改或修正都对应一个 Issue，讨论或修正都以这个 Issue 为中心进行。只要查看 Issue，就能知道和这个更改相关的一切信息，并以此进行管理。</p>
        <p>在 Git 的提交信息中写上 Issue 的 ID（例如“#7”），GitHub 就会自动生成从 Issue 到对应提交的链接。另外，只要按照特定的格式描述提交信息，还可以关闭
          Issue。这是一个非常方便的功能，请务必实践一下。详细内容将在第 5 章中为您讲解。</p>
        <h3 id="nav_point_22">
          <strong>Wiki</strong>
        </h3>
        <p>通过 Wiki 功能，任何人都能随时对一篇文章进行更改并保存，因此可以多人共同完成一篇文章。该功能常用在开发文档或手册的编写中。语法方面，可以通过第 5 章讲解的 GFM 语法进行书写。</p>
        <p>Wiki 页也是作为 Git 仓库进行管理的，改版的历史记录会被切实保存下来，使用者可以放心改写。由于其支持克隆至本地进行编辑，所以程序员使用时可以不必开启浏览器。</p>
        <h3 id="nav_point_23">
          <strong>Pull Request</strong>
        </h3>
        <p>开发者向 GitHub 的仓库推送更改或功能添加后，可以通过 Pull Request 功能向别人的仓库提出申请，请求对方合并。</p>
        <p>Pull Request 送出 后，目标仓库的管理者等人将能够查看 Pull Request 的内容及其中包含的代码更改。</p>
        <p>同时，GitHub 还提供了对 Pull Request 和源代码前后差别进行讨论的功能。通过此功能，可以以行为单位对源代码添加评论，让程序员之间高效地交流。</p>
        <p>详细内容及实际发送 Pull Request 的流程将在第 6 章中进行讲解。</p>
        <blockquote>
          <p>
            <strong>专栏：GitHub 上受到瞩目的软件</strong>
          </p>
          <p>在这里为各位介绍几个正在 GitHub 上开发的软件（表 a）（截至 2013 年 12 月）。想必其中很多软件大家都用过或者听过。另外，在 GitHub 上可以随时查看当前备受瞩目的软件 <span
              class="注释编号">11</span>
            。</p>
          <p>
            <strong>表 a　GitHub 上正在开发的知名软件</strong>
          </p>
          <table width="90%" border="1">
            <thead>
              <tr>
                <th>
                  <p class="表头单元格">名称</p>
                </th>
                <th>
                  <p class="表头单元格">解说</p>
                </th>
                <th>
                  <p class="表头单元格">GitHub 的 URL</p>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <p class="表格单元格">Ruby on Rails</p>
                </td>
                <td>
                  <p class="表格单元格">在 Ruby 中使用的一种代表性的开源 Web 框架</p>
                </td>
                <td>
                  <p class="表格单元格">
                    <a href="https://github.com/rails/rails">https://github.com/rails/rails</a>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p class="表格单元格">Node</p>
                </td>
                <td>
                  <p class="表格单元格">最近在 JavaScript 界大受欢迎的平台。又名 Node.js</p>
                </td>
                <td>
                  <p class="表格单元格">
                    <a href="https://github.com/joyent/node">https://github.com/joyent/node</a>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p class="表格单元格">jQuery</p>
                </td>
                <td>
                  <p class="表格单元格">当今所有领域都在应用的 JavaScript 库</p>
                </td>
                <td>
                  <p class="表格单元格">
                    <a href="https://github.com/jquery/jquery">https://github.com/jquery/jquery</a>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p class="表格单元格">Symfony2</p>
                </td>
                <td>
                  <p class="表格单元格">通过 PHP 编写的全栈式 Web 框架</p>
                </td>
                <td>
                  <p class="表格单元格">
                    <a href="https://github.com/symfony/symfony">https://github.com/symfony/symfony</a>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p class="表格单元格">Bootstrap</p>
                </td>
                <td>
                  <p class="表格单元格">可以做出 Twitter 那种界面的组件集</p>
                </td>
                <td>
                  <p class="表格单元格">
                    <a href="https://github.com/twitter/bootstrap">https://github.com/twitter/bootstrap</a>
                  </p>
                </td>
              </tr>
            </tbody>
          </table>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">11</span>
          <a href="https://github.com/trending">https://github.com/trending</a>
        </p>
        <h2 id="nav_point_24">
          <strong>1.6　小结</strong>
        </h2>
        <p>本章就实现了社会化编程的 GitHub 进行了讲解。各部分的详细解说将在随后的章中进行。</p>
        <h3 id="nav_point_25">
          <strong>参考资料</strong>
        </h3>
        <p>如果要更加深入理解社会化编程的概念，建议参考松田明先生的资料（表 1.1）。撰写本章时笔者就参考了这些资料。</p>
        <p>
          <strong>表 1.1　参考资料</strong>
          <span class="注释编号">12</span>
        </p>
        <p class="注释内容">
          <span class="注释编号下">12</span>
          三份资料的原标题依次为『たのしい Rails』『オブジェクト指向ソーシャルコーディングスクリプト言語　Ruby』『ソーシャルコーディングの世界』。——译者注
        </p>
        <table width="90%" border="1">
          <thead>
            <tr>
              <th>
                <p class="表头单元格">标题</p>
              </th>
              <th>
                <p class="表头单元格">URL</p>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <p class="表格单元格">轻松 Rails</p>
              </td>
              <td>
                <p class="表格单元格">
                  <a
                    href="http://www.slideshare.net/a_matsuda/rails-development-that-doesnt-hurt">http://www.slideshare.net/a_matsuda/rails-development-that-doesnt-hurt</a>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p class="表格单元格">面向对象社会化编程脚本语言 Ruby</p>
              </td>
              <td>
                <p class="表格单元格">
                  <a
                    href="https://speakerdeck.com/a_matsuda/object-oriented-social-coding-scripting-language-ruby">https://speakerdeck.com/a_matsuda/object-oriented-social-coding-scripting-language-ruby</a>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p class="表格单元格">社会化编程的世界</p>
              </td>
              <td>
                <p class="表格单元格">
                  <a
                    href="https://speakerdeck.com/u/a_matsuda/p/social-coding">https://speakerdeck.com/u/a_matsuda/p/social-coding</a>
                </p>
              </td>
            </tr>
          </tbody>
        </table>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_26">
          <strong>第 2 章　Git的导入</strong>
        </h1>
        <p>Git 仓库管理功能是 GitHub 的核心。因此，使用 GitHub 之前必须先掌握 Git 的相关知识，同时本地的设备还要安装 Git 的环境。本章我们将为大家讲解使用 Git 所需的知识及各种设置。</p>
        <h2 id="nav_point_27">
          <strong>2.1　诞生背景</strong>
        </h2>
        <p>Git 属于分散型版本管理系统，是为版本管理而设计的软件。</p>
        <p>Linux 的创始人 Linus Torvalds 在 2005 年开发了 Git 的原型程序。当时，由于在 Linux
          内核开发中使用的既有版本管理系统的开发方许可证发生了变更，为了更换新的版本管理系统，Torvalds 开发了 Git。</p>
        <p>Linux 内核的更新速度在全世界也算首屈一指。因此，势必需要一个功能强、性能高的版本管理系统来提高开发速度。</p>
        <p>在当时的开源环境下，虽然已经有数款版本管理软件被开发出来，但功能和性能都差强人意。加之 Git 是由 Linus Torvalds 亲自着手开发的，可以说在功能与性能方面无可挑剔。程序员们愿意接受 Git，很大
          程度上取决于这个背景。</p>
        <p>笔者在从 Subversion<span class="注释编号">1</span>
          改用 Git 时，也对其强大的功能和性能感到震惊。Git 功能多到夸张，让人觉得至今都没能彻底掌握它。同时，它大幅削减了笔者花在版本管理系统上的时间，现在如果没有 Git，软件开发恐怕会是一件非常痛苦的事情。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a href="http://subversion.apache.org/">http://subversion.apache.org/</a>
        </p>
        <p>在发布之初，Git 由于其艰涩难懂，只有部分黑客愿意使用。但随着众多开发者的共同努力，现在它已被全世界的程序员们所采用。</p>
        <h2 id="nav_point_28">
          <strong>2.2　什么是版本管理</strong>
        </h2>
        <p>版本管理就是管理更新的历史记录。它为我们提供了一些在软件开发过程中必不可少的功能，例如记录一款软件添加或更改源代码的过程，回滚到特定阶段，恢复误删除的文件等。</p>
        <p>在 Git 出现以前，人们普遍采用 Subversion 等集中型版本管理系统，而现在 Git 已经成为了主流。由于 GitHub 的普及，想必世界上使用 Git 的人会越来越多。因此要学习版本管理的各位，建议您选择
          Git。</p>
        <h3 id="nav_point_29">
          <strong>集中型与分散型</strong>
        </h3>
        <p>刚才我们提到版本管理系统分为 Subversion 这类集中型的与 Git 这类分散型的，下面就为各位简单说明一下二者的不同点。</p>
        <h4 id="sigil_toc_id_4">
          <strong>……集中型</strong>
        </h4>
        <p>以 Subversion 为代表的集中型，会如图 2.1 所示将仓库集中存放在服务器之中，所以只存在一个仓库。这就是为什么这种版本管理系统会被称作集中型。</p>
        <p class="图"><img src="Image00008.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 2.1　集中型</strong>
        </p>
        <p>
          集中型将所有数据集中存放在服务器当中，有便于管理的优点。但是一旦开发者所处的环境不能连接服务器，就无法获取最新的源代码，开发也就几乎无法进行。服务器宕机时也是同样的道理，而且万一服务器故障导致数据消失，恐怕开发者就再也见不到最新的源代码了。
        </p>
        <h4 id="sigil_toc_id_5">
          <strong>……分散型</strong>
        </h4>
        <p>图 2.2 是以 Git 为代表的分散型的示意图。如图中所示，GitHub 将仓库 Fork 给了每一个用户。Fork 就是将 GitHub 的某个特定仓库复制到自己的账户下。Fork
          出的仓库与原仓库是两个不同的仓库，开发者可以随意编辑。</p>
        <p class="图"><img src="Image00009.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 2.2　分散型</strong>
        </p>
        <p>如图所示，分散型拥有多个仓库，相对而言稍显复杂。不过，由于本地的开发环境中就有仓库，所以开发者不必连接远程仓库就可以进行开发。</p>
        <p>图中只显示了一般的使用流程。实际上，所有仓库之间都可以进行 push 和 pull。即便不通过 GitHub，开发者 A 也可以直接向开发者 B 的仓库进行 push 或
          pull。因此在使用前如果不事先制定规范，初学者往往会搞不清最新的源代码保存在哪里，导致开发失去控制。不过不用担心，只要各位随着本书的讲解亲自动手尝试，想掌握要领并不是一件难事。</p>
        <h3 id="nav_point_30">
          <strong>集中型与分散型哪个更好</strong>
        </h3>
        <p>要说集中型与分散型哪个更好，其实双方都各有优缺点，需要看具体情况而定。不过，随着 Git 与 GitHub 的普及，今后使用分散型的开发者将会占绝大多数。只要规则制定得当，分散型同样能像集中型那样进行管理。</p>
        <p>有些人在学习版本管理的相关知识时，认为该从相对简单的集中型入手，再循序渐进学习分散型。但笔者认为，今后用到集中型的机会很少，所以不必特地绕这个弯路。</p>
        <p>同样，建议想给团队导入版本管理系统的读者选择 GitHub 与
          Git。如果软件开发进行到一半再从集中型转为分散型，不但需要支付高额的费用，还要让开发者花费大量的精力与金钱去重新学习。考虑到今后的各种机遇与挑战，从一开始就选择分散型，必定是各位成功路上的关键一步。</p>
        <p>只要脑中掌握了多个仓库并存的概念，学习分散型并不是什么难事。而且对于刚刚接触这方面知识的人来说，由于没有先入为主的干扰，应该很容易接受这一概念。</p>
        <h2 id="nav_point_31">
          <strong>2.3　安装</strong>
        </h2>
        <p>接下来就让我们在本地环境中实际安装 Git，进行各种设置。</p>
        <h3 id="nav_point_32">
          <strong>Mac 与 Linux</strong>
        </h3>
        <p>最近的 Mac 中都预装了 Git。而各版本的 Linux 中也都以软件包（Package）的形式提供给用户了，所以各位可以直接使用。关于这两个环境特有的详细安装方法，由于篇幅关系恕不赘述。</p>
        <h3 id="nav_point_33">
          <strong>Windows</strong>
        </h3>
        <p>在 Windows 环境中，最简单快捷的方法是使用 msysGit <span class="注释编号">2</span>
          。请按照 Downloads 的向导下载安装包。本书使用的版本是 Git-1.8.4-preview20130916.exe。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a href="http://msysgit.github.io/">http://msysgit.github.io/</a>
        </p>
        <p>安装包下载完毕后，只要双击运行，按照向导一步步安装即可。下面我们对安装时的设定进行讲解。</p>
        <h4 id="sigil_toc_id_6">
          <strong>……组件的选择</strong>
        </h4>
        <p>在图 2.3 的页面中选择需要的组件。由于所有必要组件都已默认勾选，大可直接进入下一步。</p>
        <p class="图"><img src="Image00010.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 2.3　组件的选择</strong>
        </p>
        <h4 id="sigil_toc_id_7">
          <strong>……设置环境变量</strong>
        </h4>
        <p>在图 2.4 的页面中，可以设置调用 Git 的环境变量。本书的讲解只会用到 msysGit 中附属的 Git Bash 命令提示符，所以请选择最上面的 Use Git Bash only，然后进行下一步。</p>
        <p class="图"><img src="Image00011.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 2.4　环境变量的设置</strong>
        </p>
        <h4 id="sigil_toc_id_8">
          <strong>……换行符的处理</strong>
        </h4>
        <p>在图 2.5 所示的页面中，选择换行符的相关设置。</p>
        <p class="图"><img src="Image00012.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 2.5　换行符的转换</strong>
        </p>
        <p>GitHub 中公开的代码大部分都是以 Mac 或 Linux 中的 LF（Line Feed）换行。然而，由于 Windows 中是以 CRLF（Carriage Return ＋ Line
          Feed）换行的，所以在非对应的编辑器中将不能正常显示。</p>
        <p>Git 可以通过设置自动转换这些换行符。使用 Windows 环境的各位，请选择推荐的“Checkout Windows-style, commit Unix-style line
          endings”选项。换行符在签出时会自动转换为 CRLF，在提交时则会自动转换为 LF。</p>
        <p>各位请注意以上这几点，配合当前使用的环境进行安装。</p>
        <h4 id="sigil_toc_id_9">
          <strong>……Git Bash</strong>
        </h4>
        <p>顺利安装好 msysGit 之后，Git Bash 会作为一个应用程序添加进系统，接下来请启动它。双击之后，会弹出一个名为 Git Bash 的命令提示符（图 2.6），它附属于
          msysGit。如果各位是按照本书中介绍的流程进行安装，那么 git 命令就只能在 Git Bash 中使用，在 Windows 附属的命令提示符中则无法运行。</p>
        <p class="图"><img src="Image00013.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 2.6　Git Bash 的运行页面</strong>
        </p>
        <p>从名字中带有 Bash 就不难猜到，Git Bash 中照搬了许多 Bash 命令，习惯 Linux 的人用起来会感觉比 Windows 命令提示符更得心应手。借这个机会，不妨也熟悉一下 Windows 的
          CLI（Command Line Interface，命令行界面）操作。</p>
        <h3 id="nav_point_34">
          <strong>本书所用的环境</strong>
        </h3>
        <p>本书中的示范操作，都是在 OS X 10.9.1 上使用 Git 1.8.5.2 进行。其他大部分环境也都提供了 1.8.x 或 1.7.x
          版本的软件包，所以并不强求末尾的小版本号一致。不过还是建议各位尽量安装最新版的 Git。</p>
        <h2 id="nav_point_35">
          <strong>2.4　初始设置</strong>
        </h2>
        <p>下面我们对本地计算机里安装的 Git 进行设置。</p>
        <h3 id="nav_point_36">
          <strong>设置姓名和邮箱地址</strong>
        </h3>
        <p>首先来设置使用 Git 时的姓名和邮箱地址。名字请用英文输入。</p>
        <pre class="代码无行号">
<code>$ git config --global user.name "Firstname Lastname"
$ git config --global user.email "your_email@example.com"

</code>
</pre>
        <p>这个命令，会在“~/.gitconfig”中以如下形式输出设置文件。</p>
        <pre class="代码无行号">
<code>[user]
  name = Firstname Lastname
  email = your_email@example.com

</code>
</pre>
        <p>想更改这些信息时，可以直接编辑这个设置文件。这里设置的姓名和邮箱地址会用在 Git 的提交日志中。由于在 GitHub 上公开仓库时，这里的姓名和邮箱地址也会随着提交日志一同被公开，所以请不要使用不 便公开的隐私信息。
        </p>
        <p>在 GitHub 上公开代码后，前来参考的程序员可能来自世界任何地方，所以请不要使用汉字，尽量用英文进行描述。当然，如果您不想使用真名，完全可以使用网络上的昵称。</p>
        <h3 id="nav_point_37">
          <strong>提高命令输出的可读性</strong>
        </h3>
        <p>顺便一提，将 color.ui 设置为 auto 可以让命令的输出拥有更高的可读性。</p>
        <pre class="代码无行号">
<code>$ git config --global color.ui auto

</code>
</pre>
        <p>“~/.gitconfig”中会增加下面一行。</p>
        <pre class="代码无行号">
<code>[color]
  ui = auto

</code>
</pre>
        <p>这样一来，各种命令的输出就会变得更容易分辨。</p>
        <h2 id="nav_point_38">
          <strong>2.5　小结</strong>
        </h2>
        <p>本章中，我们从 Git 诞生的背景说起，讲了版本管理系统中集中型和分散型的相关知识。然后还实际安装了 Git，并进行了初始设置。</p>
        <p>如果您是一名开发者，今后使用 Git 的情况必然越来越多。请务必认真进行初始设置。</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_39">
          <strong>第 3 章　使用GitHub的前期准备</strong>
        </h1>
        <p>本章将为各位讲解使用 GitHub 前需要做的一些准备。</p>
        <h2 id="nav_point_40">
          <strong>3.1　使用前的准备</strong>
        </h2>
        <h3 id="nav_point_41">
          <strong>创建账户</strong>
        </h3>
        <p>首先让我们来创建 GitHub 账户。请打开创建账户的页面 <span class="注释编号">1</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a href="https://github.com/join">https://github.com/join</a>
        </p>
        <p>我们会看到如图 3.1 所示的页面。在 Username 一栏中用英文和数字输入要创建的 ID，您的公开页面的 URL（http://github.com/○○）会用到这个 ID。其他项目也请按照页面要求输入。</p>
        <p class="图"><img src="Image00014.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 3.1　账户创建页面</strong>
        </p>
        <p>填写完所有项目后点击 Create an account，就能完成账户的创建。账户创建完成后会直接进入登录状态，用户可以立即开始使用 GitHub。登录状态下用户名会显示在页面的右上方。</p>
        <h3 id="nav_point_42">
          <strong>设置头像</strong>
        </h3>
        <p>在 GitHub 上随处可见的头像（账户独有的标识）是通过 Gravatar<span class="注释编号">2</span>
          服务显示的。使用过 WordPress 的读者可能对它有所了解。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a href="http://cn.gravatar.com/">http://cn.gravatar.com/</a>
        </p>
        <p>只要使用创建 GitHub 账户时注册的邮箱在 Gravatar 上设置头像，GitHub 的头像就会变成您设置好的样子。</p>
        <p>头像并不是使用 GitHub 时的硬性要求，但如果为代码配上编码者的相貌或标识，会让人觉得安心，同时还可能让对方对您产生兴趣。毕竟我们要使用的是能将关注点聚集在人身上的 GitHub，所以建议各位积极地设置头像。
        </p>
        <h3 id="nav_point_43">
          <strong>设置 SSH Key</strong>
        </h3>
        <p>GitHub 上连接已有仓库时的认证，是通过使用了 SSH 的公开密钥认证方式进行的。现在让我们来创建公开密钥认证所需的 SSH Key，并将其添加至 GitHub。已经创建过的读者，请用现有的密钥进行设置 <span
            class="注释编号">3</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          本部分讲解参照了 GitHub 的帮助说明（<a
            href="https://help.github.com/articles/generating-ssh-keys">https://help.github.com/articles/generating-ssh-keys</a>
          ）。
        </p>
        <p>运行下面的命令创建 SSH Key。</p>
        <pre class="代码无行号">
<code>$ ssh-keygen -t rsa -C "your_email@example.com"
Generating public/private rsa key pair.
Enter file in which to save the key
(/Users/your_user_directory/.ssh/id_rsa): 按回车键
Enter passphrase (empty for no passphrase): 输入密码
Enter same passphrase again: 再次输入密码

</code>
</pre>
        <p>“your_email@example.com”的部分请改成您在创建账户时用的邮箱地址。密码需要在认证时输入，请选择复杂度高并且容易记忆的组合。</p>
        <p>输入密码后会出现以下结果。</p>
        <pre class="代码无行号">
<code>Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.
Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub.
The key fingerprint is:
fingerprint值 your_email@example.com
The key's randomart image is:
+--[ RSA 2048]----+
|     .+   +      |
|       = o O .   |
 略

</code>
</pre>
        <p>id_rsa 文件是私有密钥，id_rsa.pub 是公开密钥。</p>
        <h3 id="nav_point_44">
          <strong>添加公开密钥</strong>
        </h3>
        <p>在 GitHub 中添加公开密钥，今后就可以用私有密钥进行认证了。</p>
        <p>点击右上角的账户设定按钮（Account Settings），选择 SSH Keys 菜单之后，就会出现如图3.2的界面。点击Add SSH Key，会出现Title和Key两个输入框。在 Title
          中输入适当的密钥名称。Key 部分请粘贴 id_rsa.pub 文件里的内容。id_rsa.pub 的内容可以用如下方法查看。</p>
        <pre class="代码无行号">
<code>$ cat ~/.ssh/id_rsa.pub
ssh-rsa 公开密钥的内容 your_email@example.com

</code>
</pre>
        <p class="图"><img src="Image00015.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 3.2　SSH Keys</strong>
        </p>
        <p>添加成功之后，创建账户时所用的邮箱会接到一封提示“公共密钥添加完成”的邮件。</p>
        <p>完成以上设置后，就可以用手中的私人密钥与 GitHub 进行认证和通信了。让我们来实际试一试。</p>
        <pre class="代码无行号">
<code>$ ssh -T git@github.com
The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is fingerprint值 .
Are you sure you want to continue connecting (yes/no)? 输入yes

</code>
</pre>
        <p>出现如下结果即为成功。</p>
        <pre class="代码无行号">
<code>Hi hirocastest! You've successfully authenticated, but GitHub does not provide shell access.

</code>
</pre>
        <h3 id="nav_point_45">
          <strong>使用社区功能</strong>
        </h3>
        <p>既然说 GitHub 能够以人为焦 点，那么在创建账户后不妨试试 Follow（关注）别人。在用户信息页面的右上角点击如图 3.3 所示的按钮即可。</p>
        <p class="图"><img src="Image00016.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 3.3　Follow 按钮</strong>
        </p>
        <p>这样一来，您所 Follow 的用户的活动就会显示在您的控制面板页面中。您可以通过这种方法知道那个人在 GitHub 上都做了些什么。</p>
        <p>对于仓库，也可以使用 Watch 功能获取最新的开发信息。如果您经常使用的某个软件正在 GitHub 上进行开发，不妨去 Watch 一下。</p>
        <p>关于这部分的内容还将在第 5 章中详细讲解。</p>
        <h2 id="nav_point_46">
          <strong>3.2　实际动手使用</strong>
        </h2>
        <h3 id="nav_point_47">
          <strong>创建仓库</strong>
        </h3>
        <p>实际创建一个公开的仓库。点击右上角工具栏里的 New repository（图 3.4）图标，创建新的仓库。</p>
        <p class="图"><img src="Image00017.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 3.4　新建仓库的按钮</strong>
        </p>
        <h4 id="sigil_toc_id_10">
          <strong>……Repository name</strong>
        </h4>
        <p>参考图 3.5，在 Repository name 栏中输入仓库的名称。这里我们输入 Hello-World。</p>
        <p class="图"><img src="Image00018.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 3.5　新建仓库的页面</strong>
        </p>
        <h4 id="sigil_toc_id_11">
          <strong>……Description</strong>
        </h4>
        <p>Description 栏中可以设置仓库的说明。这一栏不是必需项，可以留空。</p>
        <h4 id="sigil_toc_id_12">
          <strong>……Public、Private</strong>
        </h4>
        <p>在这一栏可以选择 Public 还是 Private。这里我们选择 Public，创建公开仓库，仓库内的所有内容都会被公开。</p>
        <p>选择 Private 可以创建非公开仓库，用户可以设置访问权限，但这项服务是收费的。</p>
        <h4 id="sigil_toc_id_13">
          <strong>……Initialize this repository with a README</strong>
        </h4>
        <p>在 Initialize this repository with a README 选项上打 钩，随后 GitHub 会自动初始化仓库并设置 README 文件，让用户可以立刻 clone 这个仓库。如果想向
          GitHub 添加手中已有的 Git 仓库，建议不要勾选，直接手动 push。</p>
        <h4 id="sigil_toc_id_14">
          <strong>……Add .gitignore</strong>
        </h4>
        <p>下方左侧的下拉菜单非常方便，通过它可以在初始化时自动生成 .gitignore 文件 <span class="注释编号">4</span>
          。这个设定会帮我们把不需要在 Git 仓库中进行版本管理的文件记录在 .gitignore
          文件中，省去了每次根据框架进行设置的麻烦。下拉菜单中包含了主要的语言及框架，选择今后将要使用的即可。由于本书中我们并不使用任何框架，所以不做选择。</p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          该文件用来描述 Git 仓库中不需管理的文件与目录。
        </p>
        <h4 id="sigil_toc_id_15">
          <strong>……Add a license</strong>
        </h4>
        <p>右侧的下拉菜单可以选择要添加的许可协议文件。如果这个仓库中包含的代码已经确定了许可协议，那么请在这里进行选择。随后将自动生成包含许可协议内容的 LICENSE 文件，用来表明该仓库内容的许可协议。</p>
        <p>输入选择都完成后，点击 Create repository 按钮，完成仓库的创建。</p>
        <h3 id="nav_point_48">
          <strong>连接仓库</strong>
        </h3>
        <p>下面这个 URL 便是刚刚创建的仓库的页面。</p>
        <pre class="代码无行号">
<code>https://github.com/用户名/Hello-World

</code>
</pre>
        <h4 id="sigil_toc_id_16">
          <strong>……README.md</strong>
        </h4>
        <p>README.md 在初始化时已经生成好了。README.md 文件的内容会自动显示在仓库的首页当中。因此，人们一般会在这个文件中标明本仓库所包含的软件的概要、使用流程、许可协议等信息。如果使用 Markdown
          语法进行描述，还可以添加标记，提高可读性。</p>
        <h4 id="sigil_toc_id_17">
          <strong>……GitHub Flavored Markdown</strong>
        </h4>
        <p>在 GitHub 上进行交流时用到的 Issue、评论、Wiki，都可以用 Markdown 语法表述，从而进行标记。准确地说应该是 GitHub Flavored Markdown（GFM）语法。该语法虽然是
          GitHub 在 Markdown 语法基础上扩充而来的，但一般情况下只要按照原本的 Markdown 语法进行描述就可以。</p>
        <p>关于 Markdown 语法的解说，网上也有相关资料可查 <span class="注释编号">5</span>
          。各位不妨一边参考一边实际尝试。</p>
        <p class="注释内容">
          <span class="注释编号下">5</span>
          <a href="http://www.ituring.com.cn/article/775">http://www.ituring.com.cn/article/775</a>
        </p>
        <p>使用 GitHub 后，很多文档都需要用 Markdown 来书写。也就是说，全世界有大量程序员都在使用 Markdown，因此掌握这种语法已经成为程序员的标准技能之一。请各位也务必学会 Markdown 语法。
        </p>
        <h3 id="nav_point_49">
          <strong>公开代码</strong>
        </h3>
        <h4 id="sigil_toc_id_18">
          <strong>……clone 已有仓库</strong>
        </h4>
        <p>接下来我们将尝试在已有仓库中添加代码并加以公开。首先将已有仓库 clone 到身边的开发环境中。clone 时指定的路径请参考图 3.6<span class="注释编号">6</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">6</span>
          git 命令请参考第 4 章。
        </p>
        <p class="图"><img src="Image00019.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 3.6　仓库的路径</strong>
        </p>
        <pre class="代码无行号">
<code>$ git clone git@github.com:hirocastest/Hello-World.git
Cloning into 'Hello-World'...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (3/3), done.
        　
$ cd Hello-World

</code>
</pre>
        <p>这里会要求输入 GitHub 上设置的公开密钥的密码。认证成功后，仓库便会被 clone 至仓库名后的目录中。将想要公开的代码提交至这个仓库再 push 到 GitHub 的仓库中，代码便会被公开。</p>
        <h4 id="sigil_toc_id_19">
          <strong>……编写代码</strong>
        </h4>
        <p>这里我们编写一个 hello_world.php 文件，用来输出“Hello World!”。</p>
        <pre class="代码无行号">
<code>hello_world.php的内容
&lt;?php
    echo "Hello World!";
?&gt;

</code>
</pre>
        <p>由于 hello_word.php 还没有添加至 Git 仓库，所以显示为 Untracked files。</p>
        <pre class="代码无行号">
<code>$ git status
# On branch master
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be committed)
#
#       hello_world.php
nothing added to commit but untracked files present (use "git add" to track)

</code>
</pre>
        <h4 id="sigil_toc_id_20">
          <strong>……提交</strong>
        </h4>
        <p>将 hello_word.php 提交至仓库。这样一来，这个文件就进入了版本管理系统的管理之下。今后的更改管理都交由 Git 进行。</p>
        <pre class="代码无行号">
<code>$ git add hello_world.php
$ git commit -m "Add hello world script by php"
[master d23b909] Add hello world script by php
 1 file changed, 3 insertions(+)
 create mode 100644 hello_world.php

</code>
</pre>
        <p>通过 <code>git add</code>
          命令将文件加入暂存区 <span class="注释编号">7</span>
          ，再通过 <code>git commit</code>
          命令提交。</p>
        <p class="注释内容">
          <span class="注释编号下">7</span>
          在 Index 数据结构中记录文件提交之前的状态。
        </p>
        <p>添加成功后，可以通过 <code>git log</code>
          命令查看提交日志。</p>
        <pre class="代码无行号">
<code>$ git log
commit d23b909caad5d49a281480e6683ce3855087a5da
Author: hirocastest &lt;hohtsuka@gmail.com&gt;
Date:   Tue May 1 14:36:58 2012 +0900
        　
    Add hello world script by php
 略

</code>
</pre>
        <blockquote>
          <p>
            <strong>专栏：公开时的许可协议</strong>
          </p>
          <p>即便在 GitHub 上公开了源代码，也不代表著作者放弃了著作权等权利。代码的权利持有人请选择合适的许可协议。在 GitHub 上，有修正 BSD 许可协议、Apache
            许可协议等多种许可协议供人们选择，不过大多数软件都使用 MIT 许可协议。</p>
          <p>MIT 许可协议具有以下特征。</p>
          <p>
            <strong>被授权人权利：被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权和 / 或贩售软件及软件的副本，及授予被供应人同等权利，唯服从以下义务。</strong>
          </p>
          <p>
            <strong>被授权人义务：在软件和软件的所有副本中都必须包含以上版权声明和本许可声明。</strong>
          </p>
          <p>
            <strong>其他重要特性：此许可协议并非属 copyleft 的自由软件许可协议条款，允许在自由及开放源代码软件或非自由软件（proprietary software）所使用。</strong>
          </p>
          <p>
            <strong>MIT 的内容可依照程序著作权者的需求更改内容。此亦为 MIT 与 BSD（The BSD license, 3-clause BSD license）本质上不同处。</strong>
          </p>
          <p>
            <strong>MIT 许可协议可与其他许可协议并存。另外，MIT 条款也是自由软件基金会（FSF）所认可的自由软件许可协议条款，与 GPL 兼容。</strong>
          </p>
          <p>
            <strong>——MIT 许可证，Wikipedia，<a href="http://zh.wikipedia.org/">http://zh.wikipedia.org/</a>
              ，2015 年 3 月 27 日获取</strong>
          </p>
          <hr />
          <p>详细内容请参阅原文<span class="注释编号">8</span>
            。</p>
          <p>实际使用时，只需将 LICENSE 文件加入仓库，并在 README.md 文件中声明使用了何种许可协议即可。</p>
          <p>使用没有声明许可协议的软件时，以防万一最好直接联系著作者。</p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">8</span>
          <a
            href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</a>
        </p>
        <h4 id="sigil_toc_id_21">
          <strong>……进行 push</strong>
        </h4>
        <p>之后只要执行 push，GitHub 上的仓库就会被更新。</p>
        <pre class="代码无行号">
<code>$ git push
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 328 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:hirocastest/Hello-World.git
   46ff713..d23b909 master -&gt; master

</code>
</pre>
        <p>这样一来代码就在 GitHub 上公开了。不妨实际连接 <a
            href="http://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/Hello-World">http://github.com/用户名/Hello-World</a>
          查看一下。Git 更加详细的操作请查阅第 4 章。</p>
        <h2 id="nav_point_50">
          <strong>3.3　小结</strong>
        </h2>
        <p>本章讲解了初次在 GitHub 建立仓库以及公开代码的流程。完成这些，各位就踏入了 GitHub 的世界。</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_51">
          <strong>第 4 章　通过实际操作学习Git</strong>
        </h1>
        <p>在本章中，我们将学习 Git 相关的基本知识与操作方法。已经将 Git 实际运用于开发的读者大可跳过本章。本章中将要解说的，是理解本书内容所必不可少的一些 Git 操作。请随着我们的解说，一边实际操作，一边学习并掌握
          Git。</p>
        <h2 id="nav_point_52">
          <strong>4.1　基本操作</strong>
        </h2>
        <h3 id="nav_point_53">
          <strong>git init——初始化仓库</strong>
        </h3>
        <p>要使用 Git 进行版本管理，必须先初始化仓库。Git 是使用 <code>git init</code>
          命令进行初始化的。请实际建立一个目录并初始化仓库。</p>
        <pre class="代码无行号">
<code>$ mkdir git-tutorial
$ cd git-tutorial
$ git init
Initialized empty Git repository in /Users/hirocaster/github/github-book
/git-tutorial/.git/

</code>
</pre>
        <p>如果初始化成功，执行了 <code>git init</code>
          命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。</p>
        <p>在 Git
          中，我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。开发者可以通过这种方式获取以往的文件。具体操作指令我们将在后面详细解说。
        </p>
        <h3 id="nav_point_54">
          <strong>git status——查看仓库的状态</strong>
        </h3>
        <p>
          <code>git status</code>
          命令用于显示 Git 仓库的状态。这是一个十分常用的命令，请务必牢记。
        </p>
        <p>工作树和仓库在被操作的过程中，状态会不断发生变化。在 Git 操作过程中时常用 <code>git status</code>
          命令查看当前状态，可谓基本中的基本。下面，就让我们来实际查看一下当前状态。</p>
        <pre class="代码无行号">
<code>$ git status
# On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)

</code>
</pre>
        <p>结果显示了我们当前正处于 master 分支下。关于分支我们会在不久后讲到，现在不必深究。接着还显示了没有可提交的内容。所谓提交（Commit），是指“记录工作树中所有文件的当前状态”。</p>
        <p>尚没有可提交的内容，就是说当前我们建立的这个仓库中还没有记录任何文件的任何状态。这里，我们建立 README.md 文件作为管理对象，为第一次提交做前期准备。</p>
        <pre class="代码无行号">
<code>$ touch README.md
$ git status
# On branch master
#
# Initial commit
## Untracked files:#   (use "git add &lt;file&gt;..." to include in what will
be committed)#
#       README.md
nothing added to commit but untracked files present (use "git add" to track)

</code>
</pre>
        <p>可以看到在 Untracked files 中显示了 README.md 文件。类似地，只要对 Git 的工作树或仓库进行操作，<code>git status</code>
          命令的显示结果就会发生变化。</p>
        <h3 id="nav_point_55">
          <strong>git add——向暂存区中添加文件</strong>
        </h3>
        <p>如果只是用 Git 仓库的工作树创建了文件，那么该文件并不会被记入 Git 仓库的版本管理对象当中。因此我们用 <code>git status</code>
          命令查看 README.md 文件时，它会显示在 Untracked files 里。</p>
        <p>要想让文件成为 Git 仓库的管理对象，就需要用 <code>git add</code>
          命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。</p>
        <pre class="代码无行号">
<code>$ git add README.md
$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file&gt;..." to unstage)
#
#       new file:   README.md
#

</code>
</pre>
        <p>将 README.md 文件加入暂存区后，<code>git status</code>
          命令的显示结果发生了变化。可以看到，README.md 文件显示在 Changes to be committed 中了。</p>
        <h3 id="nav_point_56">
          <strong>git commit——保存仓库的历史记录</strong>
        </h3>
        <p>
          <code>git commit</code>
          命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件。
        </p>
        <h4 id="sigil_toc_id_22">
          <strong>……记述一行提交信息</strong>
        </h4>
        <p>我们来实际运行一下 <code>git commit</code>
          命令。</p>
        <pre class="代码无行号">
<code>$ git commit -m "First commit"
[master (root-commit) 9f129ba] First commit
  1 file changed, 0 insertions(+), 0 deletions(-)
  create mode 100644 README.md

</code>
</pre>
        <p>
          <code>-m</code>
          参数后的 <code>"First commit"</code>
          称作提交信息，是对这个提交的概述。
        </p>
        <h4 id="sigil_toc_id_23">
          <strong>……记述详细提交信息</strong>
        </h4>
        <p>刚才我们只简洁地记述了一行提交信息，如果想要记述得更加详细，请不加 <code>- m</code>
          ，直接执行 <code>git commit</code>
          命令。执行后编辑器就会启动，并显示如下结果。</p>
        <pre class="代码无行号">
<code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file&gt;..." to unstage)
#
#       new file:   README.md
#

</code>
</pre>
        <p>在编辑器中记述提交信息的格式如下。</p>
        <ul>
          <li>
            <p>第一行：用一行文字简述提交的更改内容</p>
          </li>
          <li>
            <p>第二行：空行</p>
          </li>
          <li>
            <p>第三行以后：记述更改的原因和详细内容</p>
          </li>
        </ul>
        <p>只要按照上面的格式输入，今后便可以通过确认日志的命令或工具看到这些记录。</p>
        <p>在以 #（井号）标为注释的 <code>Changes to be committed</code>
          （要提交的更改）栏中，可以查看本次提交中包含的文件。将提交信息按格式记述完毕后，请保存并关闭编辑器，以 #（井号）标为注释的行不必删除。随后，刚才记述的提交信息就会被提交。</p>
        <h4 id="sigil_toc_id_24">
          <strong>……中止提交</strong>
        </h4>
        <p>如果在编辑器启动后想中止提交，请将提交信息留空并直接关闭编辑器，随后提交就会被中止。</p>
        <h4 id="sigil_toc_id_25">
          <strong>……查看提交后的状态</strong>
        </h4>
        <p>执行完 <code>git commit</code>
          命令后再来查看当前状态。</p>
        <pre class="代码无行号">
<code>$ git status
# On branch master
nothing to commit, working directory clean

</code>
</pre>
        <p>当前工作树处于刚刚完成提交的最新状态，所以结果显示没有更改。</p>
        <h3 id="nav_point_57">
          <strong>git log——查看提交日志</strong>
        </h3>
        <p>
          <code>git log</code>
          命令可以查看以往仓库中提交的日志。包括可以查看什么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。关于合并我们会在后面解说。
        </p>
        <p>我们先来看看刚才的 <code>git commit</code>
          命令是否被记录了。</p>
        <pre class="代码无行号">
<code>$ git log
    　
commit 9f129bae19b2c82fb4e98cde5890e52a6c546922
Author: hirocaster &lt;hohtsuka@gmail.com&gt;
Date:   Sun May 5 16:06:49 2013 +0900
    　
    First commit

</code>
</pre>
        <p>如上图所示，屏幕显示了刚刚的提交操作。commit 栏旁边显示的“9f129b……”是指向这个提交的哈希值。Git 的其他命令中，在指向提交时会用到这个哈希值。</p>
        <p>Author 栏中显示我们给 Git 设置的用户名和邮箱地址。Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息。</p>
        <h4 id="sigil_toc_id_26">
          <strong>……只显示提交信息的第一行</strong>
        </h4>
        <p>如果只想让程序显示第一行简述信息，可以在 <code>git log</code>
          命令后加上 <code>--pretty=short</code>
          。这样一来开发人员就能够更轻松地把握多个提交。</p>
        <pre class="代码无行号">
<code>$ git log --pretty=short
        　
commit 9f129bae19b2c82fb4e98cde5890e52a6c546922
Author: hirocaster &lt;hohtsuka@gmail.com&gt;
        　
    First commit

</code>
</pre>
        <h4 id="sigil_toc_id_27">
          <strong>……只显示指定目录、文件的日志</strong>
        </h4>
        <p>只要在 <code>git log</code>
          命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。</p>
        <pre class="代码无行号">
<code>$ git log README.md

</code>
</pre>
        <h4 id="sigil_toc_id_28">
          <strong>……显示文件的改动</strong>
        </h4>
        <p>如果想查看提交所带来的改动，可以加上 <code>- p</code>
          参数，文件的前后差别就会显示在提交信息之后。</p>
        <pre class="代码无行号">
<code>$ git log -p

</code>
</pre>
        <p>比如，执行下面的命令，就可以只查看 README.md 文件的提交日志以及提交前后的差别。</p>
        <pre class="代码无行号">
<code>$ git log -p README.md

</code>
</pre>
        <p>如上所述，<code>git log</code>
          命令可以利用多种参数帮助开发者把握以往提交的内容。不必勉强自己一次记下全部参数，每当有想查看的日志就积极去查，慢慢就能得心应手了。</p>
        <h3 id="nav_point_58">
          <strong>git diff——查看更改前后的差别</strong>
        </h3>
        <p>
          <code>git diff</code>
          命令可以查看工作树、暂存区、最新提交之间的差别。单从字面上可能很难理解，各位不妨跟着笔者的解说亲手试一试。
        </p>
        <p>我们在刚刚提交的 README.md 中写点东西。</p>
        <pre class="代码无行号">
<code># Git教程

</code>
</pre>
        <p>这里用 Markdown 语法写下了一行题目。</p>
        <h4 id="sigil_toc_id_29">
          <strong>……查看工作树和暂存区的差别</strong>
        </h4>
        <p>执行 <code>git diff</code>
          命令，查看当前工作树与暂存区的差别。</p>
        <pre class="代码无行号">
<code>$ git diff
        　
diff --git a/README.md b/README.md
index e69de29..cb5dc9f 100644
--- a/README.md
+++ b/README.md
@@ -0,0 +1 @@
+# Git教程

</code>
</pre>
        <p>由于我们尚未用 <code>git add</code>
          命令向暂存区添加任何东西，所以程序只会显示工作树与最新提交状态之间的差别。</p>
        <p>这里解释一下显示的内容。“+”号标出的是新添加的行，被删除的行则用“-”号标出。我们可以看到，这次只添加了一行。</p>
        <p>用 <code>git add</code>
          命令将 README.md 文件加入暂存区。</p>
        <pre class="代码无行号">
<code>$ git add README.md

</code>
</pre>
        <h4 id="sigil_toc_id_30">
          <strong>……查看工作树和最新提交的差别</strong>
        </h4>
        <p>如果现在执行 <code>git diff</code>
          命令，由于工作树和暂存区的状态并无差别，结果什么都不会显示。要查看与最新提交的差别，请执行以下命令。</p>
        <pre class="代码无行号">
<code>$ git diff HEAD
diff --git a/README.md b/README.md
index e69de29..cb5dc9f 100644
--- a/README.md
+++ b/README.md
@@ -0,0 +1 @@
+# Git教程

</code>
</pre>
        <p>不妨养成这样一个好习惯：在执行 <code>git commit</code>
          命令之前先执行 <code>git diff HEAD</code>
          命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交。这里的 HEAD 是指向当前分支中最新一次提交的指针。</p>
        <p>由于我们刚刚确认过两个提交之间的差别，所以直接运行 <code>git commit</code>
          命令。</p>
        <pre class="代码无行号">
<code>$ git commit -m "Add index"
[master fd0cbf0] Add index
 1 file changed, 1 insertion(+)

</code>
</pre>
        <p>保险起见，我们查看一下提交日志，确认提交是否成功。</p>
        <pre class="代码无行号">
<code>$ git log
commit fd0cbf0d4a25f747230694d95cac1be72d33441d
Author: hirocaster &lt;hohtsuka@gmail.com&gt;
Date:   Sun May 5 16:10:15 2013 +0900
        　
    Add index
        　
commit 9f129bae19b2c82fb4e98cde5890e52a6c546922
Author: hirocaster &lt;hohtsuka@gmail.com&gt;
Date:   Sun May 5 16:06:49 2013 +0900
        　
    First commit

</code>
</pre>
        <p>成功查到了第二个提交。</p>
        <h2 id="nav_point_59">
          <strong>4.2　分支的操作</strong>
        </h2>
        <p>在进行多个并行作业时，我们会用到分支。在这类并行开发的过程中，往往同时存在多个最新代码状态。如图 4.1 所示，从 master 分支创建 feature-A 分支和 fix-B
          分支后，每个分支中都拥有自己的最新代码。master 分支是 Git 默认创建的分支，因此基本上所有开发都是以这个分支为中心进行的。</p>
        <p class="图"><img src="Image00020.jpg" alt="" width="60%" style="width: 60%" />
        </p>
        <p class="p-img-title">
          <strong>图 4.1　从 master 分支创建 feature-A 分支和 fix-B 分支</strong>
        </p>
        <p>不同分支中，可以同时进行完全不同的作业。等该分支的作业完成之后再与 master 分支合并。比如 feature-A 分支的作业结束后与 master 合并，如图 4.2 所示。</p>
        <p class="图"><img src="Image00021.jpg" alt="" width="55%" style="width: 55%" />
        </p>
        <p class="p-img-title">
          <strong>图 4.2　feature-A　分支作业结束后的状态</strong>
        </p>
        <p>通过灵活运用分支，可以让多人同时高效地进行并行开发。在这里，我们将带大家学习与分支相关的 Git 操作。</p>
        <h3 id="nav_point_60">
          <strong>git branch——显示分支一览表</strong>
        </h3>
        <p>
          <code>git branch</code>
          命令可以将分支名列表显示，同时可以确认当前所在分支。让我们来实际运行 <code>git branch</code>
          命令。
        </p>
        <pre class="代码无行号">
<code>$ git branch
* master

</code>
</pre>
        <p>可以看到 master 分支左侧标有“*”（星号），表示这是我们当前所在的分支。也就是说，我们正在 master 分支下进行开发。结果中没有显示其他分支名，表示本地仓库中只存在 master 一个分支。</p>
        <h3 id="nav_point_61">
          <strong>git checkout -b——创建、切换分支</strong>
        </h3>
        <p>如果想以当前的 master 分支为基础创建新的分支，我们需要用到 <code>git checkout -b</code>
          命令。</p>
        <h4 id="sigil_toc_id_31">
          <strong>……切换到 feature-A 分支并进行提交</strong>
        </h4>
        <p>执行下面的命令，创建名为 feature-A 的分支。</p>
        <pre class="代码无行号">
<code>$ git checkout -b feature-A
Switched to a new branch 'feature-A'

</code>
</pre>
        <p>实际上，连续执行下面两条命令也能收到同样效果。</p>
        <pre class="代码无行号">
<code>$ git branch feature-A
$ git checkout feature-A

</code>
</pre>
        <p>创建 feature-A 分支，并将当前分支切换为 feature-A 分支。这时再来查看分支列表，会显示我们处于 feature-A 分支下。</p>
        <pre class="代码无行号">
<code>$ git branch
* feature-A
  master

</code>
</pre>
        <p>feature-A 分支左侧标有“*”，表示当前分支为 feature-A。在这个状态下像正常开发那样修改代码、执行 <code>git add</code>
          命令并进行提交的话，代码就会提交至 feature-A 分支。像这样不断对一个分支（例如 feature-A）进行提交的操作，我们称为“培育分支”。</p>
        <p>下面来实际操作一下。在 README.md 文件中添加一行。</p>
        <pre class="代码无行号">
<code># Git教程
        　
- feature-A

</code>
</pre>
        <p>这里我们添加了 feature-A 这样一行字母，然后进行提交。</p>
        <pre class="代码无行号">
<code>$ git add README.md
$ git commit -m "Add feature-A"
[feature-A 8a6c8b9] Add feature-A
 1 file changed, 2 insertions(+)

</code>
</pre>
        <p>于是，这一行就添加到 feature-A 分支中了。</p>
        <h4 id="sigil_toc_id_32">
          <strong>……切换到 master 分支</strong>
        </h4>
        <p>现在我们再来看一看 master 分支有没有受到影响。首先切换至 master 分支。</p>
        <pre class="代码无行号">
<code>$ git checkout master
Switched to branch 'master'

</code>
</pre>
        <p>然后查看 README.md 文件，会发现 README.md 文件仍然保持原先的状态，并没有被添加文字。feature-A 分支的更改不会影响到 master
          分支，这正是在开发中创建分支的优点。只要创建多个分支，就可以在不互相影响的情况下同时进行多个功能的开发。</p>
        <h4 id="sigil_toc_id_33">
          <strong>……切换回上一个分支</strong>
        </h4>
        <p>现在，我们再切换回 feature-A 分支。</p>
        <pre class="代码无行号">
<code>$ git checkout -
Switched to branch 'feature-A'

</code>
</pre>
        <p>像上面这样用“-”（连字符）代替分支名，就可以切换至上一个分支。当然，将“-”替换成 feature-A 同样可以切换到 feature-A 分支。</p>
        <h3 id="nav_point_62">
          <strong>特性分支</strong>
        </h3>
        <p>Git 与 Subversion（SVN）等集中型版本管理系统不同，创建分支时不需要连接中央仓库，所以能够相对轻松地创建分支。因此，当今大部分工作流程中都用到了特性（Topic）分支。</p>
        <p>特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由 master 分支担当（图
          4.3）。</p>
        <p class="图"><img src="Image00022.jpg" alt="" width="43%" style="width: 43%" />
        </p>
        <p class="p-img-title">
          <strong>图 4.3　特性分支的概念</strong>
        </p>
        <p>之前我们创建了 feature-A 分支，这一分支主要实现 feature-A，除 feature-A 的实现之外不进行任何作业。即便在开发过程中发现了 BUG，也需要再创建新的分支，在新分支中进行修正。</p>
        <p>基于特定主题的作业在特性分支中进行，主题完成后再与 master 分支合并。只要保持这样一个开发流程，就能保证 master 分支可以随时供人查看。这样一来，其他开发者也可以放心大胆地从 master
          分支创建新的特性分支。</p>
        <h3 id="nav_point_63">
          <strong>主干分支</strong>
        </h3>
        <p>主干分支是刚才我们讲解的特性分支的原点，同时也是合并的终点。通常人们会用 master 分支作为主干分支。主干分支中并没有开发到一半的代码，可以随时供他人查看。</p>
        <p>有时我们需要让这个主干分支总是配置在正式环境中，有时又需要用标签 Tag 等创建版本信息，同时管理多个版本发布。拥有多个版本发布时，主干分支也有多个。</p>
        <h3 id="nav_point_64">
          <strong>git merge——合并分支</strong>
        </h3>
        <p>接下来，我们假设 feature-A 已经实现完毕，想要将它合并到主干分支 master 中。首先切换到 master 分支。</p>
        <pre class="代码无行号">
<code>$ git checkout master
Switched to branch 'master'

</code>
</pre>
        <p>然后合并 feature-A 分支。为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 <code>--no-ff</code>
          参数。</p>
        <pre class="代码无行号">
<code>$ git merge --no-ff feature-A

</code>
</pre>
        <p>随后编辑器会启动，用于录入合并提交的信息。</p>
        <pre class="代码无行号">
<code>Merge branch 'feature-A'
    　
# Please enter a commit message to explain why this merge is necessary,
# especially if it merges an updated upstream into a topic branch.
#
# Lines starting with '#' will be ignored, and an empty message aborts
# the commit.

</code>
</pre>
        <p>默认信息中已经包含了是从 feature-A 分支合并过来的相关内容，所以可不必做任何更改。将编辑器中显示的内容保存，关闭编辑器，然后</p>
        <p>就会看到下面的结果。</p>
        <pre class="代码无行号">
<code>Merge made by the 'recursive' strategy.
 README.md | 2 ++
 1 file changed, 2 insertions(+)

</code>
</pre>
        <p>这样一来，feature-A 分支的内容就合并到 master 分支中了。</p>
        <h3 id="nav_point_65">
          <strong>git log --graph——以图表形式查看分支</strong>
        </h3>
        <p>用 <code>git log --graph</code>
          命令进行查看的话，能很清楚地看到特性分支（feature-A）提交的内容已被合并。除此以外，特性分支的创建以及合并也都清楚明了。</p>
        <pre class="代码无行号">
<code>$ git log --graph
    　
*   commit 83b0b94268675cb715ac6c8a5bc1965938c15f62
|\  Merge: fd0cbf0 8a6c8b9
| | Author: hirocaster &lt;hohtsuka@gmail.com&gt;
| | Date:   Sun May 5 16:37:57 2013 +0900
| |
| |     Merge branch 'feature-A'
| |
| * commit 8a6c8b97c8962cd44afb69c65f26d6e1a6c088d8
|/  Author: hirocaster &lt;hohtsuka@gmail.com&gt;
|   Date:   Sun May 5 16:22:02 2013 +0900
|
|       Add feature-A
|
* commit fd0cbf0d4a25f747230694d95cac1be72d33441d
| Author: hirocaster &lt;hohtsuka@gmail.com&gt;
| Date:   Sun May 5 16:10:15 2013 +0900
|
|     Add index
|
* commit 9f129bae19b2c82fb4e98cde5890e52a6c546922
  Author: hirocaster &lt;hohtsuka@gmail.com&gt;
  Date:   Sun May 5 16:06:49 2013 +0900
    　
      First commit

</code>
</pre>
        <p>
          <code>git log --graph</code>
          命令可以用图表形式输出提交日志，非常直观，请大家务必记住。
        </p>
        <h2 id="nav_point_66">
          <strong>4.3　更改提交的操作</strong>
        </h2>
        <h3 id="nav_point_67">
          <strong>git reset——回溯历史版本</strong>
        </h3>
        <p>通过前面学习的操作，我们已经学会如何在实现功能后进行提交，累积提交日志作为历史记录，借此不断培育一款软件。</p>
        <p>Git 的另一特征便是可以灵活操作历史版本。借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。</p>
        <p>在这里，为了让各位熟悉对历史版本的操作，我们先回溯历史版本，创建一个名为 fix-B 的特性分支（图 4.4）。</p>
        <p class="图"><img src="Image00023.jpg" alt="" width="58%" style="width: 58%" />
        </p>
        <p class="p-img-title">
          <strong>图 4.4　回溯历史，创建 fix-B 分支</strong>
        </p>
        <h4 id="sigil_toc_id_34">
          <strong>……回溯到创建 feature-A 分支前</strong>
        </h4>
        <p>让我们先回溯到上一节 feature-A 分支创建之前，创建一个名为 fix-B 的特性分支。</p>
        <p>要让仓库的 HEAD、暂存区、当前工作树回溯到指定状态，需要用到 <code>git reset --hard</code>
          命令。只要提供目标时间点的哈希值 <span class="注释编号">1</span>
          ，就可以完全恢复至该时间点的状态。事不宜迟，让我们执行下面的命令。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          哈希值在每个环境中各不相同，读者请查看自身当前环境中 Add index 的哈希值，进行替换。
        </p>
        <pre class="代码无行号">
<code>$ git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d
HEAD is now at fd0cbf0 Add index

</code>
</pre>
        <p>我们已经成功回溯到特性分支（feature-A）创建之前的状态。由于所有文件都回溯到了指定哈希值对应的时间点上，README.md 文件的内容也恢复到了当时的状态。</p>
        <h4 id="sigil_toc_id_35">
          <strong>……创建 fix-B 分支</strong>
        </h4>
        <p>现在我们来创建特性分支（fix-B）。</p>
        <pre class="代码无行号">
<code>$ git checkout -b fix-B
Switched to a new branch 'fix-B'

</code>
</pre>
        <p>作为这个主题的作业内容，我们在 README.md 文件中添加一行文字。</p>
        <pre class="代码无行号">
<code># Git教程
        　
  - fix-B

</code>
</pre>
        <p>然后直接提交 README.md 文件。</p>
        <pre class="代码无行号">
<code>$ git add README.md
        　
$ git commit -m "Fix B"
[fix-B 4096d9e] Fix B
 1 file changed, 2 insertions(+)

</code>
</pre>
        <p>现在的状态如图 4.5 所示。接下来我们的目标是图 4.6 中所示的状态，即主干分支合并 feature-A 分支的修改后，又合并了 fix-B 的修改。</p>
        <p class="图"><img src="Image00024.jpg" alt="" width="30%" style="width: 30%" />
        </p>
        <p class="p-img-title">
          <strong>图 4.5　当前 fix-B 分支的状态</strong>
        </p>
        <p class="图"><img src="Image00025.jpg" alt="" width="55%" style="width: 55%" />
        </p>
        <p class="p-img-title">
          <strong>图 4.6　fix-B 分支的下一步目标</strong>
        </p>
        <h4 id="sigil_toc_id_36">
          <strong>……推进至 feature-A 分支合并后的状态</strong>
        </h4>
        <p>首先恢复到 feature-A 分支合并后的状态。不妨称这一操作为“推进历史”。</p>
        <p>
          <code>git log</code>
          命令只能查看以当前状态为终点的历史日志。所以这里要使用 <code>git reflog</code>
          命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 <code>git reset --hard</code>
          命令恢复到回溯历史前的状态。
        </p>
        <p>首先执行 <code>git reflog</code>
          命令，查看当前仓库执行过的操作的日志。</p>
        <pre class="代码无行号">
<code>$ git reflog
4096d9e HEAD@{0}: commit: Fix B
fd0cbf0 HEAD@{1}: checkout: moving from master to fix-B
fd0cbf0 HEAD@{2}: reset: moving to fd0cbf0d4a25f747230694d95cac1be72d33441d
83b0b94 HEAD@{3}: merge feature-A: Merge made by the 'recursive' strategy.
fd0cbf0 HEAD@{4}: checkout: moving from feature-A to master
8a6c8b9 HEAD@{5}: checkout: moving from master to feature-A
fd0cbf0 HEAD@{6}: checkout: moving from feature-A to master
8a6c8b9 HEAD@{7}: commit: Add feature-A
fd0cbf0 HEAD@{8}: checkout: moving from master to feature-A
fd0cbf0 HEAD@{9}: commit: Add index
9f129ba HEAD@{10}: commit (initial): First commit

</code>
</pre>
        <p>在日志中，我们可以看到 commit、checkout、reset、merge 等 Git 命令的执行记录。只要不进行 Git 的 GC（Garbage
          Collection，垃圾回收），就可以通过日志随意调取近期的历史状态，就像给时间机器指定一个时间点，在过去未来中自由穿梭一般。即便开发者错误执行了 Git 操作，基本也都可以利用
          <code>git reflog</code>
          命令恢复到原先的状态，所以请各位读者务必牢记本部分。</p>
        <p>从上面数第四行表示 feature-A 特性分支合并后的状态，对应哈希值为 83b0b94<span class="注释编号">2</span>
          。我们将 HEAD、暂存区、工作树恢复到这个时间点的状态。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          哈希值只要输入 4 位以上就可以执行。
        </p>
        <pre class="代码无行号">
<code>$ git checkout master
        　
$ git reset --hard 83b0b94
HEAD is now at 83b0b94 Merge branch 'feature-A'

</code>
</pre>
        <p>之前我们使用 <code>git reset --hard</code>
          命令回溯了历史，这里又再次通过它恢复到了回溯前的历史状态。当前的状态如图 4.7 所示。</p>
        <p class="图"><img src="Image00026.jpg" alt="" width="55%" style="width: 55%" />
        </p>
        <p class="p-img-title">
          <strong>图 4.7　恢复历史后的状态</strong>
        </p>
        <h3 id="nav_point_68">
          <strong>消除冲突</strong>
        </h3>
        <p>现在只要合并 fix-B 分支，就可以得到我们想要的状态。让我们赶快进行合并操作。</p>
        <pre class="代码无行号">
<code>$ git merge --no-ff fix-B
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Recorded preimage for 'README.md'
Automatic merge failed; fix conflicts and then commit the result.

</code>
</pre>
        <p>这时，系统告诉我们 README.md 文件发生了冲突（Conflict）。系统在合并 README.md 文件时，feature-A 分支更改的部分与本次想要合并的 fix-B 分支更改的部分发生了冲突。</p>
        <p>不解决冲突就无法完成合并，所以我们打开 README.md 文件，解决这个冲突。</p>
        <h4 id="sigil_toc_id_37">
          <strong>……查看冲突部分并将其解决</strong>
        </h4>
        <p>用编辑器打开 README.md 文件，就会发现其内容变成了下面这个样子。</p>
        <pre class="代码无行号">
<code># Git教程
        　
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  - feature-A
=======
  - fix-B
&gt;&gt;&gt;&gt;&gt;&gt;&gt; fix-B

</code>
</pre>
        <p>
          <code>=======</code>
          以上的部分是当前 HEAD 的内容，以下的部分是要合并的 fix-B 分支中的内容。我们在编辑器中将其改成想要的样子。
        </p>
        <pre class="代码无行号">
<code># Git教程
        　
  - feature-A
  - fix-B

</code>
</pre>
        <p>如上所示，本次修正让 feature-A 与 fix-B 的内容并存于文件之中。但是在实际的软件开发中，往往需要删除其中之一，所以各位在处理冲突时，务必要仔细分析冲突部分的内容后再行修改。</p>
        <h4 id="sigil_toc_id_38">
          <strong>……提交解决后的结果</strong>
        </h4>
        <p>冲突解决后，执行 <code>git add</code>
          命令与 <code>git commit</code>
          命令。</p>
        <pre class="代码无行号">
<code>$ git add README.md
        　
$ git commit -m "Fix conflict"
Recorded resolution for 'README.md'.
[master 6a97e48] Fix conflict

</code>
</pre>
        <p>由于本次更改解决了冲突，所以提交信息记为 "Fix conflict"。</p>
        <h3 id="nav_point_69">
          <strong>git commit --amend——修改提交信息</strong>
        </h3>
        <p>要修改上一条提交信息，可以使用 <code>git commit --amend</code>
          命令。</p>
        <p>我们将上一条提交信息记为了 "Fix conflict"，但它其实是 fix-B 分支的合并，解决合并时发生的冲突只是过程之一，这样标记实在不妥。于是，我们要修改这条提交信息。</p>
        <pre class="代码无行号">
<code>$ git commit --amend

</code>
</pre>
        <p>执行上面的命令后，编辑器就会启动。</p>
        <pre class="代码无行号">
<code>Fix conflict
    　
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD^1 &lt;file&gt;..." to unstage)
#
#       modified:   README.md
#

</code>
</pre>
        <p>编辑器中显示的内容如上所示，其中包含之前的提交信息。请将提交信息的部分修改为 Merge branch 'fix-B'，然后保存文件，关闭编辑器。</p>
        <pre class="代码无行号">
<code>[master 2e7db6f] Merge branch 'fix-B'

</code>
</pre>
        <p>随后会显示上面这条结果。现在执行 <code>git log --graph</code>
          命令，可以看到提交日志中的相应内容也已经被修改。</p>
        <pre class="代码无行号">
<code>$ git log --graph
    　
*   commit 2e7db6fb0b576e9946965ea680e4834ee889c9d8
|\  Merge: 83b0b94 4096d9e
| | Author: hirocaster &lt;hohtsuka@gmail.com&gt;
| | Date:   Sun May 5 16:58:27 2013 +0900
| |
| |     Merge branch 'fix-B'
| |
| * commit 4096d9e856995a1aafa982aabb52bfc0da656b74
| | Author: hirocaster &lt;hohtsuka@gmail.com&gt;
| | Date:   Sun May 5 16:50:31 2013 +0900
| |
| |     Fix B
| |
* |   commit 83b0b94268675cb715ac6c8a5bc1965938c15f62
|\ \  Merge: fd0cbf0 8a6c8b9
| |/  Author: hirocaster &lt;hohtsuka@gmail.com&gt;
|/|   Date:   Sun May 5 16:37:57 2013 +0900
| |
| |       Merge branch 'feature-A'
| |
| * commit 8a6c8b97c8962cd44afb69c65f26d6e1a6c088d8
|/  Author: hirocaster &lt;hohtsuka@gmail.com&gt;
|   Date:   Sun May 5 16:22:02 2013 +0900
|
|       Add feature-A
|
* commit fd0cbf0d4a25f747230694d95cac1be72d33441d
| Author: hirocaster &lt;hohtsuka@gmail.com&gt;
| Date:   Sun May 5 16:10:15 2013 +0900
|
|     Add index
|
* commit 9f129bae19b2c82fb4e98cde5890e52a6c546922
  Author: hirocaster &lt;hohtsuka@gmail.com&gt;
  Date:   Sun May 5 16:06:49 2013 +0900
    　
      First commit

</code>
</pre>
        <h3 id="nav_point_70">
          <strong>git rebase -i——压缩历史</strong>
        </h3>
        <p>在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。这是个会经常用到的技巧，让我们来实际操作体会一下。</p>
        <h4 id="sigil_toc_id_39">
          <strong>……创建 feature-C 分支</strong>
        </h4>
        <p>首先，新建一个 feature-C 特性分支。</p>
        <pre class="代码无行号">
<code>$ git checkout -b feature-C
Switched to a new branch 'feature-C'

</code>
</pre>
        <p>作为 feature-C 的功能实现，我们在 README.md 文件中添加一行文字，并且故意留下拼写错误，以便之后修正。</p>
        <pre class="代码无行号">
<code># Git教程
        　
  - feature-A
  - fix-B
  - faeture-C

</code>
</pre>
        <p>提交这部分内容。这个小小的变更就没必要先执行 <code>git add</code>
          命令再执行 <code>git commit</code>
          命令了，我们用 <code>git commit -am</code>
          命令来一次完成这两步操作。</p>
        <pre class="代码无行号">
<code>$ git commit -am "Add feature-C"
[feature-C 7a34294] Add feature-C
 1 file changed, 1 insertion(+)

</code>
</pre>
        <h4 id="sigil_toc_id_40">
          <strong>……修正拼写错误</strong>
        </h4>
        <p>现在来修正刚才预留的拼写错误。请各位自行修正 README.md 文件的内容，修正后的差别如下所示。</p>
        <pre class="代码无行号">
<code>$ git diff
diff --git a/README.md b/README.md
index ad19aba..af647fd 100644
--- a/README.md
+++ b/README.md
@@ -2,4 +2,4 @@
        　
   - feature-A
   - fix-B
-  - faeture-C
+  - feature-C

</code>
</pre>
        <p>然后进行提交。</p>
        <pre class="代码无行号">
<code>$ git commit -am "Fix typo"
[feature-C 6fba227] Fix typo
 1 file changed, 1 insertion(+), 1 deletion(-)

</code>
</pre>
        <p>错字漏字等失误称作 typo，所以我们将提交信息记为 " Fix typo"。</p>
        <p>实际上，我们不希望在历史记录中看到这类提交，因为健全的历史记录并不需要它们。如果能在最初提交之前就发现并修正这些错误，也就不会出现这类提交了。</p>
        <h4 id="sigil_toc_id_41">
          <strong>……更改历史</strong>
        </h4>
        <p>因此，我们来更改历史。将 " Fix typo"修正的内容与之前一次的提交合并，在历史记录中合并为一次完美的提交。为此，我们要用到 <code>git rebase</code>
          命令。</p>
        <pre class="代码无行号">
<code>$ git rebase -i HEAD~2

</code>
</pre>
        <p>用上述方式执行 <code>git rebase</code>
          命令，可以选定当前分支中包含 HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。</p>
        <pre class="代码无行号">
<code>pick 7a34294 Add feature-C
pick 6fba227 Fix typo
        　
# Rebase 2e7db6f..6fba227 onto 2e7db6f
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out

</code>
</pre>
        <p>我们将 6fba227 的 Fix typo 的历史记录压缩到 7a34294 的 Add feature-C 里。按照下图所示，将 6fba227 左侧的 pick 部分删除，改写为 fixup。</p>
        <pre class="代码无行号">
<code>pick 7a34294 Add feature-C
fixup 6fba227 Fix typo


</code>
</pre>
        <p>保存编辑器里的内容，关闭编辑器。</p>
        <pre class="代码无行号">
<code>[detached HEAD 51440c5] Add feature-C
 1 file changed, 1 insertion(+)
Successfully rebased and updated refs/heads/feature-C.

</code>
</pre>
        <p>系统显示 rebase 成功。也就是以下面这两个提交作为对象，将 "Fix typo"的内容合并到了上一个提交 "Add feature-C"中，改写成了一个新的提交。</p>
        <ul>
          <li>
            <p>7a34294 Add feature-C</p>
          </li>
          <li>
            <p>6fba227 Fix typo</p>
          </li>
        </ul>
        <p>现在再查看提交日志时会发现 Add feature-C 的哈希值已经不是 7a34294 了，这证明提交已经被更改。</p>
        <pre class="代码无行号">
<code>$ git log --graph
            　
* commit 51440c55b23fa7fa50aedf20aa43c54138171137
| Author: hirocaster &lt;hohtsuka@gmail.com&gt;
| Date:   Sun May 5 17:07:36 2013 +0900
|
|     Add feature-C
|
*   commit 2e7db6fb0b576e9946965ea680e4834ee889c9d8
|\  Merge: 83b0b94 4096d9e
| | Author: hirocaster &lt;hohtsuka@gmail.com&gt;
| | Date:   Sun May 5 16:58:27 2013 +0900
| |
| |     Merge branch 'fix-B'
| |
| * commit 4096d9e856995a1aafa982aabb52bfc0da656b74
| | Author: hirocaster &lt;hohtsuka@gmail.com&gt;
| | Date:   Sun May 5 16:50:31 2013 +0900
| |
| |     Fix B
| |
 省略

</code>
</pre>
        <p>这样一来，Fix typo 就从历史中被抹去，也就相当于 Add feature-C 中从来没有出现过拼写错误。这算是一种良性的历史改写。</p>
        <h3 id="nav_point_71">
          <strong>……合并至 master 分支</strong>
        </h3>
        <pre class="代码无行号">
<code>$ git checkout master
Switched to branch 'master'
        　
$ git merge --no-ff feature-C
Merge made by the 'recursive' strategy.
 README.md | 1 +
 1 file changed, 1 insertion(+)

</code>
</pre>
        <p>master 分支整合了 feature-C 分支。开发进展顺利。</p>
        <h2 id="nav_point_72">
          <strong>4.4　推送至远程仓库</strong>
        </h2>
        <p>Git 是分散型版本管理系统，但我们前面所学习的，都是针对单一本地仓库的操作。下面，我们将开始接触远在网络另一头的远程仓库。远程仓库顾名思义，是与我们本地仓库相对独立的另一个仓库。让我们先在 GitHub
          上创建一个仓库，并将其设置为本地仓库的远程仓库。</p>
        <p>请参考第 3 章的 3.2 节在 GitHub 上新建一个仓库。为防止与其他仓库混淆，仓库名请与本地仓库保持一致，即 git-tutorial。创建时请不要勾选 Initialize this repository
          with a README 选项（图 4.8）。因为一旦勾选该选项，GitHub 一侧的仓库就会自动生成 README
          文件，从创建之初便与本地仓库失去了整合性。虽然到时也可以强制覆盖，但为防止这一情况发生还是建议不要勾选该选项，直接点击 Create repository 创建仓库。</p>
        <p class="图"><img src="Image00027.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 4.8　不要勾选该选项</strong>
        </p>
        <h3 id="nav_point_73">
          <strong>git remote add——添加远程仓库</strong>
        </h3>
        <p>在 GitHub 上创建的仓库路径为“<code>git@github.com:用户名/git-tutorial.git</code>
          ”。现在我们用 <code>git remote add</code>
          命令将它设置成本地仓库的远程仓库 <span class="注释编号">3</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          本节讲解中使用的用户名为 github-book，读者请根据自身环境予以替换。
        </p>
        <pre class="代码无行号">
<code>$ git remote add origin git@github.com:github-book/git-tutorial.git

</code>
</pre>
        <p>按照上述格式执行 <code>git remote add</code>
          命令之后，Git 会自动将 <code>git@github.com:github-book/git-tutorial.git</code>
          远程仓库的名称设置为 origin（标识符）。</p>
        <h3 id="nav_point_74">
          <strong>git push——推送至远程仓库</strong>
        </h3>
        <h4 id="sigil_toc_id_42">
          <strong>……推送至 master 分支</strong>
        </h4>
        <p>如果想将当前分支下本地仓库中的内容推送给远程仓库，需要用到 <code>git push</code>
          命令。现在假定我们在 master 分支下进行操作。</p>
        <pre class="代码无行号">
<code>$ git push -u origin master
Counting objects: 20, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (10/10), done.
Writing objects: 100% (20/20), 1.60 KiB, done.
Total 20 (delta 3), reused 0 (delta 0)
To git@github.com:github-book/git-tutorial.git
 * [new branch]      master -&gt; master
Branch master set up to track remote branch master from origin.

</code>
</pre>
        <p>像这样执行 <code>git push</code>
          命令，当前分支的内容就会被推送给远程仓库 origin 的 master 分支。<code>-u</code>
          参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 <code>git pull</code>
          命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。</p>
        <p>执行该操作后，当前本地仓库 master 分支的内容将会被推送到 GitHub 的远程仓库中。在 GitHub 上也可以确认远程 master 分支的内容和本地 master 分支相同。</p>
        <h4 id="sigil_toc_id_43">
          <strong>……推送至 master 以外的分支</strong>
        </h4>
        <p>除了 master 分支之外，远程仓库也可以创建其他分支。举个例子，我们在本地仓库中创建 feature-D 分支，并将它以同名形式 push 至远程仓库。</p>
        <pre class="代码无行号">
<code>$ git checkout -b feature-D
Switched to a new branch 'feature-D'

</code>
</pre>
        <p>我们在本地仓库中创建了 feature-D 分支，现在将它 push 给远程仓库并保持分支名称不变。</p>
        <pre class="代码无行号">
<code>$ git push -u origin feature-D
Total 0 (delta 0), reused 0 (delta 0)
To git@github.com:github-book/git-tutorial.git
 * [new branch]      feature-D -&gt; feature-D
Branch feature-D set up to track remote branch feature-D from origin.

</code>
</pre>
        <p>现在，在远程仓库的 GitHub 页面就可以查看到 feature-D 分支了。</p>
        <h2 id="nav_point_75">
          <strong>4.5　从远程仓库获取</strong>
        </h2>
        <p>上一节中我们把在 GitHub 上新建的仓库设置成了远程仓库，并向这个仓库 push 了 feature-D 分支。现在，所有能够访问这个远程仓库的人都可以获取 feature-D 分支并加以修改。</p>
        <p>本节中我们从实际开发者的角度出发，在另一个目录下新建一个本地仓库，学习从远程仓库获取内容的相关操作。这就相当于我们刚刚执行过 push 操作的目标仓库又有了另一名新开发者来共同开发。</p>
        <h3 id="nav_point_76">
          <strong>git clone——获取远程仓库</strong>
        </h3>
        <h4 id="sigil_toc_id_44">
          <strong>……获取远程仓库</strong>
        </h4>
        <p>首先我们换到其他目录下，将 GitHub 上的仓库 clone 到本地。注意不要与之前操作的仓库在同一目录下。</p>
        <pre class="代码无行号">
<code>$ git clone git@github.com:github-book/git-tutorial.git
Cloning into 'git-tutorial'...
remote: Counting objects: 20, done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 20 (delta 3), reused 20 (delta 3)
Receiving objects: 100% (20/20), done.
Resolving deltas: 100% (3/3), done.
$ cd git-tutorial

</code>
</pre>
        <p>执行 <code>git clone</code>
          命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master
          分支在内容上是完全相同的。</p>
        <pre class="代码无行号">
<code>$ git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/feature-D
  remotes/origin/master

</code>
</pre>
        <p>我们用 <code>git branch -a</code>
          命令查看当前分支的相关信息。添加 <code>-a</code>
          参数可以同时显示本地仓库和远程仓库的分支信息。</p>
        <p>结果中显示了 remotes/origin/feature-D，证明我们的远程仓库中已经有了 feature-D 分支。</p>
        <h4 id="sigil_toc_id_45">
          <strong>……获取远程的 feature-D 分支</strong>
        </h4>
        <p>我们试着将 feature-D 分支获取至本地仓库。</p>
        <pre class="代码无行号">
<code>$ git checkout -b feature-D origin/feature-D
Branch feature-D set up to track remote branch feature-D from origin.
Switched to a new branch 'feature-D'

</code>
</pre>
        <p>
          <code>-b</code>
          参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了
          origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。
        </p>
        <h4 id="sigil_toc_id_46">
          <strong>……向本地的 feature-D 分支提交更改</strong>
        </h4>
        <p>现在假定我们是另一名开发者，要做一个新的提交。在 README.md 文件中添加一行文字，查看更改。</p>
        <pre class="代码无行号">
<code>$ git diff
diff --git a/README.md b/README.md
index af647fd..30378c9 100644
--- a/README.md
+++ b/README.md
@@ -3,3 +3,4 @@
   - feature-A
   - fix-B
   - feature-C
+  - feature-D

</code>
</pre>
        <p>按照之前学过的方式提交即可。</p>
        <pre class="代码无行号">
<code>$ git commit -am "Add feature-D"
[feature-D ed9721e] Add feature-D
 1 file changed, 1 insertion(+)

</code>
</pre>
        <h4 id="sigil_toc_id_47">
          <strong>……推送 feature-D 分支</strong>
        </h4>
        <p>现在来推送 feature-D 分支。</p>
        <pre class="代码无行号">
<code>$ git push
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 281 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
To git@github.com:github-book/git-tutorial.git
   ca0f98b..ed9721e feature-D -&gt; feature-D

</code>
</pre>
        <p>从远程仓库获取 feature-D 分支，在本地仓库中提交更改，再将 feature-D 分支推送回远程仓库，通过这一系列操作，就可以与其他开发者相互合作，共同培育 feature-D 分支，实现某些功能。</p>
        <h3 id="nav_point_77">
          <strong>git pull——获取最新的远程仓库分支</strong>
        </h3>
        <p>现在我们放下刚刚操作的目录，回到原先的那个目录下。这边的本地仓库中只创建了 feature-D 分支，并没有在 feature-D 分支中进行任何提交。然而远程仓库的 feature-D
          分支中已经有了我们刚刚推送的提交。这时我们就可以使用 git pull 命令，将本地的 feature-D 分支更新到最新状态。当前分支为 feature-D 分支。</p>
        <pre class="代码无行号">
<code>$ git pull origin feature-D
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 3 (delta 1), reused 3 (delta 1)
Unpacking objects: 100% (3/3), done.
From github.com:github-book/git-tutorial
 * branch            feature-D -&gt; FETCH_HEAD
 First, rewinding head to replay your work on top of it...
 Fast-forwarded feature-D to ed9721e686f8c588e55ec6b8071b669f411486b8.

</code>
</pre>
        <p>GitHub 端远程仓库中的 feature-D 分支是最新状态，所以本地仓库中的 feature-D 分支就得到了更新。今后只需要像平常一样在本地进行提交再 push
          给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，不断给 feature-D 增加新功能。</p>
        <p>如果两人同时修改了同一部分的源代码，push 时就很容易发生冲突。所以多名开发者在同一个分支中进行作业时，为减少冲突情况的发生，建议更频繁地进行 push 和 pull 操作。</p>
        <h2 id="nav_point_78">
          <strong>4.6　帮助大家深入理解 Git 的资料</strong>
        </h2>
        <p>至此为止，阅读并理解本书所必需的 Git 操作已经全部讲解完了。但是在实际的开发现场，往往要用到更加高级的 Git 操作。这里，我们向各位介绍一些参考资料，能够帮助各位深入理解 Git 的相关知识。</p>
        <h3 id="nav_point_79">
          <strong>Pro Git</strong>
        </h3>
        <p>
          <em>Pro Git</em>
          <span class="注释编号">4</span>
          由就职于 GitHub 公司的 Scott Chacon<span class="注释编号">5</span>
          执笔，是一部零基础的 Git 学习资料。基于知识共享的 CC BY-NC-SA 3.0 许可协议，各位可以免费阅读到包括简体中文在内的各国语言版本。
        </p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          <a href="http://git-scm.com/book/zh/v1">http://git-scm.com/book/zh/v1</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">5</span>
          <a href="https://github.com/schacon">https://github.com/schacon</a>
        </p>
        <h3 id="nav_point_80">
          <strong>LearnGitBranching</strong>
        </h3>
        <p>LearnGitBranching<span class="注释编号">6</span>
          是学习 Git 基本操作的网站（图 4.9）。注重树形结构的学习方式非常适合初学者使用，点击右下角的地球标志还可切换各种语言进行学习。</p>
        <p class="注释内容">
          <span class="注释编号下">6</span>
          <a href="http://pcottle.github.io/learnGitBranching/">http://pcottle.github.io/learnGitBranching/</a>
        </p>
        <p class="图"><img src="Image00028.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 4.9　LearnGitBranching（简体中文版）</strong>
        </p>
        <h3 id="nav_point_81">
          <strong>tryGit</strong>
        </h3>
        <p>通过 tryGit<span class="注释编号">7</span>
          我们可以在 Web 上一边操作一边学习 Git 的基本功能（图 4.10）。很可惜该教程只有英文版。</p>
        <p class="注释内容">
          <span class="注释编号下">7</span>
          <a href="http://try.github.io/">http://try.github.io/</a>
        </p>
        <p class="图"><img src="Image00029.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 4.10　tryGit</strong>
        </p>
        <h2 id="nav_point_82">
          <strong>4.7　小结</strong>
        </h2>
        <p>本章就理解本书所必需的 Git 操作进行了讲解。只要掌握了本章的知识，就足以应付日常开发中的大部分操作了。</p>
        <p>遇到不常用的特殊操作时，还请各位读者查阅本书介绍的参考资料，确保操作的正确性。</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_83">
          <strong>第 5 章　详细解说GitHub的功能</strong>
        </h1>
        <p>GitHub 为实现社会化编程提供了诸多功能。本章就请各位读者随我们一起边看页面边学习，加深对 GitHub 丰富功能的理解。</p>
        <h2 id="nav_point_84">
          <strong>5.1　键盘快捷键</strong>
        </h2>
        <p>在 GitHub 中，很多页面都可以使用键盘快捷键。熟悉键盘操作，能够让 GitHub 变得更加便捷。</p>
        <p>在各个页面按下 shift ＋ / 都可以打开键盘快捷键一览表（图 5.1），查看当前页面的快捷键。如果想要感受更加快捷的操作，不妨亲自试一试。</p>
        <p class="图"><img src="Image00030.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.1　按下 shift ＋ / 显示快捷键一览表</strong>
        </p>
        <h2 id="nav_point_85">
          <strong>5.2　工具栏</strong>
        </h2>
        <h3 id="nav_point_86">
          <strong>关于 UI</strong>
        </h3>
        <p>工具栏常驻于各个页面的上端，让我们先来讲解它的相关知识（图 5.2）。</p>
        <p class="图"><img src="Image00031.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.2　工具栏</strong>
        </p>
        <h4 id="sigil_toc_id_48">
          <strong>……1 LOGO</strong>
        </h4>
        <p>点击 GitHub 的 LOGO 就会进入控制面板。控制面板的相关知识将在后面讲解。</p>
        <h4 id="sigil_toc_id_49">
          <strong>……2 Notifications</strong>
        </h4>
        <p>这一图标用于提示用户是否有新的通知。当图标为蓝色时表示有未读通知。用户在新建 Issue、被评论、进行 Pull Request 等时都会收到通知。另外，按照默认设置，用户在 GitHub
          收到的通知会同时发送到该用户的注册邮箱。邮箱接收通知的相关设置在 Account settings 中进行 <span class="注释编号">1</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a href="https://github.com/settings/notifications">https://github.com/settings/notifications</a>
        </p>
        <h4 id="sigil_toc_id_50">
          <strong>……3 搜索窗口</strong>
        </h4>
        <p>在这里输入想找的用户或代码片段，就可以搜索到与之相关的信息。</p>
        <h4 id="sigil_toc_id_51">
          <strong>……4 Explore</strong>
        </h4>
        <p>从各个角度介绍 GitHub 上的热门软件。</p>
        <ul>
          <li>
            <p>GitHub 公司特别介绍的软件（附开发者制作的视频）</p>
          </li>
          <li>
            <p>按语言筛选本日 / 周 / 月的热门仓库 / 开发者 <span class="注释编号">2</span>
            </p>
          </li>
        </ul>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a href="https://github.com/trending">https://github.com/trending</a>
        </p>
        <p>在这里有机会了解到最尖端的技术和软件。作为一名程序员，可以在上面找到许多灵感。建议各位定期关注一下这里。笔者也经常借助语言筛选器查询各语言的顶尖代码库。</p>
        <h4 id="sigil_toc_id_52">
          <strong>……5 Gist</strong>
        </h4>
        <p>Gist 功能主要用于管理及发布一些没必要保存在仓库中的代码，比如小的代码片段等。笔者就经常把一些随便编写的脚本代码等放在 Gist 中。系统会自动管理更新历史，并且提供了 Fork 功能。另外，通过 Gist
          还可以很方便地为同事编写代码示例。</p>
        <p>在 Gist 上添加的代码示例可以嵌入博客中。当然，如果选择了语言，还会自动添加语法高亮。详细介绍请参考附录 B。</p>
        <h4 id="sigil_toc_id_53">
          <strong>……6 Blog</strong>
        </h4>
        <p>这是到 GitHub 公司官方博客的超链接，GitHub 公司会在上面发布通知。新功能的通知、新入职员工的介绍、drinkup 聚会的信息等都会在上面定期发布。</p>
        <h4 id="sigil_toc_id_54">
          <strong>……7 Help</strong>
        </h4>
        <p>GitHub 相关的帮助。虽然只有英文版，但用的都是比较简单的英文，遇到不懂的地方不妨在这里查一下。</p>
        <h4 id="sigil_toc_id_55">
          <strong>……8 头像、用户名</strong>
        </h4>
        <p>点击后会显示用户的个人信息页面。个人信息页面将在后面进行讲解。</p>
        <h4 id="sigil_toc_id_56">
          <strong>……9 Create a new...</strong>
        </h4>
        <p>创建新的 Git 仓库或 Organization，向 Organization 添加成员、小组、仓库，为仓库添加 Issue 或 collaborator 等操作的菜单都聚集在这里。显示内容会根据当前页面不同而改变。
        </p>
        <h4 id="sigil_toc_id_57">
          <strong>……10 Account settings</strong>
        </h4>
        <p>Account settings 的图标是一把螺丝刀和一柄锤子，点击它可以打开账户设置页面。在这里可以进行个人信息、安全管理、付费方案的设置，各位在使用 GitHub 时请务必浏览一遍。</p>
        <h4 id="sigil_toc_id_58">
          <strong>……11 Sign out</strong>
        </h4>
        <p>点击这个按钮可以退出 GitHub。</p>
        <h2 id="nav_point_87">
          <strong>5.3　控制面板</strong>
        </h2>
        <h3 id="nav_point_88">
          <strong>关于 UI</strong>
        </h3>
        <p>现在为各位讲解登录 GitHub 时最先显示在我们眼前的控制面板（图 5.3）。</p>
        <p class="图"><img src="Image00032.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.3　控制面板</strong>
        </p>
        <h4 id="sigil_toc_id_59">
          <strong>……1 News Feed</strong>
        </h4>
        <p>显示当前已 Follow 的用户和已 Watch 的项目的活动信息，用户可以在这里查看最新动向。将右上角 RSS 标志的 URL 添加到 RSS 阅读器中，还可以通过 RSS 查看。</p>
        <h4 id="sigil_toc_id_60">
          <strong>……2 Pull Requests</strong>
        </h4>
        <p>显示用户已进行过的 Pull Request。通过这里，开发者可以很方便地追踪 Pull Request 的后续情况。</p>
        <h4 id="sigil_toc_id_61">
          <strong>……3 Issues</strong>
        </h4>
        <p>在这里可以查看用户拥有权限的仓库或分配给自己的 Issue。当用户同时进行多个项目时，可以在这里一并查看 Issue。</p>
        <h4 id="sigil_toc_id_62">
          <strong>……4 Stars</strong>
        </h4>
        <p>以列表的形式显示用户添加了 Star 的仓库。有些仓库需要经常查找，但又不必在 Watch 中频繁显示详细信息时，可以给这些仓库添加 Star，方便自己随时在这一栏中找到它们。</p>
        <h4 id="sigil_toc_id_63">
          <strong>……5 Broadcast</strong>
        </h4>
        <p>主要用于接收 GitHub 公司发来的通知或使用技巧的小贴士。</p>
        <h4 id="sigil_toc_id_64">
          <strong>……6 Repositories you contribute to</strong>
        </h4>
        <p>显示用户做过贡献的仓库。按贡献时间的先后顺序排列。</p>
        <h4 id="sigil_toc_id_65">
          <strong>……7 Your Repositories</strong>
        </h4>
        <p>按更新时间顺序显示用户的仓库。标有钥匙图案的是非公开仓库，标有类似字母 Y 图案的是用户 Fork 过的仓库。</p>
        <h2 id="nav_point_89">
          <strong>5.4　个人信息</strong>
        </h2>
        <p>访问下述 URL，就可以看到各位的个人信息。</p>
        <pre class="代码无行号">
<code>https://github.com/用户名

</code>
</pre>
        <h3 id="nav_point_90">
          <strong>关于 UI</strong>
        </h3>
        <p>我们以 Chris Wanstrath 的个人信息页（图 5.4）为例进行讲解。</p>
        <p class="图"><img src="Image00033.jpg" alt="图像说明文字" />
        </p>
        <p class="p-img-title">
          <strong>图 5.4　个人信息</strong>
        </p>
        <h4 id="sigil_toc_id_66">
          <strong>……1 用户信息</strong>
        </h4>
        <p>这里显示注册用户的基本信息，包括姓名、所属公司、邮箱地址、已加入的 Organization 等。如果对该用户感兴趣，可以点击页面右上角的 Follow 按钮（已经 Follow 的用户会显示
          Unfollow）。这样一来，这个人在 GitHub 上的活动都会显示在您的 News Feed 中。</p>
        <h4 id="sigil_toc_id_67">
          <strong>……2 Popular Repositories</strong>
        </h4>
        <p>显示公开仓库中受欢迎的、拥有大量 Star 的部分热门仓库。</p>
        <h4 id="sigil_toc_id_68">
          <strong>……3 Repositories contributed to</strong>
        </h4>
        <p>按时间的先后顺序显示该用户做过贡献的部分仓库。该用户可能是这个仓库的软件开发者，也可能只是通过发送 Pull Request 等方式对该仓库做过某些贡献。</p>
        <h4 id="sigil_toc_id_69">
          <strong>……4 Public contributions</strong>
        </h4>
        <p>一格表示一天，记录当日用户对拥有读取权限的仓库的大致贡献度。贡献度的衡量标准包括发送 Pull Request 的次数、写 Issue
          的次数、进行提交的次数等。颜色越深代表贡献度越高。一名程序员绿色的天数越多，证明他对 GitHub 越熟悉。</p>
        <h4 id="sigil_toc_id_70">
          <strong>……5 Contribution Activity</strong>
        </h4>
        <p>按时间顺序显示具体贡献活动的链接。</p>
        <h4 id="sigil_toc_id_71">
          <strong>……6 Repositories</strong>
        </h4>
        <p>显示该用户公开的仓库（图 5.5）。Fork 来的仓库也显示在这里。</p>
        <p class="图"><img src="Image00034.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.5　Repositories 标签页</strong>
        </p>
        <p>仓库名称、简要说明、使用的语言、最终更新日期都会出现在列表中。星形图案旁边的数字表示给这个仓库添加 Star 的人数，再旁边是被 Fork 数。</p>
        <p>背景显示的图标表示这个仓库的更新频率。横向为时间轴，右侧为最新时间。表中色块越高，该仓库的更新频率也就越高。</p>
        <h4 id="sigil_toc_id_72">
          <strong>……7 Public Activity</strong>
        </h4>
        <p>显示该用户的公开活动（图 5.6）。活动就是指这个用户做了什么，比如向仓库进行提交或者 Pull Request 等，其大量的公开信息都会记录在这里。</p>
        <p class="图"><img src="Image00035.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.6　Public Activity 标签页</strong>
        </p>
        <p>从这里可以了解到该用户平常都在 GitHub 上做些什么。比如查看一下崇拜已久的程序员的公开活动，就可以知道他现在关注些什么，或者正在热心于开发些什么。</p>
        <h2 id="nav_point_91">
          <strong>5.5　仓库</strong>
        </h2>
        <p>仓库的 URL 形式如下所示。</p>
        <pre class="代码无行号">
<code>https://github.com/用户名/仓库名

</code>
</pre>
        <p>这个页面可以说是各个软件的大门。循着目录找下去我们就可以查阅自己想要的文件。如果有相应权限，还可以对文件的内容直接进行编辑、提交。</p>
        <h3 id="nav_point_92">
          <strong>关于 UI</strong>
        </h3>
        <p>我们以图 5.7 为例进行说明。特别重要的项目会在本章后半部分重新详细讲解。</p>
        <p class="图"><img src="Image00036.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.7　仓库页面</strong>
        </p>
        <h4 id="sigil_toc_id_73">
          <strong>……1 用户名（组织名）/仓库名</strong>
        </h4>
        <p>左上角图标旁边显示的是用户名和仓库名。斜线左侧为用户名。使用 GitHub 的组织账户时，这一部分则为组织名。斜线右侧是仓库名。</p>
        <h4 id="sigil_toc_id_74">
          <strong>……2 Watch/Star/Fork</strong>
        </h4>
        <p>眼睛图标旁边写着 Watch 字样。点击这个按钮就可以 Watch 该仓库，今后该仓库的更新信息会显示在用户的公开活动中。Star 旁边的数字表示给这个仓库添加 Star 的人数。这个数越高，代表该仓库越受关注。
        </p>
        <p>Watch 与 Star 有所不同，Watch 之后该仓库的相关信息会在后述的 Notifications 中显示，让用户可以追踪仓库的内容，而 Star 更像是书签，让用户将来可以在 Star
          标记的列表中找到该仓库。另外，Star 数还是 GitHub 上判断仓库热门程度的指标之一。</p>
        <p>旁边的分叉图标是 Fork 按钮。后面的数字代表该仓库被 Fork 至各用户仓库的次数。这个数字越大，表示参与这个仓库开发的人越多。</p>
        <h4 id="sigil_toc_id_75">
          <strong>……3 Code</strong>
        </h4>
        <p>显示该仓库中的文件列表。仓库名下方是该仓库的简单说明和 URL。</p>
        <h4 id="sigil_toc_id_76">
          <strong>……4 Issue</strong>
        </h4>
        <p>用于 BUG 报告、功能添加、方向性讨论等，将这些以 Issue 形式进行管理。Pull Request 时也会创建 Issue。旁边显示的数字是当前处于 Open 状态的 Issue 数。</p>
        <h4 id="sigil_toc_id_77">
          <strong>……5 Pull Requests</strong>
        </h4>
        <p>在 Pull Requests 中可以列表查看并管理 Pull Request。代码的更改和讨论都可以在这里进行。旁边显示的数字表示尚未 Close 的 Pull Request 的数量。</p>
        <h4 id="sigil_toc_id_78">
          <strong>……6 Wiki</strong>
        </h4>
        <p>Wiki 是一种比 HTML 语法更简单的页面描述功能。常用于记录开发者之间应该共享的信息或软件文档。数字表示当前 Wiki 的页面数量。</p>
        <h4 id="sigil_toc_id_79">
          <strong>……7 Pulse</strong>
        </h4>
        <p>显示该仓库最近的活动信息。该仓库中的软件是无人问津，还是在火热地开发之中，从这里可以一目了然。</p>
        <h4 id="sigil_toc_id_80">
          <strong>……8 Graphs</strong>
        </h4>
        <p>以图表形式显示该仓库的各项指标。让用户轻松了解该仓库的活动倾向。</p>
        <h4 id="sigil_toc_id_81">
          <strong>……9 Network</strong>
        </h4>
        <p>以图表形式直观地显示出当前仓库的状态及 Fork 出的仓库的状态。同时会显示成员列表。</p>
        <h4 id="sigil_toc_id_82">
          <strong>……10 Settings</strong>
        </h4>
        <p>这里可以更改当前仓库的设置。用户必须拥有更改设置的权限才能看到这个菜单。</p>
        <h4 id="sigil_toc_id_83">
          <strong>……11 SSH clone URL</strong>
        </h4>
        <p>clone 仓库时所需的 URL。点击右侧的剪贴板图标可以将 URL 复制到剪贴板中。点击 HTTPS、SSH、Subversion 图标可以切换至相应协议的 URL。</p>
        <h4 id="sigil_toc_id_84">
          <strong>……12 Clone in Desktop</strong>
        </h4>
        <p>启动 GitHub 专用的客户端应用程序并进行 clone。GitHub 专用的客户端应用程序有 Windows 版和 Mac 版，详细情况请参考附录 A 的讲解。</p>
        <h4 id="sigil_toc_id_85">
          <strong>……13 Download ZIP</strong>
        </h4>
        <p>将当前正在阅览的分支中的文件以 ZIP 形式打包下载。这种方式与 Git 的 clone 不同，只是单纯将文件下载到本地，所以无法通过 Git
          查看日志或对仓库进行更改。如果只是想使用仓库中的文件，比较适合用这种方式下载。</p>
        <h4 id="sigil_toc_id_86">
          <strong>……a commits</strong>
        </h4>
        <p>在这里可以查看当前分支的提交历史。左侧的数字表示提交数。</p>
        <h4 id="sigil_toc_id_87">
          <strong>……b branches</strong>
        </h4>
        <p>可以查看仓库的分支列表。左侧的数字表示当前拥有的分支数。</p>
        <h4 id="sigil_toc_id_88">
          <strong>……c releases</strong>
        </h4>
        <p>显示仓库的标签（Tag）列表。同时可以将标签加入时的文件以归档形式（ZIP、tar.gz）下载到本地。软件在版本升级时一般都会打标签，如果需要特定版本的文件，可以从这里寻找。</p>
        <h4 id="sigil_toc_id_89">
          <strong>……d contributors</strong>
        </h4>
        <p>显示对该仓库进行过提交的程序员名单。如果您也对该仓库发送过 Pull Request 并且被采纳，那么在这里就能找到自己的名字。左边的数字是程序员的人数。</p>
        <h4 id="sigil_toc_id_90">
          <strong>……e Compare and review</strong>
        </h4>
        <p>可以查看当前显示的分支与其他分支的差别，以便进行审查。点击这个按钮，会出现一个页面让用户选择比较对象。</p>
        <h4 id="sigil_toc_id_91">
          <strong>……f branch</strong>
        </h4>
        <p>显示当前分支的名称。从这里可以切换仓库内分支，查看其他分支的文件。</p>
        <h4 id="sigil_toc_id_92">
          <strong>……g path</strong>
        </h4>
        <p>显示当前文件列表的路径。点击上级目录的链接就可以直接移动至该目录。</p>
        <h4 id="sigil_toc_id_93">
          <strong>……h Fork this project and Create a new file</strong>
        </h4>
        <p>可以在当前仓库的路径下新建文件。新建文件作为一个新的提交，记录在 Fork 出的分支中。</p>
        <p>如果用户对该仓库拥有足够权限，该项则显示为 Create a new file，用户可以直接在当前路径下新建文件。</p>
        <h4 id="sigil_toc_id_94">
          <strong>……i files</strong>
        </h4>
        <p>可以查看当前分支的文件。顶端为最新提交的相关信息。在文件或目录的列表中，从左至右分别为文件名称、该文件最新的提交日志、更新日期。点击目录或文件就可以查看相应内容。</p>
        <p>如果当前目录中包含 README 文件，那么在文件列表下方会显示 README。一般而言，README 中记录着该仓库中软件的说明或使用方法以及许可协议等信息，请务必加以阅读。</p>
        <h3 id="nav_point_93">
          <strong>文件的相关操作</strong>
        </h3>
        <p>点开文件后会显示出文件的内容，同时右上角会显示用于该文件的菜单（图 5.8）。Edit 可以对文件内容进行编辑并提交。Raw 可以直接在浏览器中显示该文件的内容。使用这个 URL，就能通过 HTTPS
          协议获取该文件。Blame 能够按行显示最新提交的信息。History 可以查看该文件的历史记录。Delete 可以删除这个文件。</p>
        <p class="图"><img src="Image00037.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.8　文件相关操作的菜单</strong>
        </p>
        <p>文件内容的左侧会显示该文件的行号。假如我们点击第 10 行的行号，这一行就会被高亮标记为黄色，同时 URL 末尾会自动添加“#L10”。使用这个
          URL，程序员们在交流时，就可以将讨论明确指向某一行。另外，如果将“#L10”改成“#L10-15”，则会标记该文件的第 10 ～ 15 行。各位不妨将这点记下来，以便日后应用。</p>
        <blockquote>
          <p>
            <strong>专栏：通过部分名称搜索文件</strong>
          </p>
          <p>各位不妨在仓库页面试着按下键盘的 t 键，然后输入要找的目录或文件的部分名称。筛选器会在仓库的目录和文件中进行筛选，搜索出您要找的文件（图 a）。</p>
          <p>这种方式要比一级级查看目录和文件快得多，请积极利用。</p>
          <p class="图"><img src="Image00038.jpg" alt="{%}" />
          </p>
          <p class="p-img-title">
            <strong>图 a　搜索 yml</strong>
          </p>
        </blockquote>
        <h3 id="nav_point_94">
          <strong>查看差别</strong>
        </h3>
        <p>在 GitHub 上，直接修改 URL 就可以让用户以多种形式查看差别。这里我们以 Ruby on Rails 的仓库 <span class="注释编号">3</span>
          为例，给各位介绍直接修改 URL 的一些技巧。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          <a href="https://github.com/rails/rails/">https://github.com/rails/rails/</a>
        </p>
        <h4 id="sigil_toc_id_95">
          <strong>……查看分支间的差别</strong>
        </h4>
        <p>比如我们想查看 4-0-stable 分支与 3-2-stable 分支之间的差别，可以像下面这样将分支名加到 URL 里。</p>
        <pre class="代码无行号">
<code>https://github.com/rails/rails/compare/4-0-stable...3-2-stable

</code>
</pre>
        <p>这样，就可以查看两个分支间的差别了（图 5.9）。可以看到，有 65 名程序员经过 1710 次提交，完成了 3.2 版本到 4.0 版本的升级工作。</p>
        <p class="图"><img src="Image00039.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.9　3-0-stable 与 4-0-stable 的差别</strong>
        </p>
        <h4 id="sigil_toc_id_96">
          <strong>……查看与几天前的差别</strong>
        </h4>
        <p>假如我们想查看 master 分支在最近 7 天内的差别，可以像下面这样这样将时间加入 URL。</p>
        <pre class="代码无行号">
<code>https://github.com/rails/rails/compare/master@{7.day.ago}...master

</code>
</pre>
        <p>这样，就可以查看这段期间内的差别。</p>
        <ul>
          <li>
            <p>day</p>
          </li>
          <li>
            <p>week</p>
          </li>
          <li>
            <p>month</p>
          </li>
          <li>
            <p>year</p>
          </li>
        </ul>
        <p>指定期间可以使用以上四个时间单位。如果差别过大则不会列出所有提交，只显示最近的一部分。</p>
        <h4 id="sigil_toc_id_97">
          <strong>……查看与指定日期之间的差别</strong>
        </h4>
        <p>假设我们想查看 master 分支 2013 年 1 月 1 日与现在的区别，可以将日期加入 URL。</p>
        <pre class="代码无行号">
<code>https://github.com/rails/rails/compare/master@{2013-01-01}...master

</code>
</pre>
        <p>这样，便可以查看与指定日期之间的差别。但是如果指定日期与现在的差别过大，或者指定日期过于久远，则无法显示。</p>
        <p>由于可以从多种角度查看差别，所以 GitHub 也称得上是一个优秀的源代码查看器。各位不妨记住直接修改 URL 来查看差别的方法，当遇到上述情况时，它能帮您节省不少时间。</p>
        <h2 id="nav_point_95">
          <strong>5.6　Issue</strong>
        </h2>
        <p>在软件开发过程中，开发者们为了跟踪 BUG 及进行软件相关讨论，进而方便管理，创建了 Issue。管理 Issue 的系统称为 BTS（Bug Tracking System，BUG 跟踪系统）。当今具有代表性的
          BTS 有 Redmine<span class="注释编号">4</span>
          、Trac<span class="注释编号">5</span>
          、Bugzilla<span class="注释编号">6</span>
          等。</p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          <a href="http://www.redmine.org/">http://www.redmine.org/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">5</span>
          <a href="http://trac.edgewall.org/">http://trac.edgewall.org/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">6</span>
          <a href="http://www.bugzilla.org/">http://www.bugzilla.org/</a>
        </p>
        <p>GitHub 也为自身加入了 BTS 的功能。在 GitHub 上，可以将它作为软件开发者之间的交流工具，多多加以利用。遇到下面几种情况时，各位就可以使用这个功能。</p>
        <ul>
          <li>
            <p>发现软件的 BUG 并报告</p>
          </li>
          <li>
            <p>有事想向作者询问、探讨</p>
          </li>
          <li>
            <p>事先列出今后准备实施的任务</p>
          </li>
        </ul>
        <p>Issue 除 BUG 管理之外还有许多其他用途。在软件开发者的圈子中，将 Issue 用于多种用途的情况已经司空见惯。作为 GitHub 的功能之一，想必今后会有更多人自然而然地用到它。所以借此机会，让我们来共同学习
          Issue 的一些简单用法。</p>
        <h3 id="nav_point_96">
          <strong>简洁且表现力丰富的描述方法</strong>
        </h3>
        <p>GitHub 的 Issue 及评论可以使用 GFM<span class="注释编号">7</span>
          语法进行描述，从而获得丰富的表现力。比如像图 5.10 中那样描述，然后点击 Preview，就可以看到图 5.11 中那种标记后的效果。</p>
        <p class="注释内容">
          <span class="注释编号下">7</span>
          <a
            href="https://help.github.com/articles/github-flavored-markdown">https://help.github.com/articles/github-flavored-markdown</a>
        </p>
        <p class="图"><img src="Image00040.jpg" alt="" width="75%" style="width: 75%" />
        </p>
        <p class="p-img-title">
          <strong>图 5.10　Markdown 语法示例</strong>
        </p>
        <p class="图"><img src="Image00041.jpg" alt="" width="70%" style="width: 70%" />
        </p>
        <p class="p-img-title">
          <strong>图 5.11　Markdown 语法效果预览</strong>
        </p>
        <p>在文本框旁边可以找到 GFM 语法相关帮助的链接（图 5.12）。</p>
        <p class="图"><img src="Image00042.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.12　Markdown 语法备忘表的链接</strong>
        </p>
        <h4 id="sigil_toc_id_98">
          <strong>……语法高亮</strong>
        </h4>
        <p>假设我们像下面这样，先指定语言再描述代码。</p>
        <pre class="代码无行号">
<code>````ruby
def hello_world
  puts 'Hello World!'
end
````

</code>
</pre>
        <p>这样一来，代码就会如图 5.13 所示被添加语法高亮 <span class="注释编号">8</span>
          ，变得直观易读。</p>
        <p class="注释内容">
          <span class="注释编号下">8</span>
          将代码的关键字变色或改变字体，从而提高可读性。
        </p>
        <p class="图"><img src="Image00043.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.13　添加语法高亮后的代码</strong>
        </p>
        <h4 id="sigil_toc_id_99">
          <strong>……添加图片</strong>
        </h4>
        <p>添加图片也十分简单。只需将图片拖曳到文本框中便可以粘贴图片。选择图 5.14 中的链接会弹出对话框，在这里也可以完成同样的操作。GitHub 的网站上也有相关内容的详细讲解，各位不妨参考一下 <span
            class="注释编号">9</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">9</span>
          <a
            href="https://help.github.com/articles/issue-attachments">https://help.github.com/articles/issue-attachments</a>
        </p>
        <p class="图"><img src="Image00044.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.14　添加图片的链接</strong>
        </p>
        <h3 id="nav_point_97">
          <strong>添加标签以便整理</strong>
        </h3>
        <p>Issue 可以通过添加标签（Label）来进行整理。添加标签后，Issue 的左侧就会显示标签（图 5.15）。点击页面左侧的标签，还可以只显示该类标签的 Issue。</p>
        <p class="图"><img src="Image00045.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.15　添加了标签的 Issue</strong>
        </p>
        <p>标签可以自由创建。既可以像图 5.15 那样按语言和技术分类，也可以按照 BUG、任务、备忘等作业类型分类。各位可以按照需要选择便于整理的标签。</p>
        <p>提个小建议：其实在 Issue 比较少的情况下不必每个都添加标签，大可等 Issue 积攒到一定数量，只有进行筛选才能清晰把握时再添加标签。</p>
        <h3 id="nav_point_98">
          <strong>添加里程碑以便管理</strong>
        </h3>
        <p>除标签外，还可以通过添加里程碑来管理 Issue。通过图 5.16 可以看出，项目距离下一个版本（3.0.0 版）还有 6 个 Issue 需要实施，整体的 96% 已经实施完毕并
          Close。从这里的链接我们可以查看剩余的 Issue。</p>
        <p class="图"><img src="Image00046.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.16　version 3.0.0 的里程碑</strong>
        </p>
        <p>设置里程碑，就可以用 Issue 来管理任务。</p>
        <blockquote>
          <p>
            <strong>专栏：了解贡献时的规则！</strong>
          </p>
          <p>在描述 Issue 时，常常会看到图 a中这种贡献规范的链接。在该仓库的根目录下添加 CONTRIBUTING.md 文件后该链接就会显示出来<span class="注释编号">10</span>
            。</p>
          <p>规范的内容一般包括报告时 Issue 的描述方法、Pull Request 时的规则或要求、许可证的相关信息等。为了在开源项目开发中能与其他人和谐相处，请务必在贡献之前仔细阅读这些规范。</p>
          <p class="图"><img src="Image00047.jpg" alt="{%}" />
          </p>
          <p class="p-img-title">
            <strong>图 a　规范的链接</strong>
          </p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">10</span>
          <a
            href="https://github.com/blog/1184-contributing-guidelines">https://github.com/blog/1184-contributing-guidelines</a>
        </p>
        <h3 id="nav_point_99">
          <strong>Tasklist 语法</strong>
        </h3>
        <p>我们可以使用 GFM 的一项独有功能，那就是 Tasklist 语法 <span class="注释编号">11</span>
          。首先试着按下面的格式进行描述。</p>
        <p class="注释内容">
          <span class="注释编号下">11</span>
          <a
            href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments">https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments</a>
        </p>
        <pre class="代码无行号">
<code># 本月要做的任务
- [ ] 完成图片
- [x] 完成部署工具的设置
- [ ] 实现抽签功能

</code>
</pre>
        <p>这样一来，这段文字就会被标记成复选列表的样式（图 5.17）。这个复选列表可以直接勾选或者取消，不必打开 Issue 的编辑页面重新编辑，十分方便，建议各位记住这个功能。</p>
        <p class="图"><img src="Image00048.jpg" alt="" width="400" style="width: 400px" />
        </p>
        <p class="p-img-title">
          <strong>图 5.17　Tasklist 语法</strong>
        </p>
        <h3 id="nav_point_100">
          <strong>通过提交信息操作 Issue</strong>
        </h3>
        <p>在 GitHub 上，只要按照特定的格式描述提交信息，就可以像一般 BTS 带有的功能那样对 Issue 进行操作。</p>
        <h4 id="sigil_toc_id_100">
          <strong>……在相关 Issue 中显示提交</strong>
        </h4>
        <p>在 Issue 一览表中我们可以看到，每一个 Issue 标题的下面都分配了诸如“#24”的编号。只要在提交信息的描述中加入“#24”，就可以如图 5.18 所示，在 Issue
          中显示该提交的相关信息，使关联的提交一目了然。这里只需轻轻点击一下便可以显示相应提交的具体内容，在代码审查时省去了从大量提交日志中搜索相应提交的麻烦，非常方便。</p>
        <p class="图"><img src="Image00049.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.18　提交信息</strong>
        </p>
        <h4 id="sigil_toc_id_101">
          <strong>……Close Issue</strong>
        </h4>
        <p>如果一个处于 Open 状态的 Issue 已经处理完毕，只要在该提交中以下列任意一种格式描述提交信息，对应的 Issue 就会被 Close。</p>
        <ul>
          <li>
            <p>fix #24</p>
          </li>
          <li>
            <p>fixes #24</p>
          </li>
          <li>
            <p>fixed #24</p>
          </li>
          <li>
            <p>close #24</p>
          </li>
          <li>
            <p>closes #24</p>
          </li>
          <li>
            <p>closed #24</p>
          </li>
          <li>
            <p>resolve #24</p>
          </li>
          <li>
            <p>resolves #24</p>
          </li>
          <li>
            <p>resolved #24</p>
          </li>
        </ul>
        <p>利用这个方法，每次提交并 push 之后，就不必再大费周章地到 GitHub 的 Issue 中寻找相应 Issue 再手动 Close，省去不少麻烦。</p>
        <p>像这样，只要按照特定的格式描述提交信息，GitHub 就会自动识别并处理，让使用 GitHub 变得更加轻松。目前，很多 GitHub 之外的 BTS 也实现了这一功能，记住它绝对是有利无弊的。</p>
        <h3 id="nav_point_101">
          <strong>将特定的 Issue 转换为 Pull Request</strong>
        </h3>
        <p>在 GitHub 上，如果给 Issue 添加源代码，它就会变成我们马上要讲到的 Pull Request。Issue 与 Pull Request 的编号相互通用，通过 GitHub 的 API 可以将特定的
          Issue 转换为 Pull Request，能够完成这一操作的 hub 命令将在本书的 8.1 节中讲解。在这里，各位只要先记住 Issue 与 Pull Request 的编号通用即可。</p>
        <h2 id="nav_point_102">
          <strong>5.7　Pull Request</strong>
        </h2>
        <p>Pull Request 是用户修改代码后向对方仓库发送采纳请求的功能，也是 GitHub 的核心功能（图 5.19）。正因为有了这个功能，才会让众多开发者轻松地加入到开源开发的队伍中来。</p>
        <p class="图"><img src="Image00050.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.19　Pull Request 一览</strong>
        </p>
        <p>在 Pull Request 页面能够列表查看当前处于 Open 状态的 Pull Request。通过点击页面左部和上部的选项可以进行筛选和重新排列。</p>
        <p>在列表中点击特定的 Pull Request 就会进入详细页面（图 5.20）。页面上方显示着这次是从谁的哪个分支向谁的哪个分支发送了 Pull Request。下面，我们对各个标签（Tag）页进行讲解。</p>
        <p class="图"><img src="Image00051.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.20　Pull Request 的详细页面</strong>
        </p>
        <blockquote>
          <p>
            <strong>专栏：获取 diff 格式与 patch 格式的文件</strong>
          </p>
          <p>对长期投身于软件开发的人来说，有时可能会希望以 diff 格式文件和 patch 格式文件的形式来处理 Pull Request。</p>
          <p>举个例子，假设 Pull Request 的 URL 如下所示。</p>
          <pre class="代码无行号">
<code>https://github.com/用户名/仓库名/pull/28

</code>
</pre>
          <p>如果想获取 diff 格式的文件，只要像下面这样在 URL 末尾添加 .diff 即可。</p>
          <pre class="代码无行号">
<code>https://github.com/用户名/仓库名/pull/28.diff

</code>
</pre>
          <p>同理，想要 patch 格式的文件，只需要在 URL 末尾添加 .patch 即可。</p>
          <pre class="代码无行号">
<code>https://github.com/用户名/仓库名/pull/28.patch

</code>
</pre>
          <p>想要 diff 格式与 patch 格式文件的各位请按照上述方法进行操作。</p>
        </blockquote>
        <h3 id="nav_point_103">
          <strong>Conversation</strong>
        </h3>
        <p>在 Conversation 标签页中，可以查看与当前 Pull Request
          相关的所有评论以及提交的历史记录。人们在这里添加评论互相探讨，发送提交落实讨论内容的整个过程会按时间顺序列出，供用户查看。各位在查看过程中如果有自己的想法，不妨积极地添加评论参与探讨。</p>
        <p>提交日志的右侧有该提交的哈希值，点击链接即可确认相应提交的详细信息。</p>
        <blockquote>
          <p>
            <strong>专栏：引用评论</strong>
          </p>
          <p>在 Conversation 中人们通过添加评论进行对话。这里有一个简单方法可以帮您引用某个人的评论。选中想引用的评论然后按 R 键，被选择的部分就会自动以评论语法写入评论文本框（图 a）。</p>
          <p>这样一来就可以轻松便捷地引用评论了。该快捷键在 Issue 中同样有效。</p>
          <p class="图"><img src="Image00052.jpg" alt="{%}" />
          </p>
          <p class="p-img-title">
            <strong>图 a　按 R 键引用选中的部分</strong>
          </p>
        </blockquote>
        <h3 id="nav_point_104">
          <strong>Commits</strong>
        </h3>
        <p>在 Commits 标签页中，按时间顺序列表显示了与当前 Pull Request 相关的提交（图 5.21）。标签上的数字为提交的次数。每个提交右侧的哈希值可以连接到该提交的代码。</p>
        <p class="图"><img src="Image00053.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.21　Pull Request 的提交一览</strong>
        </p>
        <blockquote>
          <p>
            <strong>专栏：在评论中应用表情</strong>
          </p>
          <p>GitHub 的文化中有使用表情的习惯。表情种类繁多，要一次全记下来十分困难。这时我们可以利用表情的自动补全功能<span class="注释编号">12</span>
            。</p>
          <p>在评论中输入“:”（冒号）便会启动表情自动补全功能。只要输入几个与该表情相关的字母，系统就会为您筛选自动补全的对象（图 a）。选择想要的表情，其相应代码（前后都有冒号的字符串）便会插入到文本框中。</p>
          <p>准确表达感情可以让交流变得和谐，各位请记得多加利用。</p>
          <p class="图"><img src="Image00054.jpg" alt="图像说明文字" />
          </p>
          <p class="p-img-title">
            <strong>图 a　自动补全以“ra”开头的表情</strong>
          </p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">12</span>
          请登录 <a href="http://www.emoji-cheat-sheet.com/">http://www.emoji-cheat-sheet.com/</a>
          查找可使用的表情。
        </p>
        <h3 id="nav_point_105">
          <strong>Files Changed</strong>
        </h3>
        <p>Files Changed 标签页中可以查看当前 Pull Request 更改的文件内容以及前后差别。标签上的数字表示新建及被更改的文件数。</p>
        <p>默认情况下系统会将空格的不同也高亮显示，所以在空格有改动的情况下会难以阅读。这时只要在 URL 的末尾添加“?w=1”就可以不显示空格的差别。</p>
        <p>将鼠标指针放到被更改行行号的左侧，我们会看到一个加号。点击这个加号可以在代码中插入评论（图 5.22）。这样，评论是针对哪行代码的就一目了然了。</p>
        <p class="图"><img src="Image00055.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.22　对所选内容行进行评论</strong>
        </p>
        <p>这个插入评论的功能让针对代码的讨论变得十分顺畅。特别是在多人协作的软件开发中，这个功能更加不可或缺。</p>
        <h2 id="nav_point_106">
          <strong>5.8　Wiki</strong>
        </h2>
        <p>Wiki 是一个使用简单的语法就能编写文档的功能（图
          5.23）。所有有权限的人都可以对文章进行修改，所以比较适合多人共同编写文章的情况。创建、编辑文档时不必另外启动软件，用起来十分方便，非常适合用来针对更新频率较高的软件进行文档等信息方面的汇总。</p>
        <p class="图"><img src="Image00056.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.23　Wiki 的应用实例</strong>
        </p>
        <p>与 Issue 和 Pull Request 相同，Wiki 也支持 GFM 语法，所以可以轻松创建表现力丰富的文档。点击页面右上角的 New Page 按钮便可以创建新的 Wiki 页。</p>
        <p>Wiki 功能本身的数据也在 Git 中进行管理。点击 Clone URL 按钮可以将当前 Wiki 的 Git 仓库 URL 复制到剪贴板中。用户能够通过 clone 操作获取 Wiki
          仓库，然后在本地创建、编辑页面，进行提交再 push，便可以完成对 Wiki 的创建及编辑工作。</p>
        <h3 id="nav_point_107">
          <strong>Pages</strong>
        </h3>
        <p>在 Pages 标签页中可以列表查看 Wiki 页面（图 5.24）。</p>
        <p class="图"><img src="Image00057.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.24　Wiki 页面一览</strong>
        </p>
        <h3 id="nav_point_108">
          <strong>History</strong>
        </h3>
        <p>在 History 标签页中可以查看 Wiki 的修改历史记录（图 5.25）。</p>
        <p class="图"><img src="Image00058.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.25　Wiki 历史记录一览</strong>
        </p>
        <p>由于 Wiki 功能也有历史记录可查，所以软件开发者可以放心地投入到工作中去。将 Wiki 仓库 clone 到本地，就可以不借助浏览器，直接用自己熟悉的编辑器进行编辑，十分人性化。</p>
        <p>一般情况下，Wiki 中记载着软件相关的 FAQ、文档、代码示例及解说等信息。各位在使用 GitHub 上开发的软件前，建议先查看一遍 Wiki。</p>
        <blockquote>
          <p>
            <strong>专栏：在 Wiki 中显示侧边栏</strong>
          </p>
          <p>所有 Wiki 页面都可以显示侧边栏。做法很简单，只要创建名为“_sidebar”的页面即可。_sidebar 页不会显示在 Pages 的页面一览中。在编辑各页面时页面下部会附加 Sidebar 段（图
            a），用户可以在这里编辑侧边栏的内容。</p>
          <p class="图"><img src="Image00059.jpg" alt="{%}" />
          </p>
          <p class="p-img-title">
            <strong>图 a　编辑侧边栏的内容</strong>
          </p>
        </blockquote>
        <h2 id="nav_point_109">
          <strong>5.9　Pulse</strong>
        </h2>
        <p>Pulse 是体现该仓库软件开发活跃度的功能（图 5.26）。近期该仓库创建了多少 Pull Request 或 Issue，有多少人参与了这个仓库的开发等，都可以在这里一目了然。</p>
        <p class="图"><img src="Image00060.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.26　Pulse 的页面</strong>
        </p>
        <p>根据这个页面，用户可以判断目前这个软件是否正在被积极开发，或者持有仓库修改权限的人是否在认真地进行 BUG 修正等维护工作。在挑选 GitHub 上开发的软件时，它可以作为一个重要的衡量标准。</p>
        <p>下面，我们就来详细讲解一下这个功能。</p>
        <h3 id="nav_point_110">
          <strong>active pull requests</strong>
        </h3>
        <p>页面中 Overview 的左半部分显示了特定期间内活动过的 Pull Request 数。图 5.26 中有 25 个 Pull Request，其中有 20 个被采纳，其余 5 个仍然保持 Open 状态。剩余的这
          5 个 Pull Request 将来要么会被采纳，要么会被 Close。</p>
        <p>如果想查看清单的详细内容，只要点击对应项即可（图 5.27）。Pull Request 的概要及链接按照合并的先后顺序排列。</p>
        <p class="图"><img src="Image00061.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.27　已合并的 Pull Request 的概要及链接</strong>
        </p>
        <p>点击 proposed-pull-request 则可以按 创建的先后顺序查 看 Pull Request 的概要及链接。</p>
        <p>通过这些信息，用户可以了解该软件最近正在开发哪些功能。如果发现对方正在进行功能扩展或者修正，不妨积极试用一下这个功能。这或许会成为您加入开源软件开发的契机。</p>
        <h3 id="nav_point_111">
          <strong>active issue</strong>
        </h3>
        <p>页面中 Overview 的右半部分显示了特定期间内活动过的 Issue 数。图 5.26 中有 110 个 Issue，其中有 96 个被 Close，其余 14 个仍处于 Open 状态。</p>
        <p>如果想查看清单的详细内容，只要点击对应项即可。Issue 的概要及链接按照 Close 的先后顺序排列。</p>
        <p>点击 new issue 则可以按创建的先后顺序查看 Issue 的概要及链接。</p>
        <p>通过观察 Issue 的整体动向，用户能够知道这个软件是否有人在积极地维护与支持。对方仓库越是活跃，用户发送的 BUG 报告和相关探讨越可能收到回应。</p>
        <h3 id="nav_point_112">
          <strong>commits</strong>
        </h3>
        <p>Overview 下方显示的是与提交相关的信息。左侧部分包含了如下几类信息。</p>
        <ul>
          <li>
            <p>编写过代码的人数</p>
          </li>
          <li>
            <p>提交的次数</p>
          </li>
          <li>
            <p>default branch 中修改过的文件数</p>
          </li>
          <li>
            <p>default branch 中添加的行数</p>
          </li>
          <li>
            <p>default branch 中删除的行数</p>
          </li>
        </ul>
        <p>通过这些信息，用户可以大致把握该仓库中活跃开发者的人数。</p>
        <p>另外，右侧图表显示了这些开发者具体发送的提交数。通过图表我们可以了解到有哪些开发者在格外积极地向该仓库发送提交。</p>
        <h3 id="nav_point_113">
          <strong>Releases published</strong>
        </h3>
        <p>提交相关信息的下方显示了“5 Releases published”之类的字样，这是版本发布的相关信息。已发布的各版本的下载链接按照发布时间的先后顺序一一列出。</p>
        <p>通过这里我们可以了解到该软件的版本升级频率。</p>
        <h3 id="nav_point_114">
          <strong>Unresolved Conversations</strong>
        </h3>
        <p>最后我们来讲解显示为“4 Unresolved Conversations”的这个部分。</p>
        <p>这里列出的 Issue 和 Pull Request 都创建于 Period 指定的时间之前，它们都尚未 Close
          并且仍有人参与评论。一般情况下，仓库中软件的重大事项讨论都会持续很长时间，所以这些讨论大多放在这里。其中会有不少关于该软件今后发展方向的讨论。如果各位有哪些比较关心的软件，不妨关注一下这部分的讨论内容。</p>
        <h2 id="nav_point_115">
          <strong>5.10　Graphs</strong>
        </h2>
        <p>在 Graphs 页中，可以通过 4 种图表查看该仓库的相关统计信息（图 5.28）。利用图表直观地汇总信息，可以让用户把握当前仓库的各种趋势。下面，让我们来了解一下每个图表所包含的信息。</p>
        <p class="图"><img src="Image00062.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.28　Graphs</strong>
        </p>
        <h3 id="nav_point_116">
          <strong>Contributors</strong>
        </h3>
        <p>在 Contributors 的图表中，我们可以看到每个用户在相应日期中发送提交、添加代码、删除代码的大致数量（图
          5.29）。从这里我们能够了解到该仓库的代码主要由哪些人编写。而且，还可以通过图表分析出该软件大幅修改阶段和稳定维护阶段的相应时期。</p>
        <p class="图"><img src="Image00063.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.29　Contributors</strong>
        </p>
        <p>另外，这些图表的统计中还包括发送 Pull Request 被采纳后产生的代码增减。</p>
        <h3 id="nav_point_117">
          <strong>Commit Activity</strong>
        </h3>
        <p>Commit Activity 中显示了一年内（52 周）每周收到的提交的大致数 量（图 5.30）。第二张表中还可以查看相应周每天的提交数量。判断某个仓库是否有人在积极更新时，这部分是一个重要的指标。</p>
        <p class="图"><img src="Image00064.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.30　Commit Activity</strong>
        </p>
        <ul>
          <li class="第1级无序列表">
            <strong>Code Frequency</strong>
          </li>
        </ul>
        <p>Code Frequency 中显示了该仓库中代码行数的增加量和删除量（图 5.31）。一款优秀的软件并不会一味地增加代码，在经过重构之后，代码量往往会降低。通过这张图，我们可以直观地把握相应信息。</p>
        <p class="图"><img src="Image00065.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.31　Code Frequency</strong>
        </p>
        <h3 id="nav_point_118">
          <strong>Punchcard</strong>
        </h3>
        <p>从 Punchcard 的图中我们可以直观地掌握一周内每天何时收到的提交最多（图 5.32）。黑色圆越大，表示提交越频繁。</p>
        <p class="图"><img src="Image00066.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.32　punchcard</strong>
        </p>
        <p>仓库的关键人物往往会出现在提交频率高的时间段，因此用户发送的 Pull Request 最有可能在这段时间内被处理。大致了解时间规律，将有助于各位把握好发送 Pull Request
          以及等待回复的时间点。另外，该软件的开发是集中在早上还是晚上，从这张图中也可一目了然。</p>
        <h2 id="nav_point_119">
          <strong>5.11　Network</strong>
        </h2>
        <p>以图表形式显示包括克隆仓库在内的所有分支的提交（图 5.33）。从图上可以直观地看出每个人做了多少工作。</p>
        <p class="图"><img src="Image00067.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.33　所有分支的图表</strong>
        </p>
        <p>将鼠标指针停留在表中提交或合并的点上，可以查看相应的参考内容。</p>
        <h2 id="nav_point_120">
          <strong>5.12　Settings</strong>
        </h2>
        <p>在这里可以对仓库进行任何设置。用户必须拥有更改设置的权限，才能看到这个页面。</p>
        <h3 id="nav_point_121">
          <strong>Options</strong>
        </h3>
        <p>在 Options 中可以变更仓库本身的相关设置（图 5.34）。</p>
        <p class="图"><img src="Image00068.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.34　Settings 的 Options 页面</strong>
        </p>
        <h4 id="sigil_toc_id_102">
          <strong>……1 Settings</strong>
        </h4>
        <p>在这里可以修改仓库名称，设置显示仓库 URL 时默认显示的分支。这个默认分支同时也是创建 Pull Request 时的默认值，如果各位的主分支不是 master 分支，建议更改这一设置。</p>
        <h4 id="sigil_toc_id_103">
          <strong>……2 Features</strong>
        </h4>
        <p>这里可以更改 Wiki 和 Issue 的相关设置。如果想关闭某些功能，只要取消已勾选的相应复选框，该功能就会从菜单中移除，无法使用。</p>
        <h4 id="sigil_toc_id_104">
          <strong>……3 GitHub Pages</strong>
        </h4>
        <p>GitHub 有一个名为 GitHub Pages 的仓库，用户可以利用该仓库中的资料创建 Web 页，用来发布仓库中软件的相关信息。如果已经创建过 GitHub Pages，则会显示相应 URL。点击
          Automatic Page Generator 即可以自动创建 GitHub Pages。</p>
        <h4 id="sigil_toc_id_105">
          <strong>……4 Danger Zone</strong>
        </h4>
        <p>这里都是一些需要格外留意的设置。在这里，用户可以将仓库改为私有或是变更仓库所有者，甚至删除仓库本身。这些设置有可能影响到其他人，在变更时一定要谨慎。</p>
        <h3 id="nav_point_122">
          <strong>Collaborators</strong>
        </h3>
        <p>用户主要在这里设置仓库的访问权限。如果仓库隶属于个人账户，那么可以像图 5.35 所示那样添加 GitHub 的用户名，赋予该用户直接读写仓库的权限。</p>
        <p class="图"><img src="Image00069.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.35　个人账户的 Collaborators 页面</strong>
        </p>
        <p>不过，如果仓库隶属于 Organization 账户，则需要像图 5.36 所示的那样先创建 Team，然后赋予该 Team 读写仓库的权限。</p>
        <p class="图"><img src="Image00070.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.36　Organization 账户的 Collaborators 页面</strong>
        </p>
        <p>像这样使用 Organization 账户可以高效地设置仓库权限，在公司等多人共同进行开发的组织中，建议使用 Organization 账户。</p>
        <h3 id="nav_point_123">
          <strong>Webhooks and Services</strong>
        </h3>
        <p>在这个页面中，用户可以添加 Hook 让 GitHub 仓库与其他服务集成。通过 Add webhook 可以添加用户自己的 webhook。通过 Configure services 则可以从 GitHub
          事先列出的可以集成的服务中进行选择。能与 GitHub 集成的服务非常多，其中还包括邮件及 IRC 等社交服务，建议各位不要错过这个设置。在如此大量的服务当中，相信各位能找到自己正在使用的工具。</p>
        <h3 id="nav_point_124">
          <strong>Deploy Keys</strong>
        </h3>
        <p>在这个页面中，用户可以添加用于部署的公开密钥，允许以只读方式访问仓库。设置公开密钥后，用户可以使用私有密钥通过 ssh 协议 clone 仓库。要注意的是，这里添加的公开密钥·私有密钥对无法再添加到其他仓库。使用
          Deploy Keys 功能时，需要给每个仓库赋予不同的密钥对。</p>
        <h2 id="nav_point_125">
          <strong>5.13　Notifications</strong>
        </h2>
        <p>页面左上角 LOGO 旁边的蓝色亮点就是 Notifications。点击它，我们可以看到 GitHub 所有活动的通知（图 5.37）。灵活运用这个 Notifications，可以大幅提高合作开发的效率。</p>
        <p class="图"><img src="Image00071.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 5.37　Notifications 的页面</strong>
        </p>
        <p>每当创建 Issue、收到评论、创建 Pull Request 等情况发生时，我们就会在 Notifications 中收到通知。</p>
        <p>页面左侧是 Notifications 的筛选器，可以分别查看未读的、与自己相关的通知，或者按仓库分类查看通知等。</p>
        <p>点击仓库名右侧的对勾，可以将该仓库的所有 Notifications 设置为已读状态。</p>
        <p>点击各条通知右侧的扩音器图标，那么即使今后这个通知的相关内容再收到追加评论时，也不会再通知用户。点击通知右侧的对勾，可以将相应的 Notifications 设置为已读状态。当然，点击 Notifications
          阅读详细内容后，该通知也会自动转换为已读状态。</p>
        <p>如果 LOGO 旁的蓝色亮点是发光状态，则表示有未读的 Notifications，请养成及时查看的习惯。越早处理通知，开发者之间的协同工作就越有效率。</p>
        <h2 id="nav_point_126">
          <strong>5.14　其他功能</strong>
        </h2>
        <p>GitHub 还提供了其他许多功能。我们在这里只介绍其中的一部分。</p>
        <h3 id="nav_point_127">
          <strong>GitHub Pages</strong>
        </h3>
        <p>GitHub Pages 主要用于在 GitHub 上托管静态 HTML，以便发布项目的 Web 页 <span class="注释编号">13</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">13</span>
          <a href="https://pages.github.com/">https://pages.github.com/</a>
        </p>
        <p>由于可以绑定独立域 名，人们也经常利用结合了这个功能的 Octopress<span class="注释编号">14</span>
          框架来搭建博客。有兴趣的读者不妨试一试。</p>
        <p class="注释内容">
          <span class="注释编号下">14</span>
          <a href="http://octopress.org/">http://octopress.org/</a>
        </p>
        <h3 id="nav_point_128">
          <strong>GitHub Jobs</strong>
        </h3>
        <p>GitHub Jobs 是面向全世界招聘程序员的职位公告板 <span class="注释编号">15</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">15</span>
          <a href="https://jobs.github.com/">https://jobs.github.com/</a>
        </p>
        <p>450 美元可以发布 30 天招聘公告，希望在世界范围内招聘优秀程序员的公司不妨尝试一下这个功能。</p>
        <p>想到海外就职的程序员也可以多看一看这里。</p>
        <h3 id="nav_point_129">
          <strong>GitHub Enterprise</strong>
        </h3>
        <p>GitHub Enterprise 专为那些无法将源代码放到公司之外的企业设计。这项服务可以以虚拟机的形式提供 GitHub。申请后可以先试用 45 天，所以企业内部在探讨是否导入时可以实际使用一下再决定。</p>
        <p>导入的最大阻碍其实是成本。这项服务主要面向 20 人以上的组织，如果规模不足，建议还是使用普通的 GitHub。详细内容请参照 GitHub Enterprise 的页面 <span
            class="注释编号">16</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">16</span>
          <a href="https://enterprise.github.com/pricing">https://enterprise.github.com/pricing</a>
        </p>
        <p>考虑到实体机的运行成本及维护成本，除非是规模相当大的企业，否则还是不建议使用 GitHub Enterprise。</p>
        <h3 id="nav_point_130">
          <strong>GitHub API</strong>
        </h3>
        <p>GitHub 面向开发者公开了 API。特别是在开发面向程序员的 Web 服务时，能与 GitHub 集成绝对有利无弊。详细内容请参照官方网站 <span class="注释编号">17</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">17</span>
          <a href="https://developer.github.com/">https://developer.github.com/</a>
        </p>
        <h2 id="nav_point_131">
          <strong>5.15　小结</strong>
        </h2>
        <p>本章中，我们结合 GitHub 的实际操作页面给各位讲解了 GitHub 上提供的各项功能。其中某些功能的细节可能经常使用 GitHub 的人也并不完全清楚。</p>
        <p>在 GitHub 上与其他人共同进行软件开发时，如果发现同组搭档对功能不够熟悉，不妨按照本书中的介绍为其讲解一番。</p>
        <blockquote>
          <p>
            <strong>专栏：在 Mac 的通知中心查看 GitHub 的 Notifications</strong>
          </p>
          <p>OS X 从 10.8 Mountain Lion 版本开始添加了通知中心的功能，该功能用于简单汇总并显示应用程序的警告。</p>
          <p>GitHub 为 Mac 准备了专用的客户端软件<span class="注释编号">18</span>
            。利用这个软件，用户就可以通过 GUI 完成仓库的简单操作。不仅如此，只要这个软件在运行，GitHub 的 Notifications 收到的内容就会同时显示在通知中心中（图 a）。</p>
          <p class="图"><img src="Image00072.jpg" alt="" width="80%" style="width: 80%" />
          </p>
          <p class="p-img-title">
            <strong>图 a　通知中心接收 GitHub 的通知</strong>
          </p>
          <p>GitHub 的客户端部署版本 GitHub Enterprise 也支持这一功能。只要在同一客户端的设置页面（图 b）进行设置，通知中心就能够同时接收 GitHub.com 和 GitHub Enterprise
            双方的通知。</p>
          <p class="图"><img src="Image00073.jpg" alt="" width="80%" style="width: 80%" />
          </p>
          <p class="p-img-title">
            <strong>图 b　GitHub Enterprise 的设置</strong>
          </p>
          <p>日常使用 GitHub 的各位请务必一试。</p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">18</span>
          <a href="https://mac.github.com/">https://mac.github.com/</a>
        </p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_132">
          <strong>第 6 章　尝试Pull Request</strong>
        </h1>
        <p>按部就班地创建 GitHub 账号并公开自己的源代码并不是什么难事。不过，刚刚接触 GitHub 的人往往不会或不敢使用 Pull Request 功能。</p>
        <p>Pull Request 是社会化编程的象征。GitHub 创造的这一功能，可以说给开源开发世界带来了一场革命。不会用这个功能，就等于不会用 GitHub。</p>
        <p>不过，掌握 Pull Request 的难度确实较高，刚刚接触 GitHub 的人在发送 Pull Request 时，往往会遇到找不到对方的项目或者不知道该如何发送等问题。</p>
        <p>所以，本书将为各位创造一个亲自动手发送 Pull Request 的机会，请各位不要错过。</p>
        <h2 id="nav_point_133">
          <strong>6.1　Pull Request 的概要</strong>
        </h2>
        <h3 id="nav_point_134">
          <strong>什么是 Pull Request</strong>
        </h3>
        <p>首先我们来理解什么是 Pull Request<span class="注释编号">1</span>
          。Pull Request 是自己修改源代码后，请求对方仓库采纳该修改时采取的一种行为。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          Pull Request 在网络上也常常被简称为 PR。
        </p>
        <h3 id="nav_point_135">
          <strong>Pull Request 的流程</strong>
        </h3>
        <p>下面来看看具体的例子。现在假设我们在使用 GitHub 上的一款开源软件。</p>
        <p>在使用这款软件的过程中，我们偶然间发现了 BUG。为了继续使用软件，我们手动修复了这个 BUG。如果我们修改的这段代码能被该软件的开发仓库采纳，今后与我们同样使用这款软件的人就不会再遇到这个
          BUG。为此，我们要第一时间发送 Pull Request。</p>
        <p>在 GitHub 上发送 Pull Request 后，接收方的仓库会创建一个附带源代码的 Issue，我们在这个 Issue 中记录详细内容。这就是 Pull Request。</p>
        <p>发送过去的 Pull Request 是否被采纳，要由接收方仓库的管理者进行判断。一般只要代码没有问题，对方都会采纳。如果有问题，我们会收到评论。</p>
        <p>只要 Pull Request 被顺利采纳，我们就会成为这个项目的 Contributor（贡献者），我们编写的这段代码也将被全世界的人使用。这正是社会化编程和开源开发的一大乐趣。</p>
        <p>我们为本书专门搭设了一个网站，各位可以对其进行修改，尝试发送 Pull Request。</p>
        <h2 id="nav_point_136">
          <strong>6.2　发送 Pull Request 前的准备</strong>
        </h2>
        <p>整体概念如图 6.1 所示。</p>
        <p class="图"><img src="Image00074.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 6.1　Pull Request 的概念图</strong>
        </p>
        <h3 id="nav_point_137">
          <strong>查看要修正的源代码</strong>
        </h3>
        <p>请登录我们为各位准备的网站 <span class="注释编号">2</span>
          。该网站的源代码已经在 GitHub 上公开 <span class="注释编号">3</span>
          。各位请将自己的感想写入源代码，然后发送 Pull Request。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a href="https://ituring.github.io/first-pr/">https://ituring.github.io/first-pr/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          <a href="https://github.com/ituring/first-pr">https://github.com/ituring/first-pr</a>
        </p>
        <p>这个网站通过 GitHub 的 GitHub Pages 功能发布。GitHub Pages 的网站的源代码位于仓库的 gh-pages 分支。访问仓库页面，我们就可以看到源代码。</p>
        <p>记述感想时需要修改 index.html 文件。各位不妨先查看它的源代码，对内容有个印象。</p>
        <h3 id="nav_point_138">
          <strong>Fork</strong>
        </h3>
        <p>各位请访问仓库页面，点击 Fork 按钮创建自己的仓库（图 6.2）。</p>
        <p class="图"><img src="Image00075.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 6.2　Fork 按钮</strong>
        </p>
        <p>新建的仓库名 为“自己的账户名 /first-pr”。在这里我们命名为 hirocastest。</p>
        <h3 id="nav_point_139">
          <strong>clone</strong>
        </h3>
        <p>clone 仓库所需的访问信息显示在右侧的中央部分，让我们将它复制下来，把这个仓库 clone 到当前的开发环境中。</p>
        <pre class="代码无行号">
<code>$ git clone git@github.com:hirocastest/first-pr.git
Cloning into 'first-pr'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (12/12), done.
remote: Total 14 (delta 2), reused 0 (delta 0)
Receiving objects: 100% (14/14), 24.05 KiB, done.
Resolving deltas: 100% (2/2), done.
$ cd first-pr

</code>
</pre>
        <p>first-pr 目录下会生成 Git 仓库。这个仓库与我们 GitHub 账户下的 first-pr 仓库状态相同。现在只要在这个仓库中修改源代码进行 push，GitHub 账户中的仓库就会被修改。</p>
        <h3 id="nav_point_140">
          <strong>branch</strong>
        </h3>
        <h4 id="sigil_toc_id_106">
          <strong>……为何要在特性分支中进行作业</strong>
        </h4>
        <p>当前 Git 的主流开发模式都会使用特性分支。关于特性分支的详细知识，我们已经在第 4 章讲解过了。</p>
        <p>各位请养成创建特性分支后再修改代码的好习惯。在 GitHub 上发送 Pull Request 时，一般都是发送特性分支。这样一来，Pull Request
          就拥有了更明确的特性（主题）。让对方了解自己修改代码的意图，有助于提高代码审查的效率。</p>
        <h4 id="sigil_toc_id_107">
          <strong>……确认分支</strong>
        </h4>
        <p>我们来查看一下 clone 出的仓库的分支。</p>
        <pre class="代码无行号">
<code>$ git branch -a
* gh-pages       ←当前分支
  remotes/origin/HEAD -&gt; origin/gh-pages
  remotes/origin/gh-pages

</code>
</pre>
        <p>开头加了“remotes/origin/”的是 GitHub 端仓库的分支。我们手头的开发环境中只有 gh-pages 分支。</p>
        <p>网站中显示的 HTML 位于 /origin/gh-pages 分支。虽然通常情况下最新版代码都位于 master 分支，但由于本次我们使用了 GitHub Pages，所以最新代码位于 gh-pages 分支。
        </p>
        <h4 id="sigil_toc_id_108">
          <strong>……创建特性分支</strong>
        </h4>
        <p>我们创建一个名为 work 的分支，用来发送 Pull Request。这个 work 分支就是这次的特性分支。现在创建 work 分支并自动切换。</p>
        <pre class="代码无行号">
<code>$ git checkout -b work gh-pages
Switched to a new branch 'work'

</code>
</pre>
        <p>确认是否切换到了 work 分支下。</p>
        <pre class="代码无行号">
<code>$ git branch -a
  gh-pages
* work  ←当前分支
  remotes/origin/HEAD -&gt; origin/gh-pages
  remotes/origin/gh-pages

</code>
</pre>
        <p>查看文件列表，我们可以看到网站中显示的 index.html 文件。</p>
        <pre class="代码无行号">
<code>$ ls
README.md       index.html      params.json
images          javascripts     stylesheets

</code>
</pre>
        <p>可以用浏览器打开并确认显示。</p>
        <h3 id="nav_point_141">
          <strong>添加代码</strong>
        </h3>
        <p>用编辑器打开 index.html 文件，以 HTML 形式添加感想。</p>
        <pre class="代码无行号">
<code>省略
&lt;p&gt;请写明这是对本书内容的实践或描述对本书的感想并发送Pull Request。&lt;/p&gt;
↓追加的行
&lt;p class="impression"&gt; 这本书读着很有趣。（@HIROCASTER）&lt;/p&gt;
省略

</code>
</pre>
        <p>请自由添加感想并用 p 标签（Tag）括起，然后关闭编辑器。</p>
        <h3 id="nav_point_142">
          <strong>提交修改</strong>
        </h3>
        <p>用 <code>git diff</code>
          命令查看修改是否已经正确进行。</p>
        <pre class="代码无行号">
<code>$ git diff
diff --git a/index.html b/index.html
index f2034b3..91b8ecb 100644
--- a/index.html
+++ b/index.html
@@ -39,6 +39,8 @@
    　
 &lt;p&gt;请写明这是对本书内容的实践或描述对本书的感想并发送Pull Request。&lt;/p&gt;
    　
 +&lt;p class="impression"&gt; 这本书读着很有趣。（@HIROCASTER）&lt;/p&gt;
 +
 省略

</code>
</pre>
        <p>然后用浏览器打开，查看显示是否正确。然后确认添加的代码，提交至本地仓库。</p>
        <pre class="代码无行号">
<code>$ git add index.html
$ git commit -m "Add my impression"
[work 243f28d] Add my impression
 1 file changed, 2 insertions(+)

</code>
</pre>
        <h3 id="nav_point_143">
          <strong>创建远程分支</strong>
        </h3>
        <p>要从 GitHub 发送 Pull Request，GitHub 端的仓库中必须有一个包含了修改后代码的分支。我们现在就来创建本地 work 分支的相应远程分支。</p>
        <pre class="代码无行号">
<code>$ git push origin work
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 353 bytes, done.
Total 3 (delta 2), reused 0 (delta 0)
To git@github.com:hirocastest/first-pr.git
 * [new branch]      work -&gt; work

</code>
</pre>
        <p>查看分支，/origin/work 已被创建。</p>
        <pre class="代码无行号">
<code>$ git branch -a
   master
   * work
   remotes/origin/HEAD -&gt; origin/master
   remotes/origin/gh-pages
   remotes/origin/work   ←已被创建

</code>
</pre>
        <p>请打开 GitHub 的“用户名 /first-pr”页，确认 work 分支是否被创建，以及是否已包含我们添加的代码。</p>
        <h2 id="nav_point_144">
          <strong>6.3　发送 Pull Request</strong>
        </h2>
        <p>参考图 6.3，登录 GitHub 并切换至 work 分支。点击分支名左侧的绿色按钮，会跳转至查看分支间差别的页面（图 6.4）。请在这里通过差别查看刚刚进行的更改是否正确。这里显示的东西就是我们本次 Pull
          Request 中包含的提交。</p>
        <p class="图"><img src="Image00076.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 6.3　切换分支</strong>
        </p>
        <p class="图"><img src="Image00077.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 6.4　查看分支间差别的页面</strong>
        </p>
        <p>确认想要发送的 Pull Request 的内容差别无误后，请点击 Create Pull Request。随后显示的表单用于填写请求对方采纳的评论（图 6.5）。现在让我们在评论栏中简明扼要地描述本次进行 Pull
          Request 的理由。</p>
        <p class="图"><img src="Image00078.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 6.5　填写请求对方采纳的评论</strong>
        </p>
        <p>确认没有问题后，点击 Send pull request 按钮。这样一来，Pull Request 的目标仓库中就会新建 Pull Request 和 Issue，同时该仓库的管理者会接到通知。</p>
        <hr />
        <p>至此，恭喜各位顺利发送了第一次的 Pull Request。现在我们发送的源代码还没有被采纳，对方仓库不会有任何变化，所以网页也仍然是原样。</p>
        <p>如果想查看已发送 Pull Request 的状态，可以登录 GitHub，打开自己的控制面板查看 Pull Request 标签页。点击自己发送的 Pull Request 后会进入如图 6.6 的页面，管理者对
          Pull Request 的评论会发到这里。这些在 Conversation 标签页中会按照时间顺序排列显示。只要代码没有问题，我们的 Pull Request 就会被采纳 <span
            class="注释编号">4</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          本书中出现的示例仓库，现阶段将主要由译者及志愿者（包括尝试 Pull Request 的各位读者）进行维护。但是在本书出版后，随着时间推移，可能会发生反应变慢甚至没有反应的情况。烦请参照第 7
          章的内容以及关于示例仓库的讲解，一同努力维护。
        </p>
        <p class="图"><img src="Image00079.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 6.6　Pull Request</strong>
        </p>
        <h2 id="nav_point_145">
          <strong>6.4　让 Pull Request 更加有效的方法</strong>
        </h2>
        <p>下面为各位介绍在开发现场如何更有效地运用 Pull Request。</p>
        <h3 id="nav_point_146">
          <strong>在开发过程中发送 Pull Request 进行讨论</strong>
        </h3>
        <p>在软件的设计与实现过程中如果想发起讨论，Pull Request 是个非常好的契机。我们虽然可以像本次示例一样等代码完成后再发送 Pull
          Request，但在实际开发过程中，这样做很可能导致一个功能在完成后才收到设计或实现方面的指正，从而使代码需要大幅更改或重新实现。</p>
        <p>在 GitHub 上，我们可以尽早创建 Pull Request，从审查中获得反馈，让大家在设计与实现方面思路一致，借此逐渐提高代码质量。这个方法在团队开发大型项目时尤其有效，已将 GitHub 运用到实际开发中的团
          队请务必试一试。</p>
        <p>这个方法执行起来很简单。只要在想发起讨论时发送 Pull Request 即可，不必等代码最终完成。即便某个功能尚在开发之中，只要在 Pull Request
          中附带一段简单代码让大家有个大体印象，就能获取不少反馈。如果在 Pull Request 中再加入直观易懂的 Tasklist（请参照第 5 章的“Tasklist
          语法”），就能很清楚反映出哪些功能已经实现，将来要做哪些工作。这不但能加快审查者的工作效率，还能作为自己的备忘录使用。</p>
        <p>从反馈中，我们不但能获得对自己所提议的新功能的支持和相关改善意见，有时还会被人指出自己没注意到的失误，或者准备编写的代码与其他成员重复等。这样一来，我们最终所完成的代码的质量一定会比原先高出许多。</p>
        <p>向发送过 Pull Request 的分支添加提交时，该提交会自动添加至已发送的 Pull Request 中。</p>
        <p>这一方法要求尽早发送 Pull Request，越早效果越明显。另外还有一件事要记住，就是千万不要在 Pull Request 中添加无关的修改。处理与主题无关的作业请另外创建分支，不然会让原本清晰的讨论变得一团糟。
        </p>
        <h3 id="nav_point_147">
          <strong>明确标出“正在开发过程中”</strong>
        </h3>
        <p>为防止开发到一半的 Pull Request 被误合并，一般都会像图 6.7 中所示的那样在标题前加上“[WIP]”字样。WIP 是 Work In Progress
          的简写，表示仍在开发过程中。等所有功能都实现之后，再消去这个前缀。</p>
        <p class="图"><img src="Image00080.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 6.7　标明仍在开发中的 Pull Request</strong>
        </p>
        <p>这种在代码库中边讨论边开发的开发流程，要比以往在完成之后审查再反馈的流程高效得多。这个方法已经被应用到众多的软件开发现场。通过这一方法，开发者可以体验 GitHub 上独有的速度感。各位请务必加以实践。</p>
        <h3 id="nav_point_148">
          <strong>不进行 Fork 直接从分支发送 Pull Request</strong>
        </h3>
        <p>这个方法也值得在 GitHub 上进行开发的团队借鉴。</p>
        <p>一般说来，在 GitHub 上修改对方的代码时，需要先将仓库 Fork 到本地，然后再修改代码，发送 Pull Request。但是，如果用户对该仓库有编辑权限，则可以直接创建分支，从分支发送 Pull
          Request。利用这一设计，团队开发时不妨为每一名成员赋予编辑权限，免去 Fork 仓库的麻烦。这样，成员在有需要时就可以创建自己的分支，然后直接向 master 分支等发送 Pull Request。</p>
        <p>其实，这一方法已经被 GitHub 实际运用到开发之中 <span class="注释编号">5</span>
          。关于这一开发流程的具体内容将在第 9 章详细说明。</p>
        <p class="注释内容">
          <span class="注释编号下">5</span>
          <a
            href="https://github.com/blog/1124-how-we-ues-pull-requests-to-build-github">https://github.com/blog/1124-how-we-ues-pull-requests-to-build-github</a>
        </p>
        <h2 id="nav_point_149">
          <strong>6.5　仓库的维护</strong>
        </h2>
        <p>Fork 或 clone 来的仓库，一旦放置不管就会离最新的源代码越来越远。如果不以最新的源代码为基础进行开发，劳神费力地编写代码也很可能是白费力气。下面就让我们学习如何让仓库保持最新状态。</p>
        <p>通常来说 clone 来的仓库实际上与原仓库并没有任何关系。所以我们需要将原仓库设置为远程仓库，从该仓库获取（fetch）数据与本地仓库进行合并（merge），让本地仓库的源代码保持最新状态（图 6.8）。</p>
        <p class="图"><img src="Image00081.jpg" alt="" width="75%" style="width: 75%" />
        </p>
        <p class="p-img-title">
          <strong>图 6.8　将仓库更新至最新状态</strong>
        </p>
        <h3 id="nav_point_150">
          <strong>仓库的 Fork 与 clone</strong>
        </h3>
        <p>将 octocat/Spoon-Knife 作为原仓库，在 GitHub 上进行 Fork，然后 clone。</p>
        <pre class="代码无行号">
<code>$ git clone git@github.com:hirocastest/Spoon-Knife.git
Cloning into 'Spoon-Knife'...
remote: Counting objects: 24, done.
remote: Compressing objects: 100% (21/21), done.
remote: Total 24 (delta 7), reused 17 (delta 1)
Receiving objects: 100% (24/24), 74.36 KiB | 68 KiB/s, done.
Resolving deltas: 100% (7/7), done.
$ cd Spoon-Knife

</code>
</pre>
        <h3 id="nav_point_151">
          <strong>给原仓库设置名称</strong>
        </h3>
        <p>我们给原仓库设置 upstream 的名称，将其作为远程仓库。</p>
        <pre class="代码无行号">
<code>$ git remote add upstream git://github.com/octocat/Spoon-Knife.git

</code>
</pre>
        <p>今后，我们的这个仓库将以 upstream 作为原仓库的标识符。这个环境下只需要设定一次。</p>
        <h3 id="nav_point_152">
          <strong>获取最新数据</strong>
        </h3>
        <p>下面我们从远程仓库实际获取（fetch）最新源代码，与自己仓库的分支进行合并。要让仓库维持最新状态，只需要重复这一工作即可。</p>
        <pre class="代码无行号">
<code>$ git fetch upstream
From git://github.com/octocat/Spoon-Knife
 * [new branch]      master     -&gt; upstream/master
$ git merge upstream/master
Already up-to-date.

</code>
</pre>
        <p>我们通过 <code>git fetch</code>
          命令获取最新的数据，将 upstream/master 分支与当前分支（master）合并。虽然本次示例没有可以合并的内容，但这一操作确实可以将最新的源代码合并至当前分支。</p>
        <p>这样一来，当前分支（master）就获得了最新的源代码。各位在创建特性分支，编辑源代码之前，建议先将仓库更新到这一状态。一般情况下 master 分支都会获取最新代码，很少需要 Fork 的开发者亲自进行修正。</p>
        <h2 id="nav_point_153">
          <strong>6.6　小结</strong>
        </h2>
        <p>本章中我们简单学习了 Pull Request 的发送方法。想必各位已经发现，发送 Pull Request 时不单要敲一敲代码，还需要进行很多其他工作。</p>
        <p>在实际开发现场，Pull Request 多少都会与传统的习惯或规范有些冲突。但是，诸多团队的实践表明 Pull Request 确实有其显著的效果。作为一名投身于开源开发的程序员，应当尽早适应这一设计。</p>
        <p>笔者认为，对这种标准的设计或规范采取“总之先试试看”的态度，往往可以给现场带来活力，促进成员成长，给开发带来速度感。建议各位积极地去尝试。</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_154">
          <strong>第 7 章　接收Pull Request</strong>
        </h1>
        <p>发送过 Pull Request 的人不多，接收过 Pull Request 的人就更少了。下面让我们来学习接收 Pull Request 时的相关知识，以备不时之需。</p>
        <h2 id="nav_point_155">
          <strong>7.1　采纳 Pull Request 的方法</strong>
        </h2>
        <p>接收到 Pull Request 后，会如图 7.1 中所示，在仓库的 Pull Request 标签页中显示别人发送过来的 Pull Request 的一览表。现在让我们点击 Pull Request 查看详细内容。
        </p>
        <p class="图"><img src="Image00082.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 7.1　接收到的 Pull Request</strong>
        </p>
        <p>详细页面与我们发送 Pull Request 时的页面大致相同。点击 Merge pull request 按钮（图 7.2），Pull Request 的内容便会自动合并至仓库。在采纳之前，请尽量将接收到的 Pull
          Request 拿到本地开发环境中进行检查，确认是否能够正常运行以及代码是否安全。或者用将要在第 8 章中介绍的 Jenkins 等持续集成工具进行自动测试，保证新代码不破坏原有功能之后，再合并进仓库。</p>
        <p class="图"><img src="Image00083.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 7.2　Merge pull request 按钮</strong>
        </p>
        <p>这里我们为各位讲解在本地开发环境中检查接收到的 Pull Request 的流程。</p>
        <h2 id="nav_point_156">
          <strong>7.2　采纳 Pull Request 前的准备</strong>
        </h2>
        <p>除确认 Pull Request 送来的代码是否运行正常外，各位还请在代码审查上也多花些心思。GitHub 上可以快速高效地审查代码。下面我们就来介绍这些功能。</p>
        <p>学会使用各种各样的功能进行代码审查，要比以往使用工具的审查轻松很多。如果团队中所有人都养成时常审查自己代码的习惯，其叠加效果将不可估量。</p>
        <h3 id="nav_point_157">
          <strong>代码审查</strong>
        </h3>
        <p>如图 7.3 所示，在 GitHub 上可以对 Pull Request 的具体的某行代码进行评论。这让代码审查变得十分高效。</p>
        <p class="图"><img src="Image00084.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 7.3　对代码进行评论</strong>
        </p>
        <p>
          <sup>※ 每行前左侧的数字为该提交修改前的行号，右侧为修改后的行号。</sup>
        </p>
        <p>发出评论之后相关人员会立刻接到 Notifications，无论是 Pull Request 的发送方还是接收方，都能迅速反馈。由于 GitHub 的便捷性和审查的简易性，让很多人离开 GitHub
          之后在工作中倍感压力。</p>
        <p>混迹于开源世界的程序员大多习惯使用 GitHub，所以如果能将 GitHub 应用到工作中，就可以免去适应公司独有开发环境带来的压力。这也是公司导入 GitHub 的优势所在。</p>
        <h3 id="nav_point_158">
          <strong>查看图片的差别</strong>
        </h3>
        <p>在 GitHub 上不但可以查看代码的差别，还有多种方法供用户查看图片的差别。这些内容在官方博客 <span class="注释编号">1</span>
          中有详细讲解，我们只在此挑出一些介绍给各位。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a
            href="https://github.com/blog/817-behold-image-view-modes">https://github.com/blog/817-behold-image-view-modes</a>
        </p>
        <p>官方博客已经介绍了用于演示的仓库 <span class="注释编号">2</span>
          ，所以各位实际操作一下该仓库，就会发现这个功能有多么强大 <span class="注释编号">3</span>
          。各位可以通过提交日志的 Image View Mode Demo 来体验操作。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a
            href="https://github.com/cameronmcefee/Image-Diff-View-Modes">https://github.com/cameronmcefee/Image-Diff-View-Modes</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          本章的图片就是通过演示仓库制作的。
        </p>
        <h4 id="sigil_toc_id_109">
          <strong>……2-up</strong>
        </h4>
        <p>2-up 可以同时显示一张旧图片和一张新图片，从而完成对比（图 7.4）。</p>
        <p class="图"><img src="Image00085.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 7.4　2-up</strong>
        </p>
        <h4 id="sigil_toc_id_110">
          <strong>……Swipe</strong>
        </h4>
        <p>Swipe 可以在分界线左右两侧分别显示旧图片和新图片（图 7.5）。鼠标可以拖动分界线左右移动，帮助用户对比细节差异和细微的颜色差异。</p>
        <p class="图"><img src="Image00086.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 7.5　Swipe</strong>
        </p>
        <h4 id="sigil_toc_id_111">
          <strong>……Onion Skin</strong>
        </h4>
        <p>Onion Skin 能够将新旧两张图片重叠放置，分阶段从旧图片慢慢过渡至新图片，用户可以自由调节过渡比例（图 7.6）。通过这一功能，用户能够一步步确认新图片相对于旧图片的变化。</p>
        <p class="图"><img src="Image00087.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 7.6　Onion Skin</strong>
        </p>
        <h4 id="sigil_toc_id_112">
          <strong>……Difference</strong>
          <span class="注释编号">4</span>
        </h4>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          现在只有前面三种差分模式，此种方式已经没有了。——译者注
        </p>
        <p>Difference 功能让笔者都感到吃惊，它能够直接抽出两张图片不一样的部分进行比较。如图 7.7 所示，Difference 抽出了单片眼镜这一差别之处。要是拿这个功能去玩“大家来找茬”，一定是所向披靡。</p>
        <p class="图"><img src="Image00088.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 7.7　Difference</strong>
        </p>
        <p>像这样，使用 GitHub 不但可以比较代码，还能够高效地对比图片。各位不妨让负责美工的同事也来试试。</p>
        <h3 id="nav_point_159">
          <strong>在本地开发环境中反映 Pull Request 的内容</strong>
        </h3>
        <p>下面我们来讲解收到 Pull Request 后在本地开发环境中进行实际检查的流程。在本示例中，Pull Request 接收方的用户名为 ituring，发送方的用户名为“PR 发送者”。</p>
        <h4 id="sigil_toc_id_113">
          <strong>……将接收方的本地仓库更新至最新状态</strong>
        </h4>
        <p>首先，将 Pull Request 接收方的仓库 clone 到本地开发环境中（图 7.8 左侧）。如果已经 clone 过，那么请进行 pull 等操作更新至最新状态。</p>
        <p class="图"><img src="Image00089.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 7.8　clone 及 fetch</strong>
        </p>
        <pre class="代码无行号">
<code>$ git clone git@github.com:ituring/first-pr.git
Cloning into 'first-pr'...
remote: Counting objects: 34, done.
remote: Compressing objects: 100% (26/26), done.
remote: Total 34 (delta 10), reused 15 (delta 4)
Receiving objects: 100% (34/34), 89.48 KiB | 112 KiB/s, done.
Resolving deltas: 100% (10/10), done.
$ cd first-pr

</code>
</pre>
        <h4 id="sigil_toc_id_114">
          <strong>……获取发送方的远程仓库</strong>
        </h4>
        <p>将 Pull Request 发送方的仓库设置为本地仓库的远程仓库，获取发送方仓库的数据。在本示例中，我们将图 7.8 右上的仓库设置为远程仓库，进行 fetch。</p>
        <pre class="代码无行号">
<code>$ git remote add PR发送者 git@github.com:PR发送者/first-pr.git
$ git fetch PR发送者
省略
From github.com:PR发送者/first-pr
 * [new branch]       gh-pages   -&gt; PR发送者/gh-pages
 * [new branch]       master     -&gt; PR发送者/master
 * [new branch]       work       -&gt; PR发送者/work

</code>
</pre>
        <p>现在我们获取了 Pull Request 发送方仓库以及分支的数据（PR 发送者 /work）。</p>
        <h4 id="sigil_toc_id_115">
          <strong>……创建用于检查的分支</strong>
        </h4>
        <p>前面我们只获取了远程仓库的数据，这些数据尚未反映在任何一个分支中。因此我们需要创建一个分支，用来模拟采纳 Pull Request 后的状态。由于这是我们第一个 Pull Request，分支名就叫
          pr1。这一步相当于图 7.9 左侧箭头（checkout）代表的操作。现在 gh-pages 与 pr1 分支的内容完全相同。</p>
        <p class="图"><img src="Image00090.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 7.9　checkout</strong>
        </p>
        <pre class="代码无行号">
<code>$ git checkout -b pr1
Switched to a new branch 'pr1'

</code>
</pre>
        <h4 id="sigil_toc_id_116">
          <strong>……合并</strong>
        </h4>
        <p>下面要将已经 fetch 完毕的“PR 发送者 /work”的修改内容与 pr1 分支进行合并。也就是图 7.9 下侧箭头（merge）代表的操作。</p>
        <pre class="代码无行号">
<code>$ git merge PR发送者/work
Updating cc62779..243f28d
Fast-forward
 index.html |    2 ++
 1 file changed, 2 insertions(+)

</code>
</pre>
        <p>这样一来，pr1 分支中就加入了“PR 发送者 /work”分支的修改内容。本示例中我们只修改了 index.html 文件，所以检查一下 index.html
          有没有显示错误即可。在实际开发中，各位需要通过自动测试等手段检查软件是否能正常运行。</p>
        <h4 id="sigil_toc_id_117">
          <strong>……删除分支</strong>
        </h4>
        <p>检查结束后 pr1 分支就没用了，可以直接删除。我们切换至 pr1 之外的分支，运行下面的代码。</p>
        <pre class="代码无行号">
<code>$ git branch -D pr1
Deleted branch pr1 (was 243f28d).

</code>
</pre>
        <blockquote>
          <p>
            <strong>专栏：如何提升代码管理技术</strong>
          </p>
          <p>如果能灵活运用分支的创建及合并，便可以在确保安全性的前提下并行开发多个功能。这一技术在软件开发现场非常有用，而且团队规模越大效果越好。</p>
          <p>笔者认为掌握这一技术的最佳方法就是积累经验。在 GitHub 上，可以通过自己给自己的不同分支发送 Pull Request 进行练习。</p>
          <p>想学会安全又专业的源代码管理，不妨先多多尝试 Git 与 GitHub。</p>
        </blockquote>
        <h2 id="nav_point_160">
          <strong>7.3　采纳 Pull Request</strong>
        </h2>
        <p>完成上述内容后，如果 Pull Request 的内容没有问题，大可打开浏览器找出相应的 Pull Request 页面，点击 Merge pull request 按钮，随后 Pull Request
          的内容会自动合并至仓库（图 7.10）。</p>
        <p class="图"><img src="Image00091.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 7.10　自动合并的概念图</strong>
        </p>
        <p>不过，由于我们已经在本地构筑了相同的环境，只要通过 CLI 进行合并操作再 push 至 GitHub，Pull Request 中就会反映出 Pull Request 被采纳后的状态（图
          7.11）。这个状态对应到本示例中就是“PR 发送者 / work”分支合并到 gh-pages 分支。</p>
        <p class="图"><img src="Image00092.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 7.11　手动合并的概念图</strong>
        </p>
        <h3 id="nav_point_161">
          <strong>合并到主分支</strong>
        </h3>
        <p>首先，我们切换至 gh-pages 分支。</p>
        <pre class="代码无行号">
<code>$ git checkout gh-pages
Switched to branch 'gh-pages'

</code>
</pre>
        <p>然后合并“PR 发送者 /work”分支的内容。</p>
        <pre class="代码无行号">
<code>$ git merge PR送信者/work
Updating cc62779..243f28d
Fast-forward
 index.html |    2 ++
 1 file changed, 2 insertions(+)

</code>
</pre>
        <p>这样一来“PR 发送者 /work”分支就合并到了 gh-pages 分支中。</p>
        <h3 id="nav_point_162">
          <strong>push 修改内容</strong>
        </h3>
        <p>现在只剩下 push 一步了，不过为保险起见，我们先查看本地与 GitHub 端仓库内代码的差别。</p>
        <pre class="代码无行号">
<code>$ git diff origin/gh-pages
diff --git a/index.html b/index.html
index f2034b3..91b8ecb 100644
--- a/index.html
+++ b/index.html
@@ -39,6 +39,8 @@
    　
&lt;p&gt;请写明这是对本书的实践或描述对本书的感想并发送Pull Request。&lt;/p&gt;
    　
+&lt;p class="impression"&gt;这本书读着很有趣。（@HIROCASTER）&lt;/p&gt;
+
省略

</code>
</pre>
        <p>确认没有目的之外的差别后，进行 push。</p>
        <pre class="代码无行号">
<code>$ git push
省略
Total 0 (delta 0), reused 0 (delta 0)
To git@github.com:ituring/first-pr.git
   cc62779..243f28d local_gh-pages -&gt; gh-pages

</code>
</pre>
        <p>用这种方法处理后，仓库的 Pull Request 会自动从 Open 状态变为 Close 状态（图 7.12）。现在我们可以去查看网页，已采纳的源代码应该已经反映出来了。</p>
        <p class="图"><img src="Image00093.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 7.12　Pull Request 自动转为 Close 状态</strong>
        </p>
        <p>以上便是安全接收 Pull Request 的流程。Git 这种分散型版本管理软件乍看上去非常复杂，但熟悉每一个操作后，运用起来还是很简单的。</p>
        <h2 id="nav_point_163">
          <strong>7.4　小结</strong>
        </h2>
        <p>本章中我们讲解了如何安全地接收 Pull Request。</p>
        <p>像本次示例中这种只有几行代码的 Pull Request，大可直接打开 GitHub 网页点击合并，但在实际的开发现场中，接收到的 Pull Request
          往往会更加复杂，有时甚至与多个文件挂钩。所以各位要清楚本次示例只是为练习而准备，是 Pull Request 最简单的情况。</p>
        <p>作为仓库的维护者要时刻记得，无法运行的代码绝不可以合入仓库，否则会失去团队对你的信任。</p>
        <p>另外还要注意，不要发布那些无法运行的、没有通过测试的、有语法错误的源代码。</p>
        <blockquote>
          <p>
            <strong>专栏：请协助我们共同创建互相学习的社区</strong>
          </p>
          <p>关于本章和第 6 章提到的那个仓库，只要您在第 6 章中发送过 Pull Request，就会得到该仓库的管理权限，以便您对该仓库进行维护。各位可以参考本章内容，试着以仓库维护者的身份处理新送来的 Pull
            Request。这样一来，各位读者就可以通过一个仓库，互相学习 Pull Request 收发双方的相关知识。</p>
          <p>各位读者的协助不但能帮助新的读者进行学习，还可以积累作为维护方的经验。请各位务必与我们一同维护这个互相学习的社区。</p>
        </blockquote>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_164">
          <strong>第 8 章　与GitHub相互协作的工具及服务</strong>
        </h1>
        <p>GitHub 的诞生并不单单影响到了软件开发的相关人员。现在的 GitHub 已经真正成为了一个 Hub，与其相互协作的工具和服务层出不穷。下面让我们为各位介绍几个比较常用的服务。</p>
        <h2 id="nav_point_165">
          <strong>8.1　hub 命令</strong>
        </h2>
        <p>在使用 GitHub 的过程中，会不可避免地频繁接触到 git 命令。而我们在这里介绍的 hub 命令 <span class="注释编号">1</span>
          则是一个封装了 git 命令的命令行工具，能够辅助用户使用 GitHub。这是个很方便的工具，经常使用 GitHub 的读者请务必一试。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a href="https://hub.github.com/">https://hub.github.com/</a>
        </p>
        <h3 id="nav_point_166">
          <strong>概要</strong>
        </h3>
        <p>hub 命令是由 Chris Wanstrath<span class="注释编号">2</span>
          带头开发的软件。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a href="https://github.com/defunkt">https://github.com/defunkt</a>
        </p>
        <p>在 hub 命令仓库的 README.md 文件中，我们可以看到“git ＋ hub ＝ github”这样一句话 <span class="注释编号">3</span>
          。正如这句话所说，hub 命令将通常的 git 命令进行封装并增加几项功能，就可以调用 GitHub 的 API 发送命令。由于其封装了 git 命令，所以能够执行所有 git 命令的操作。另外通过 hub
          命令功能还得到了扩展，比如指定 GitHub 端仓库时可以用简略路径替代完整路径等。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          <a href="https://github.com/github/hub">https://github.com/github/hub</a>
        </p>
        <p>具体的命令我们将在后面详细讲解。</p>
        <h3 id="nav_point_167">
          <strong>安装</strong>
        </h3>
        <p>下面介绍 hub 命令的安装方法。hub 命令需要以下版本的软件 <span class="注释编号">4</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          对应 hub 1.10.6 版本。
        </p>
        <ul>
          <li>
            <p>Git 1.7.3 以上</p>
          </li>
          <li>
            <p>Ruby 1.8.6 以上</p>
          </li>
        </ul>
        <p>安装 Git 的方法请参照第 2 章。</p>
        <h4 id="sigil_toc_id_118">
          <strong>……安装</strong>
        </h4>
        <p>如果是 OS X 系统，可以从版本管理系统的 Homebrew 或 MacPorts 轻松安装。</p>
        <p>如果用 Homebrew，则执行下面的命令。</p>
        <pre class="代码无行号">
<code>$ brew install hub

</code>
</pre>
        <p>如果用 MacPorts，则执行下面的命令。</p>
        <pre class="代码无行号">
<code>$ sudo port install hub

</code>
</pre>
        <p>只此一步就能完成安装。</p>
        <p>使用其他环境的读者请按照下面的流程安装。</p>
        <pre class="代码无行号">
<code>$ curl https://hub.github.com/standalone -sLo ~/bin/hub
$ chmod +x ~/bin/hub

</code>
</pre>
        <p>通过上述命令下载 hub 命令之后，像下面这样在 shell 的环境路径后面添加 ~/bin。</p>
        <pre class="代码无行号">
<code>$ echo 'export PATH="~/bin:$PATH"' &gt;&gt; ~/.bash_profile

</code>
</pre>
        <p>重新启动 shell 后，就可以使用 hub 命令了。</p>
        <h4 id="sigil_toc_id_119">
          <strong>……确认运行情况</strong>
        </h4>
        <p>通过下面的命令确认运行情况。</p>
        <pre class="代码无行号">
<code>$ hub --version
git version 1.8.5.2
hub version 1.10.6

</code>
</pre>
        <p>结果中显示了 git 命令与 hub 命令的版本号。</p>
        <h4 id="sigil_toc_id_120">
          <strong>……设置别名</strong>
        </h4>
        <p>使用 hub 命令的最佳实践就是将相应 git 设置成 hub 的别名。hub 命令可以完成 git 命令的所有操作，所以不会影响 git 命令原本的功能。</p>
        <p>具体设置方法其实很简单，只需在 shell 的配置文件（.bash_profile 等）中添加下面一句即可。</p>
        <pre class="代码无行号">
<code>eval "$(hub alias -s)"

</code>
</pre>
        <h4 id="sigil_toc_id_121">
          <strong>……实现 shell 上的功能补全</strong>
        </h4>
        <p>为了让 hub 命令的功能更加完善，Github 上还发布了面向 bash<span class="注释编号">5</span>
          和 zsh<span class="注释编号">6</span>
          的脚本。将正在使用的 shell 与相应脚本组合，就可以让 hub 命令变得更加易用。在某些安装方法中它们会被自动安装。</p>
        <p class="注释内容">
          <span class="注释编号下">5</span>
          <a
            href="https://github.com/defunkt/hub/blob/master/etc/hub.bash_completion.sh">https://github.com/defunkt/hub/blob/master/etc/hub.bash_completion.sh</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">6</span>
          <a
            href="https://github.com/defunkt/hub/blob/master/etc/hub.zsh_completion">https://github.com/defunkt/hub/blob/master/etc/hub.zsh_completion</a>
        </p>
        <h4 id="sigil_toc_id_122">
          <strong>……~/.config/hub</strong>
        </h4>
        <p>hub 命令在初次访问 GitHub 的 API 时会询问用户名和密码，输入完之后会进行 OAuth 认证，然后我们就可以通过 API 操作 GitHub 了。这时 OAuth Token 会自动保存在
          ~/.config/hub 中。各位请慎重保管这个 Token。</p>
        <pre class="代码无行号">
<code>---
github.com:
- oauth_token:  Oauth Token
  user: hirocaster

</code>
</pre>
        <h3 id="nav_point_168">
          <strong>命令</strong>
        </h3>
        <p>下面我们来实际使用 hub 命令，看看它为 Git 扩展了哪些功能。</p>
        <p>为了与 git 命令区分得更明显，接下来讲解的内容中我们都直接输入 hub 命令。已经将 git 命令设置为别名的读者可以把 hub 的部分替换为 git，运行效果是一样的。当然，直接输入 hub
          命令也不会有任何问题。</p>
        <h3 id="nav_point_169">
          <strong>……hub clone</strong>
        </h3>
        <p>使用 <code>hub clone</code>
          命令，可以省去指定 GitHub 端仓库的部分。</p>
        <pre class="代码无行号">
<code>$ hub clone Hello-World

</code>
</pre>
        <p>上面这个命令与下面的命令效果相同。</p>
        <pre class="代码无行号">
<code>$ git clone git@github.com/用户名/Hello-World.git

</code>
</pre>
        <p>如果要指定用户，可以输入以下命令。</p>
        <pre class="代码无行号">
<code>$ hub clone octocat/Hello-World

</code>
</pre>
        <p>效果与下面这个命令完全相同。</p>
        <pre class="代码无行号">
<code>$ git clone git://github.com/octocat/Hello-World.git

</code>
</pre>
        <h3 id="nav_point_170">
          <strong>……hub remote add</strong>
        </h3>
        <p>
          <code>hub remote add</code>
          也可以省略指定 GitHub 端仓库的部分。
        </p>
        <pre class="代码无行号">
<code>$ hub remote add octocat

</code>
</pre>
        <p>上面这个命令与</p>
        <pre class="代码无行号">
<code>$ git remote add octocat git://github.com/octocat/当前操作仓库的名称.git

</code>
</pre>
        <p>的效果完全相同。</p>
        <h4 id="sigil_toc_id_123">
          <strong>……hub fetch</strong>
        </h4>
        <p>
          <code>hub fetch</code>
          与 <code>hub remote add</code>
          命令一样，只需输入用户名就可以指定当前操作的仓库执行命令，在此不再赘述。
        </p>
        <h4 id="sigil_toc_id_124">
          <strong>……hub cherry-pick</strong>
        </h4>
        <p>
          <code>hub cherry-pick</code>
          命令只需要输入 URL 就可以获取对应修改并应用到当前分支。在审查代码时，如果发现某个提交中包含值得应用到当前分支的修改，用这个命令可以轻松完成操作。
        </p>
        <pre class="代码无行号">
<code>$ hub cherry-pick https://github.com/hirocaster/github-book/commit/606a76f6831194cfe8a0fdcd6e974a29a4526cbf 实际为1行

</code>
</pre>
        <p>这个命令可以将下面两个命令的效果一次性执行。</p>
        <pre class="代码无行号">
<code>$ git remote add -f hirocaster git://github.com/hirocaster/github-book.git
$ git cherry-pick 606a76f6831194cfe8a0fdcd6e974a29a4526cbf

</code>
</pre>
        <h4 id="sigil_toc_id_125">
          <strong>……hub fork</strong>
        </h4>
        <p>
          <code>hub fork</code>
          命令的功能与 GitHub 页面的 Fork 按钮相同。比如我们 clone 了其他用户的仓库，现在想 Fork 成自己的仓库，只需要执行
        </p>
        <pre class="代码无行号">
<code>$ hub fork

</code>
</pre>
        <p>这一命令，就可获得与下面这一系列操作相同的效果。</p>
        <pre class="代码无行号">
<code>（在GitHub上对仓库做Fork处理）
$ git remote add -f 用户名 git@github.com:当前操作仓库的名称.git

</code>
</pre>
        <p>执行完毕后，Fork 出的仓库会被设置成当前本地仓库的远程仓库（以用户名为标识符）。</p>
        <h4 id="sigil_toc_id_126">
          <strong>……hub pull-request</strong>
        </h4>
        <p>
          <code>hub pull-request</code>
          命令为我们提供了创建 Pull Request 的功能。利用这个命令创建 Pull Request 可以不必访问 GitHub 页面。
        </p>
        <pre class="代码无行号">
<code>$ hub pull-request -b github-book:master -h hirocaster:index5-draft

</code>
</pre>
        <p>使用这条命令，可以从 hirocaster 的 index5-draft 分支向 github-book 的 master 分支发送 Pull Request。执行命令后编辑器会启动，用户可以在编辑器中按照一般
          Pull Request 的方式进行描述。第一行将成为 Pull Request 的标题，之后空一行，从第三行开始是 Pull Request 的正文。</p>
        <p>如果 index5-draft 的作业内容是已创建的 Issue#123 的作业内容，我们可以直接将 Issue 作为 Pull Request 发送。</p>
        <pre class="代码无行号">
<code>$ hub pull-request -i 123 -b github-book:master -h hirocaster:index5-draft

</code>
</pre>
        <p>只需附加参数 <code>- i</code>
          以及 Issue 的编号即可。目前在 Web 上无法像这样将 Issue 直接作为 Pull Request 发送，所以建议各位开发者记下这个技巧。</p>
        <h4 id="sigil_toc_id_127">
          <strong>……hub checkout</strong>
        </h4>
        <p>收到 Pull Request 的时候，如果想在本地检查该分支的运行状况，可以使用 <code>hub checkout</code>
          命令。只需要在命令后添加相应 Pull Request 的 URL，就可以将接收到的分支 checkout。</p>
        <pre class="代码无行号">
<code>$ hub checkout https://github.com/hirocaster/wdpress69/pull/208

</code>
</pre>
        <p>这个命令与下面两个命令效果相同。</p>
        <pre class="代码无行号">
<code>$ git remote add -f -t impression git://github.com/tomamu/wdpress69.git
$ git checkout --track -B tomamu-impression tomamu/impression

</code>
</pre>
        <p>执行之后系统会以“Pull Request 发送方的用户名 - 分支名”的形式在本地仓库中创建分支。Pull Request 送来的内容已经 checkout 完毕，管理者可以轻松地检查运行状况。</p>
        <h4 id="sigil_toc_id_128">
          <strong>……hub create</strong>
        </h4>
        <p>
          <code>hub create</code>
          命令适用于本地已经创建仓库，但 GitHub 端没有创建仓库的情况。
        </p>
        <pre class="代码无行号">
<code>$ hub create

</code>
</pre>
        <p>只需要输入上面这个简短的命令，GitHub 端就会创建一个同名仓库，并将其设置为本地仓库的远程仓库。这与下面这一系列操作效果相同。</p>
        <pre class="代码无行号">
<code>（在GitHub上创建仓库）
$ git remote add origin git@github.com:用户名/当前操作仓库的名称.git

</code>
</pre>
        <p>现在只要进行 push，代码就可以放到 GitHub 端的仓库中。需要注意的是，这种方法创建的都是公开仓库，请谨慎使用。</p>
        <h4 id="sigil_toc_id_129">
          <strong>……hub push</strong>
        </h4>
        <p>
          <code>hub push</code>
          命令支持同时向多个远程仓库进行 push 操作。
        </p>
        <pre class="代码无行号">
<code>$ hub push origin,staging,qa new-feature

</code>
</pre>
        <p>这一命令可以对下列远程仓库同时执行 <code>git push</code>
          命令。</p>
        <ul>
          <li>
            <p>origin</p>
          </li>
          <li>
            <p>staging</p>
          </li>
          <li>
            <p>qa</p>
          </li>
        </ul>
        <p>如果遇到需要向多个仓库进行 push 操作的情况，各位不妨试一试。</p>
        <h4 id="sigil_toc_id_130">
          <strong>……hub browse</strong>
        </h4>
        <p>
          <code>hub browse</code>
          命令可以在浏览器中打开当前操作的仓库在 GitHub 上对应的仓库页面。
        </p>
        <pre class="代码无行号">
<code>$ hub browse

</code>
</pre>
        <p>这个命令与下面的效果相同。</p>
        <pre class="代码无行号">
<code>$ open https://github.com/用户名/当前操作仓库的名称

</code>
</pre>
        <p>执行后，当前操作仓库的页面会在浏览器中打开。</p>
        <h4 id="sigil_toc_id_131">
          <strong>……hub compare</strong>
        </h4>
        <p>如果想查看当前特性分支与 master 分支的差别，可以使用 hub compare 命令。这个命令能够打开 GitHub 上对应的查看差别的页面。</p>
        <p>在特性分支下执行下面的命令。</p>
        <pre class="代码无行号">
<code>$ hub compare

</code>
</pre>
        <p>其效果与执行下面命令的效果相同。</p>
        <pre class="代码无行号">
<code>$ open https://github.com/用户名/当前操作仓库的名称/compare/当前分支名

</code>
</pre>
        <p>执行后，GitHub 上查看分支间差别的页面就会打开。需要注意的是，这种方法是查看 GitHub 端仓库内的差别，如果最新代码在本地仓库，需要先将分支 push 给远程仓库。</p>
        <hr />
        <p>现在各位应该明白，导入 hub 命令可以使熟悉命令行操作的开发者对 GitHub 更加得心应手。我们只介绍了使用频率较高的一些命令，其实 hub 命令并不止这些。</p>
        <pre class="代码无行号">
<code>$ hub help

</code>
</pre>
        <p>执行上面的命令，可以查看 hub 命令的相关帮助。里面介绍了添加参数后更加细致的操作，各位不妨去看一看。</p>
        <blockquote>
          <p>
            <strong>专栏：让 GitHub Enterprise支持 hub命令</strong>
          </p>
          <p>hub 命令不但可以用于 GitHub，还可以用于 GitHub Enterprise 的操作。使用 GitHub Enterprise 的读者请运行下面的命令。</p>
          <pre class="代码无行号">
<code>$ git config --global --add hub.host my.example.org

</code>
</pre>
          <p>
            <sup>※ 请将 my.example.org 替换成 GitHub Enterprise 的主机名</sup>
          </p>
          <p>~/.gitconfig 文件中就会添加下面这条设置。</p>
          <pre class="代码无行号">
<code>[hub]
  host = my.example.org

</code>
</pre>
          <p>添加这条设置后，从 GitHub Enterprise 上 clone 来的仓库会以 GitHub Enterprise 为对象执行 hub 命令，而从 GitHub 上 clone 来的仓库仍和原来一样，以
            GitHub 为对象执行操作。</p>
        </blockquote>
        <h2 id="nav_point_171">
          <strong>8.2　Travis CI</strong>
        </h2>
        <h3 id="nav_point_172">
          <strong>概要</strong>
        </h3>
        <p>Travis CI<span class="注释编号">7</span>
          是一款免费服务，专门托管面向开源开发组织的 CI（Continuous Integration，持续集成）。</p>
        <p class="注释内容">
          <span class="注释编号下">7</span>
          <a href="http://travis-ci.org/">http://travis-ci.org/</a>
        </p>
        <p>CI 是 XP（Extreme Programming，极限编程）的实践之一。近年来人们普遍使用 Jenkins 等软件来实现这一目的。</p>
        <p>让 CI 软件监视仓库，可以在开发者发送提交后立刻执行自动测试或构建。通过持续执行这样一个操作，可以检测出开发者意外发送的提交或无意的逻辑偏差，让代码保持在一定质量以上。</p>
        <p>如果各位正在通过 GitHub 发布代码，建议使用 Travis CI。Travis CI 支持 Ruby、PHP、Perl、Python、Java、JavaScript 等 Web 相关的语言 <span
            class="注释编号">8</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">8</span>
          <a href="http://about.travis-ci.org/docs">http://about.travis-ci.org/docs</a>
        </p>
        <h3 id="nav_point_173">
          <strong>实际尝试</strong>
        </h3>
        <p>现在让我们来设置自己的仓库，让它可以使用 Travis CI。一般情况下，只要在仓库中添加 .travis.yml 这样一个 Travis CI 专用的文 件，Travis CI 就与 GitHub 集成了。</p>
        <h4 id="sigil_toc_id_132">
          <strong>……编写配置文件</strong>
        </h4>
        <p>我们以在 Ruby on Rails 上应用 RSpec 为例，编写 .travis.yml 文件。</p>
        <pre class="代码无行号">
<code>language: ruby
rvm:
  - 1.9.2
  - 1.9.3
script: bundle exec rspec spec

</code>
</pre>
        <p>如上所述，按照</p>
        <ul>
          <li>
            <p>所使用语言</p>
          </li>
          <li>
            <p>版本</p>
          </li>
          <li>
            <p>执行测试的相关命令</p>
          </li>
        </ul>
        <p>的顺序描述。如果一次描述多个版本，则会以每个版本分别进行测试。这样一来，用户可以迅速检测出代码在哪些版本下无法通过测试。</p>
        <p>如果各位使用其他种类的语言，请参考官方网站的相关文档 <span class="注释编号">9</span>
          。基本的设置方法不变。将这个文件放置到仓库的路径下再 push 给 GitHub 端，我们就基本完成了使用 Travis CI 的准备工作。</p>
        <p class="注释内容">
          <span class="注释编号下">9</span>
          <a
            href="http://about.travis-ci.org/docs/user/getting-started/">http://about.travis-ci.org/docs/user/getting-started/</a>
        </p>
        <h4 id="sigil_toc_id_133">
          <strong>……检测配置文件是否有问题</strong>
        </h4>
        <p>Travis CI 专门提供了 Travis WebLint 供用户检测 .travis.yml 文件是否存在问题 <span class="注释编号">10</span>
          。检测时只需指定仓库，如果发现问题会出现图 8.1 中的页面。</p>
        <p class="注释内容">
          <span class="注释编号下">10</span>
          <a href="http://lint.travis-ci.org/">http://lint.travis-ci.org/</a>
        </p>
        <p class="图"><img src="Image00094.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.1　通过 Travis WebLint 检测配置是否正常</strong>
        </p>
        <p>如果配置文件的描述有误，在实际启动 CI 后会返回错误结果，但此时人们往往搞不清问题出在哪里。所以在开始使用 CI 之前请务必进行这项检测。</p>
        <h4 id="sigil_toc_id_134">
          <strong>……与 GitHub 集成</strong>
        </h4>
        <p>现在让我们访问 Travis CI 的网站，点击右上角的 Sign in with GitHub。输入 GitHub 的用户名与密码后，会通过 GitHub 进行认证。认证完毕再回到这个页面，之前显示 Sign in
          with GitHub 的地方就变成了用户的 GitHub 信息。</p>
        <p>现在我们把鼠标指针移动到头像上，点击 Accounts 跳转至图 8.2 所示的页面。页面下部是我们的仓库列表。我们只要将仓库名右侧的开关置为 ON，就可以对该仓库应用 Travis CI。</p>
        <p class="图"><img src="Image00095.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.2　Accounts</strong>
        </p>
        <p>访问 GitHub 的 Webhooks &amp; Services 页面（图 8.3），点击 Configure services 后从列表中选择 Travis，我们就能看到 Travis 的设置了。点击 Test
          Hook 按钮，Travis CI 端会对这个仓库进行试验性的自动测试。现在我们再回到 Travis CI，查看自动测试是否正常执行。如果所执行内容与我们设置的相同，那么这次设置就算完成了。</p>
        <p>今后，向 GitHub 的 push 操作将会自动触发 Travis CI 端的自动测试。</p>
        <p class="图"><img src="Image00096.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.3　Hook 的测试</strong>
        </p>
        <p>这个仓库在 Travis CI 端的 URL 为 <code>https://travis-ci.org/用户名/仓库名</code>
          。用户可以在这个页面查看自动测试的执行情况。另外，跳转至 Travis CI 首页直接搜索自己的用户名等信息，也可以查询到测试的执行情况（图 8.4）。</p>
        <p class="图"><img src="Image00097.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.4　测试的执行情况</strong>
        </p>
        <p>在 .travis.yml 中写入设置，还可以通过邮件或 IRC（Internet Relay Chat，多人在线交谈系统）接收 Travis CI
          的执行结果。漏掉结果有百害而无一利，所以设置时一定要选择自己经常关注的地方。具体设置方法请参考官方文档 <span class="注释编号">11</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">11</span>
          <a
            href="http://about.travis-ci.org/docs/user/build-configuration/">http://about.travis-ci.org/docs/user/build-configuration/</a>
        </p>
        <h4 id="sigil_toc_id_135">
          <strong>……将 Travis CI 的结果添加至 README.md</strong>
        </h4>
        <p>各位在查看 GitHub 端仓库的 README.md 文件时，不知有没有见到过像图 8.5 中“build passing”那种绿色或红色的图片。这就是刚才 Travis CI 的执行结果。</p>
        <p class="图"><img src="Image00098.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.5　Travis CI 的状态图</strong>
        </p>
        <p>绿色的图片表示仓库内代码顺利通过了测试，相反红色的图片表示仓库没有通过测试，证明仓库很可能存在某种问题。将执行结果显示在 README.md 中，既可以显示仓库的健全性，又可以防止自己遗漏 Travis CI
          的结果，一举两得。</p>
        <p>如果采用了 Markdown 语法，只需按下面格式进行描述。</p>
        <pre class="代码无行号">
<code>[![Build Status](https://secure.travis-ci.org/用户名/仓库名.png
)](http://travis-ci.org/用户名/仓库名)

</code>
</pre>
        <h2 id="nav_point_174">
          <strong>8.3　Coveralls</strong>
        </h2>
        <h3 id="nav_point_175">
          <strong>概要</strong>
        </h3>
        <p>Coveralls<span class="注释编号">12</span>
          是由 Lemur Heavy Industries<span class="注释编号">13</span>
          运营的代码覆盖率检测服务。借助 Travis CI 或 Jenkins 等持续集成服务器，向用户报告自动测试的测试覆盖率（图 8.6）。</p>
        <p class="注释内容">
          <span class="注释编号下">12</span>
          <a href="https://coveralls.io/">https://coveralls.io/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">13</span>
          <a href="http://lemurheavy.com/">http://lemurheavy.com/</a>
        </p>
        <p class="图"><img src="Image00099.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.6　代码覆盖率的报告</strong>
        </p>
        <p>该服务支持 Ruby/Rails、Python、PHP、JavaScript/Node.js、C/C++、Java、Scala 等语言。详细内容请查看官方网站的相关文档 <span
            class="注释编号">14</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">14</span>
          <a href="https://coveralls.io/docs">https://coveralls.io/docs</a>
        </p>
        <p>除简略报告外，用户还可以查看代码每部分执行了多少次测试等信息（图 8.7）。</p>
        <p class="图"><img src="Image00100.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.7　详细报告</strong>
        </p>
        <p>Coveralls 可以为每一个 Pull Request
          生成一份报告，我们建议各位使用这项服务，以时常提醒自己注意覆盖率问题。另外，由于用户可以通过详细报告了解哪些代码没有被测试，所以还有助用户改进自动测试的内容，提高测试效率。</p>
        <p>这项服务对开源开发是免费的，私有仓库则需要支付一定费用。具体金额请查看官方网站 <span class="注释编号">15</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">15</span>
          <a href="https://coveralls.io/pricing">https://coveralls.io/pricing</a>
        </p>
        <p>下面我们来举例讲解 Coveralls 的安装方法。</p>
        <h3 id="nav_point_176">
          <strong>安装</strong>
        </h3>
        <p>Coveralls 的安装非常简单，但使用时有前提条件。</p>
        <ul>
          <li>
            <p>源代码保存在 GitHub 上</p>
          </li>
          <li>
            <p>已经集成了 Travis CI 或 Jenkins 等服务</p>
          </li>
        </ul>
        <p>只要满足以上条件，就可以立即使用 Coveralls。本章中我们讲解如何与 Travis CI 或 Jenkins 进行集成。</p>
        <p>这次我们借用 Ruby 开发的 CMS——lokka<span class="注释编号">16</span>
          来进行安装。</p>
        <p class="注释内容">
          <span class="注释编号下">16</span>
          <a href="https://github.com/lokka/lokka">https://github.com/lokka/lokka</a>
        </p>
        <h4 id="sigil_toc_id_136">
          <strong>……注册</strong>
        </h4>
        <p>访问 Coveralls 的首页并点击 FREE SIGN UP，可以经由 GitHub 注册账户。</p>
        <h4 id="sigil_toc_id_137">
          <strong>……添加对象仓库</strong>
        </h4>
        <p>账户注册成功后再到 Coveralls 的首页点击 ADD REPO，这里可以添加需要生成覆盖率报告的仓库。</p>
        <p>页面中会列表显示我们在 GitHub 端的仓库（图 8.8），添加时只需要将仓库名右边的开关设置为 ON。</p>
        <p class="图"><img src="Image00101.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.8　仓库列表</strong>
        </p>
        <p>返回 Coveralls 首页，我们能看到刚才设置为 ON 的仓库已经成为报告对象。点击链接会进入图 8.9 所示的页面，这个页面为我们讲解了如何编写 Coveralls 的配置文件以及需要安装哪些插件。</p>
        <h4 id="sigil_toc_id_138">
          <strong>……编写配置文件</strong>
        </h4>
        <p>Coveralls 的配置文件是 .coveralls.yml。我们将这个文件放到仓库路径下。文件内容如下所示。</p>
        <pre class="代码无行号">
<code>service_name: travis-ci    ←描述正在使用的CI

</code>
</pre>
        <p>如果各位使用其他的持续集成服务器（Jenkins 等），最好按照自己的需要将 service_name 改成简单易懂的名称。另外，这种情况下 repo_token 需要描述成
          repo_token:xxxxxyyyyyzzzz 的形式。repo_token 可以在图 8.9 所示的页面中找到。</p>
        <p class="图"><img src="Image00102.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.9　Coveralls 的配置解说页面</strong>
        </p>
        <h4 id="sigil_toc_id_139">
          <strong>……添加 gem</strong>
        </h4>
        <p>如果使用 Ruby 或 Rails，还需要添加 gem。使用其他语言的读者请查看官方网站的相应文档。</p>
        <p>我们在 Gemfile 中添加下面一行文字。</p>
        <pre class="代码无行号">
<code>gem 'coveralls', require: false

</code>
</pre>
        <p>另外，还要在 ./spec/spec_helper.rb 或 ./test/test_helper.rb 等各位正在使用的测试工具的 helper 文件中添加下面这段代码。</p>
        <pre class="代码无行号">
<code>require 'coveralls'
Coveralls.wear!

</code>
</pre>
        <p>使用 Rails 的读者请替换成下面这段代码进行设置。</p>
        <pre class="代码无行号">
<code>require 'coveralls'
Coveralls.wear!('rails')

</code>
</pre>
        <p>执行 <code>bundle install</code>
          命令后，记得要将所有修改过的文件提交一遍。</p>
        <h4 id="sigil_toc_id_140">
          <strong>……查看报告</strong>
        </h4>
        <p>完成上述设置后进行 push 操作，Coveralls 就会在 Travis CI 自动测试后生成报告。Coveralls 报告的 URL 为
          <code>https://coveralls.io/r/用户名/仓库名</code>
          。</p>
        <p>与 Travis CI 一样，Coveralls 也提供了让 README.md 显示相关信息的标记。在报告下部 README BADGE 栏内的图片下方可以找到 Get badge URLs，点击之后便可获得
          URL（图 8.10）。将 URL 添加至 README.md 文件后，我们就可以在 GitHub 上看到与 README BADGE 栏中同样的图片了。</p>
        <p class="图"><img src="Image00103.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.10　Coveralls 的标记</strong>
        </p>
        <h2 id="nav_point_177">
          <strong>8.4　Gemnasium</strong>
        </h2>
        <p>Gemnasium 服务可以查询 GitHub 仓库中软件正在使用的 RubyGems 或 npm（Node Package Manager，包管理器），让开发者了解自己是否正在使用最新版本进行开发 <span
            class="注释编号">17</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">17</span>
          <a href="https://gemnasium.com/">https://gemnasium.com/</a>
        </p>
        <p>最近的软件都会用到多个库。因此，当库的版本升级时，如果不及时应对，就会影响到软件的使用。</p>
        <p>比如，帮助用户轻松使用 GitHub API 的 RubyGems 中有 octokit<span class="注释编号">18</span>
          这样一个库，而我们正在开发的软件正好用到了这个库。现在由于 GitHub 对 API 做了修改，octokit 只好升级版本以做应对。这时 RubyGems.org 上一定会发布新版本的 octokit。如果我们使用了
          Gemnasium，就会第一时间接到通知。</p>
        <p class="注释内容">
          <span class="注释编号下">18</span>
          <a href="http://rubygems.org/gems/octokit">http://rubygems.org/gems/octokit</a>
        </p>
        <p>另外，在 Gemnasium 的网站上会列出我们正在使用的 RubyGems 及其与最新版本的差距。版本方面的问题可以在这里一目了然（图 8.11）。</p>
        <p class="图"><img src="Image00104.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.11　正在使用的 RubyGems 以及相应最新版的列表</strong>
        </p>
        <p>Public 仓库可以免费使用 Gemnasium，Private 仓库则需要支付一定费用。如果各位有公开的仓库，推荐试一试这项服务。</p>
        <h2 id="nav_point_178">
          <strong>8.5　Code Climate</strong>
        </h2>
        <p>Code Climate 是一款代码分析报告服务 <span class="注释编号">19</span>
          ，目前只支持 Ruby。这项服务可以分析 GitHub 仓库中的软件，查出软件中质量有问题的代码，同时给软件品质评级。这是一项收费服务，但是有 14 天的免费试用期。</p>
        <p class="注释内容">
          <span class="注释编号下">19</span>
          <a href="https://codeclimate.com/">https://codeclimate.com/</a>
        </p>
        <p>Code Climate 可以在我们的日常开发中分析代码，对容易出现 BUG 的复杂部分发出警告。如果不进行重构，与分析结果相伴的评级就会越来越低（图
          8.12）。这样一来可以督促我们在日常编写高品质代码，在评级下降时及时进行重构，让软件时常保持在一个高品质状态。</p>
        <p class="图"><img src="Image00105.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.12　解析结果评级</strong>
        </p>
        <p>Code Climate 可以帮用户筛选出那些随意敲打出的劣质代码，督促用户时常进行重构。强烈推荐日常使用 Ruby 开发的读者尝试这项服务。</p>
        <h2 id="nav_point_179">
          <strong>8.6　Jenkins</strong>
        </h2>
        <h3 id="nav_point_180">
          <strong>概要</strong>
        </h3>
        <p>Jenkins 是代表性的持续集成服务器，下面我们来讲解如何让 Jenkins 与 GitHub 集成。</p>
        <p>在这里，我们将把 GitHub 端仓库发来的 Pull Request 设置为触发器，让系统自动进行测试，并将测试结果发送至 GitHub。通过这种方法可以检验收到的 Pull Request
          会不会破坏软件原有功能。另外，如果 Pull Request 会给某些功能带来 BUG 而无法通过测试，那么这个 Pull Request 将会像图 8.13 中那样显示在 GitHub 上，防止管理员误合并。</p>
        <p class="图"><img src="Image00106.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.13　Pull Request 未通过测试时显示的内容</strong>
        </p>
        <p>通过测试的 Pull Request 将会像图 8.14 中那样以绿色显示。它表示该 Pull Request 至少成功运行了所有测试代码。</p>
        <p class="图"><img src="Image00107.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.14　Pull Request 通过测试时显示的内容</strong>
        </p>
        <p>测试成功的结果一目了然，让开发者能够放心进行合并。另外，即使没能通过测试，Jenkins 也会持续对该 Pull Request 进行测试，让开发者轻松找出发生问题的时间点。</p>
        <h3 id="nav_point_181">
          <strong>安装</strong>
        </h3>
        <p>Jenkins 的官方网站 <span class="注释编号">20</span>
          上发布了 Linux 等多种 OS 下的安装包。各位可以从官方网站的右侧选择合适的安装包进行下载。</p>
        <p class="注释内容">
          <span class="注释编号下">20</span>
          <a href="http://jenkins-ci.org/">http://jenkins-ci.org/</a>
        </p>
        <p>下载完成后要使用当前 OS 的标准安装方法进行安装。Jenkins 在众多环境中都有运行实例，各位大可选择自己熟悉的环境。当然，需要进行持续集成的目标软件最好在当前环境中可以运行。</p>
        <p>通过安装包完成安装后，Jenkins 会随 OS 一起启动，其他设置也会自动完成。只要安装正常，Jenkins 将会默认使用 8080 端口。各位可以打开浏览器访问“http://jenkins 所在服务器的 IP
          地址 :8080/”，会看到如图 8.15 的页面。</p>
        <p class="图"><img src="Image00108.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.15　Jenkins 的初始界面</strong>
        </p>
        <p>至于端口号等 JVM 的设置，不同的安装包之间有所不同。使用 deb 格式的 Debian GNU/Linux 或 Ubuntu 等 Linux 在 /etc/default/jenkins 中进行设置，而使用 rpm
          格式的 Red Hat Linux 或 CentOS 则在 /etc/sysconfig/jenkins 中进行设置。详细位置请参照官方网站的 Wiki 页 <span class="注释编号">21</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">21</span>
          <a
            href="https://wiki.jenkins-ci.org/display/JENKINS/Native+Packages">https://wiki.jenkins-ci.org/display/JENKINS/Native+Packages</a>
        </p>
        <h3 id="nav_point_182">
          <strong>创建 bot 账户</strong>
        </h3>
        <p>我们要在 GitHub 上新建一个账户，让 Jenkins 通过这个账户从仓库获取源代码以及向 GitHub 发送测试结果。今后我们将这个账户称为 bot 账户。</p>
        <p>然后要创建 bot 账户专用的公开密钥和私有密钥。通过安装包安装 Jenkins 时，OS 中会创建一个 jenkins
          用户，使用这个用户来创建密钥可以自动分配私有密钥，省去后续的麻烦。要注意的是，这个密钥的密码短语（Passphrase）一定要留空。由于 Jenkins 要通过这个密钥访问 GitHub
          的仓库，如果设置了密码短语，再想让测试全自动进行可就要费一番功夫了。</p>
        <p>接下来将新创建的无密码短语的公开密钥添加到 bot 账户中。</p>
        <p>账户的创建及设置请参考第 3 章。</p>
        <h3 id="nav_point_183">
          <strong>bot 账户的权限设置</strong>
        </h3>
        <p>我们需要给 bot 账户设置 GitHub 端持续集成对象所在仓库的访问权限。</p>
        <p>公开仓库虽然可以读取，但要将结果添加至 GitHub 就必须拥有写入权限。另外，如果对象是非公开仓库，没有读取和写入权限的话 bot 是无法访问仓库数据的。</p>
        <h4 id="sigil_toc_id_141">
          <strong>……对象为个人账户时</strong>
        </h4>
        <p>如果 GitHub 端的仓库归属于个人账户，需要从 GitHub 的仓库页面进入 Settings 页面，将 bot 账户添加到 Collaborators 中。添加在这里的账户能够获得这个仓库的写入（push
          等）和读取（clone、pull 等）的权限。</p>
        <h4 id="sigil_toc_id_142">
          <strong>……对象为 Organization 账户时</strong>
        </h4>
        <p>如果仓库归属于 Organization 账户，则需要在 GitHub 页面左上角的切换账户处选择 Organization 账户。进入 Organization 账户页面选择 Teams 标签页，打开团队一览（图
          8.16），然后选择 New Team，给 bot 账户创建一个新的团队。</p>
        <p class="图"><img src="Image00109.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.16　团队一览</strong>
        </p>
        <p>接下来输入团队相关的设置（图 8.17）。在 Team Name 处输入团队名。这里我们将团队名定为 bot。“What permission level should this team
          have?”处可以选择这个团队拥有的权限。这里要选择 Write Access。最后点击 Create team 即可创建团队。</p>
        <p class="图"><img src="Image00110.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.17　创建团队与权限设置</strong>
        </p>
        <p>在接下来的页面中要设置 bot 团队的成员与仓库（图 8.18）。团队所属成员的账户在页面左侧添加。这里我们的 bot 账户名为
          hirocaster-bot。页面右侧可以添加与该团队关联的仓库。我们要进行持续集成的对象在 github-book/ghprb 中，于是我们将它添加进去。</p>
        <p class="图"><img src="Image00111.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.18　团队成员与仓库的设置</strong>
        </p>
        <p>团队名下方显示的团队说明可以通过点击 Edit 来修改。在这里填写简单的团队说明可以在团队增多后方便整理，所以建议大家多花点时间写上概要。</p>
        <p>全部输入完成后点击右上角的 Teams，查看已创建的团队。</p>
        <h4 id="sigil_toc_id_143">
          <strong>……检查设置</strong>
        </h4>
        <p>至此，我们完成了 bot 账户对持续集成对象仓库的权限设置。现在退出 GitHub 重新登入 bot 账户，确认是否能看到该仓库。</p>
        <p>今后如果增加了新的持续集成对象仓库，只需给本次创建的团队添加仓库，就可以让 bot 账户获得访问仓库的权利。</p>
        <h3 id="nav_point_184">
          <strong>给 Jenkins 设置 SSH 密钥</strong>
        </h3>
        <p>由于 Jenkins 要使用 bot 账户的私有密钥访问仓库，所以必须设置一个私有密钥。</p>
        <h4 id="sigil_toc_id_144">
          <strong>……初次使用 Jenkins 时</strong>
        </h4>
        <p>通过安装包安装 Jenkins 后，OS 中会自动生成一个 jenkins 用户。如果在这个 jenkins 用户下生成新的密钥，那么私有密钥就已经自动配置完毕，不需要多做更改。</p>
        <p>如果新密钥不是在 jenkins 用户下生成，则需要在 jenkins 用户的个人文件夹起始目录下创建 .ssh 目录，在 .ssh 目录下配置私有密钥（id_rsa）。比如在 Ubuntu 等 Linux
          的派生操作系统下，私有密钥的路径就是 /var/lib/jenkins/.ssh/id_rsa。配置私有密钥之后，jenkins 用户就可以自动使用这个私有密钥通过 SSH 进行访问。然后只要将 Jenkins 的
          job 设置成通过 SSH 访问 GitHub 仓库，Jenkins 就可以访问仓库了。</p>
        <h4 id="sigil_toc_id_145">
          <strong>……已经在使用 Jenkins 时</strong>
        </h4>
        <p>如果已经使用 Jenkins 为其他项目进行持续集成并且占用了 id_rsa 文件，就需要花一些功夫了。我们要在 ~/.ssh/config 中写入 SSH 客户端的相关设置，为 SSH
          访问特定主机时，设置要访问的实际主机名以及对应的私有密钥。</p>
        <p>在 jenkins 用户的 ~/.ssh/config 中添加下面的代码。</p>
        <pre class="代码无行号">
<code>Host ghprb.github-book
  Hostname github.com
  IdentityFile ~/.ssh/bot_id_rsa ←指定访问GitHub时的私有密钥
  StrictHostKeyChecking no
        　
Host *
  IdentityFile ~/.ssh/id_rsa ←指定通常情况下使用的私有密钥

</code>
</pre>
        <p>在 ~/.ssh/bot_id_rsa 中配置我们新创建的私有密钥。由于是私有密钥，我们将权限设置为 400。</p>
        <p>通常情况下我们是通过 <code>git@github.com:github-book/ghrpb.git</code>
          访问 GitHub 仓库的。但是经过本次设置后，在通过 Jenkins 访问仓库时，请将上面主机名的部分替换为本次设置的 HOST 名，比如
          <code>git@github.com:github-book/ghrpb.git</code>
          就需要修改成 <code>git@ghprb.github-book:github-book/ghrpb.git</code>
          。</p>
        <p>设置完成后，Jenkins 在通过 SSH 访问不同主机时就可以使用不同的私有密钥了。</p>
        <p>现在我们的 jenkins 用户已经可以使用 bot 账户的私有密钥访问 GitHub 仓库了。我们不妨先在 jenkins 用户下尝试 clone 等操作，确认能否正常执行，以便在后面 job
          设置出问题时能快速找到原因。</p>
        <h4 id="sigil_toc_id_146">
          <strong>GitHub pull request builder plugin 的安装</strong>
        </h4>
        <p>使用 Jenkins 对 Pull Request 进行自动测试时，需要用到 GitHub pull request builder plugin<span class="注释编号">22</span>
          插件 <span class="注释编号">23</span>
          。这个插件可以在 Jenkins 内部构建出 Pull Request 合并之后的状态并执行自动测试。由于其结果会自动发送到 GitHub，所以能够让我们避免“Pull Request
          合并后出现了某些问题导致测试未通过”的情况。如此一来，Pull Request 的合并就变得更加安全了。</p>
        <p class="注释内容">
          <span class="注释编号下">22</span>
          <a
            href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin">https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">23</span>
          本书使用的是 1.9 版本。
        </p>
        <p>现在我们将这个插件安装到 Jenkins 上。</p>
        <p>访问 Jenkins 的主界面，依次选择“系统管理”→“管理插件”，然后选择“可选插件”标签页。从列表中找出 GitHub pull request builder plugin，勾选安装复选框，点击直接安装（图
          8.19）。随后相应插件就会安装到系统中（图 8.20）。</p>
        <p class="图"><img src="Image00112.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.19　选择 GitHub pull request builder plugin</strong>
        </p>
        <p class="图"><img src="Image00113.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.20　相关插件已安装完毕</strong>
        </p>
        <p>接下来我们继续进行 Jenkins 的设置。首先打开“系统管理”→“系统设置”页面。</p>
        <h3 id="nav_point_185">
          <strong>Git plugin 的设置</strong>
        </h3>
        <p>点击“配置”下拉菜单中的 Git plugin，移动至 Git plugin 项目（图 8.21）。</p>
        <p class="图"><img src="Image00114.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.21　Git plugin</strong>
        </p>
        <p>现在我们来设置 Jenkins 内部使用的 Git。在 Global Config uesr.name Value 中输入姓名，在 Global Config user.email Value
          中输入邮箱地址。要注意，这两项都是必填项。</p>
        <h3 id="nav_point_186">
          <strong>Github Pull Requests Builder 的设置</strong>
        </h3>
        <p>接下来我们移动至 Github Pull Requests Builder 项目，然后点开项目下部的“高级”。</p>
        <h4 id="sigil_toc_id_147">
          <strong>……Github server api URL</strong>
        </h4>
        <p>如果各位使用的是普通的 GitHub，那么这项不需要更改，如果使用的是 GitHub Enterprise，则需要配合环境进行设置。</p>
        <h4 id="sigil_toc_id_148">
          <strong>……Access Token</strong>
        </h4>
        <p>Jenkins 与 GitHub 之间的互动其实就是通过 bot 账户的 Access Token 与 GitHub 的 API 进行信息交互，因此需要获取 bot 账户的 Access Token。</p>
        <p>填写下方的 Username 与 Password 后点击 Create access token，Jenkins 就会自动通过 bot 账户的 Username 和 Password 获取 Access Token。
        </p>
        <p>成功获取后，该部分附近会显示一长串随机文字列。只要将这个文字列复制到上数第二项 Access Token 栏中即可。</p>
        <p class="图"><img src="Image00115.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 8.22　Access Token 的设置</strong>
        </p>
        <h4 id="sigil_toc_id_149">
          <strong>……Admin list</strong>
        </h4>
        <p>GitHub pull request builder plugin 可以让用户通过在 GitHub 的 Pull Request 中添加特定评论的方式，给 Jenkins 发送“执行任务”等命令。我们需要在这里添加
          GitHub 的用户名，将上述权限赋予该用户。新建任务时，相关权限将会以这里的设置为默认值。当然，在每个任务中也可以单独进行设置。</p>
        <p>以上全部输入完毕后点击保存。</p>
        <h3 id="nav_point_187">
          <strong>job 的创建与设置</strong>
        </h3>
        <p>Jenkins 的任务用来执行自动测试，现在我们在 Jenkins 中实际创建一个。点击“创建一个新任务”，给任务起一个合适的名称，然后选择“构建一个自由风格的软件项目”。</p>
        <p>下面是任务的设置，我们只讲解必须进行的设置，其他设置请各位根据自己的需要进行判断。</p>
        <h4 id="sigil_toc_id_150">
          <strong>……GitHub project</strong>
        </h4>
        <p>在 GitHub project 中输入 GitHub 仓库的 URL，例如 <code>https://github.com/github-book/ghprb/</code>
          等。</p>
        <h4 id="sigil_toc_id_151">
          <strong>……源码管理</strong>
        </h4>
        <p>在“源码管理”中选择 Git（图 8.23）。Repository URL 要填 SSH 协议的 URL，例如 <code>git@github.com:github-book/ghprb.git</code>
          。如果在前面讲到的 ~/.ssh/config 中进行了设置，要注意替换主机名。</p>
        <p class="图"><img src="Image00116.jpg" alt="" width="85%" style="width: 85%" />
        </p>
        <p class="p-img-title">
          <strong>图 8.23　源码管理系统设置</strong>
        </p>
        <p>接下来选择 Repositories 的“高级”。在 Refspec 中输入以下内容。</p>
        <pre class="代码无行号">
<code>+refs/pull/*:refs/remotes/origin/pr/*

</code>
</pre>
        <p>在 Branches to build 的 Branch Specifier(blank for default) 中输入以下内容。</p>
        <pre class="代码无行号">
<code>${sha1}

</code>
</pre>
        <h4 id="sigil_toc_id_152">
          <strong>……构建触发器</strong>
        </h4>
        <p>在“构建触发器”中我们需要设置让任务开始执行的触发器（图 8.24）。先勾选 Github Pull Requests Builder，然后点击“高级”。</p>
        <p class="图"><img src="Image00117.jpg" alt="" width="90%" style="width: 90%" />
        </p>
        <p class="p-img-title">
          <strong>图 8.24　job 中 Github Pull Requests Builder 的设置</strong>
        </p>
        <p>在 Admin list 中输入管理者的用户名。</p>
        <p>Crontab line 需要按照 Cron 的格式进行描述。Jenkins 会按照这里设置的时间检查 Pull Request。默认设置为每 5 分钟检查一次。</p>
        <p>在 White list 中填写有可能向自己发送 Pull Request 的 GitHub 用户名。当接收到 Pull Request 时，如果发送方的用户名在 White list 或 Admin list
          之中，Jenkins 就会自动执行任务。</p>
        <p>如果在“List of organisations. Their members will be whitelisted”中输入 Organization 账户，那么隶属该账户的所有 GitHub 用户都会获得与
          White list 相同的权限。</p>
        <h4 id="sigil_toc_id_153">
          <strong>……构建</strong>
        </h4>
        <p>“构建”用来设置执行自动测试等作业的流程。这里请各位根据自己正在开发的软件进行设置。</p>
        <p>以上我们完成了最低限度的设置。现在只要接收到 Pull Request，任务就会自动执行。但是 Pull Request 的发送者必须在 Admin list 或 White list 之中。</p>
        <p>其他开发者送来 Pull Request 时，需要由 Admin list 中的用户填写评论进行控制，比如将该开发者加入 White list，或者直接允许测试执行等。关于这方面我们会在后面详细讲解。</p>
        <h3 id="nav_point_188">
          <strong>通知结果</strong>
        </h3>
        <p>自动测试的结果会由 GitHub pull request builder plugin 发送到 GitHub。这时要用到的 API 名为 Commit Status API<span
            class="注释编号">24</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">24</span>
          <a href="https://github.com/blog/1227-commit-status-api">https://github.com/blog/1227-commit-status-api</a>
        </p>
        <p>接收到 Pull Request 时，持续集成服务器会进行处理然后发送信息，随后会根据最新提交显示如图 8.25 的状态。</p>
        <p class="图"><img src="Image00118.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.25　显示 Pull Request 的状态</strong>
        </p>
        <p>这一状态附带名为 Details 的链接，指向我们刚刚设置的 Jenkins。点击这个链接可以查看相关的详细内容。</p>
        <h4 id="sigil_toc_id_154">
          <strong>……测试执行中的状态</strong>
        </h4>
        <p>接收到 Pull Request 之后，如果自动测试仍在执行中无法确定状态，则会显示为图 8.26 的样子。这时只要稍等一会，等 GitHub 接收到测试结果，状态就会被更新。</p>
        <p class="图"><img src="Image00119.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.26　测试执行中的状态</strong>
        </p>
        <h4 id="sigil_toc_id_155">
          <strong>……Failed</strong>
        </h4>
        <p>如果有某项测试没有通过，则会显示图 8.27 的状态。</p>
        <p class="图"><img src="Image00120.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.27　测试未通过时的状态</strong>
        </p>
        <p>这时可以点击 Details 链接查看详细内容，找出没能通过测试的问题所在。要注意，这个状态下千万不能合并 Pull Request。</p>
        <h4 id="sigil_toc_id_156">
          <strong>……All is well</strong>
        </h4>
        <p>如果测试全部正常通过，会如图 8.25 中那样以绿色显示。之后只要代码审查等工作没有发现问题，就可以合并了。</p>
        <h4 id="sigil_toc_id_157">
          <strong>……commit status</strong>
        </h4>
        <p>GitHub pull request builder plugin 虽然是根据最新的提交来执行任务，但是也会记录过去的提交状态。如果测试未通过，该提交会像图 8.28 里那样被标上“×”。</p>
        <p class="图"><img src="Image00121.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.28　测试未通过时的标记</strong>
        </p>
        <p>将其修正再 push 后，会如图 8.29 中那样标上绿色对勾。</p>
        <p class="图"><img src="Image00122.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.29　测试通过时的标记</strong>
        </p>
        <p>根据这些结果记录，可以直观地分辨出哪些提交引起了测试结果的变化，帮助开发者迅速地辨明问题所在。</p>
        <h3 id="nav_point_189">
          <strong>通过评论进行控制</strong>
        </h3>
        <p>在 GitHub 的 Pull Request 中填写特定评论可以控制 GitHub pull request builder plugin。</p>
        <h4 id="sigil_toc_id_158">
          <strong>……执行任务</strong>
        </h4>
        <p>如果是 Admin list 和 White list 名单之外的用户发来 Pull Request，bot 账户会询问“Can one of the admins verify this
          patch?”。这种情况下任务不会自动执行。</p>
        <p>Admin list 名单中的用户可以通过发送“ok to test”的评论让任务开始执行。如果发送评论的用户不在 Admin list 当中则会被 bot 账户忽略。如果发送 Pull Request 的用户在
          White list 之中，则任务会自动开始执行。</p>
        <h4 id="sigil_toc_id_159">
          <strong>……添加至 White list</strong>
        </h4>
        <p>如果想将发送 Pull Request 的用户添加至 White list，就用 Admin list 名单中的用户发送“add to whitelist”的评论。今后这个用户发来 Pull Request
          的话，任务都会被自动执行（图 8.30）。</p>
        <p class="图"><img src="Image00123.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 8.30　发送“add to whitelist”评论的示例</strong>
        </p>
        <h4 id="sigil_toc_id_160">
          <strong>……重新执行任务</strong>
        </h4>
        <p>如果遇到某些情况需要重新执行任务，只要 Admin list 或 White list 名单中的用户发送“retest this please”的评论即可。</p>
        <h4 id="sigil_toc_id_161">
          <strong>……变更指定评论</strong>
        </h4>
        <p>指定评论的内容可以在“系统管理”→“系统设置”→“Github Pull Requests Builder”→“高级”中进行更改。</p>
        <h2 id="nav_point_190">
          <strong>8.7　小结</strong>
        </h2>
        <p>通过使用 Jenkins 和 GitHub pull request builder plugin，我们可以更安全地合并 GitHub 的 Pull Request。第 9
          章中我们也会接触到自动测试和持续集成的相关内容。在现代的软件开发中持续集成已经不可或缺，甚至逐渐成为开发中的常识。在开源世界中也是同样。</p>
        <p>在了解一遍过程之后，持续集成的安装会变得很简单。但是在认证和权限设置方面仍存在很多难以处理的东西，往往让人们花费大量时间。因此本书详细讲解了如何让其与 GitHub 集成。各位不妨参考本书尝试一下持续集成的应用。
        </p>
        <blockquote>
          <p>
            <strong>专栏：用 Coderwall 生成 GitHub 上的个人信息</strong>
          </p>
          <p>Coderwall <span class="注释编号">25</span>
            是由社区众筹的方式开发、运营的一款服务，它可以根据 GitHub 的仓库信息等为开发者免费生成个人信息，同时根据在 GitHub 上的业绩与成就给开发者颁发勋章（图 a）。</p>
          <p class="图"><img src="Image00124.jpg" alt="" width="90%" style="width: 90%" />
          </p>
          <p class="p-img-title">
            <strong>图 a　Coderwall 的勋章</strong>
          </p>
          <p>这是一张可以证明开发者使用何种语言参与了多少个项目的证书。根据其所获得的勋章就可以判断这个人的特点。各位如果有感兴趣的人，不妨查看一下他们的个人信息。</p>
          <p>这些勋章可以嵌入到博客等网站，各位可以试着把它们展示在个人信息栏里<span class="注释编号">26</span>
            。</p>
          <p>Coderwall 中的 Teams <span class="注释编号">27</span>
            是展示各团队的地方，在这里，你既可以上传自己的团队资料，展示自己的团队成绩和文化，以此来吸引志同道合的同伴，也可以查看其他团队有哪些程序员，在 GitHub 上开发什么代码以及他们的团队文化。</p>
          <p>有意跳槽的人可以在这里查看是否有心仪的团队。如果您的公司还没有参与进来，也不妨借这个机会展示一下，将这里作为一种交流的平台。</p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">25</span>
          <a href="https://coderwall.com/">https://coderwall.com/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">26</span>
          <a href="https://coderwall.com/api#blogbadge">https://coderwall.com/api#blogbadge</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">27</span>
          <a href="https://coderwall.com/leaderboard">https://coderwall.com/leaderboard</a>
        </p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_191">
          <strong>第 9 章　使用GitHub的开发流程</strong>
        </h1>
        <p>在开发流程中使用 GitHub，可以将开发团队的能力发挥到最大限度。下面我们就为各位介绍这类开发流程。</p>
        <p>本章中讲解的“开发流程”，是指使用了 Git 与 GitHub 的团队开发所涉及的规则及步骤。接下来的部分我们将会讲解 2
          种开发流程，每个流程都有各自不同的特征。在实际开发中究竟要采用哪一种，需要根据现场团队的情况来决定。</p>
        <p>对于不熟悉 Git 和 GitHub 的团队，推荐以本书为参考来制定开发规则及步骤的草案。</p>
        <h2 id="nav_point_192">
          <strong>9.1　团队使用 GitHub 时的注意事项</strong>
        </h2>
        <p>在详细讲解使用 Git 与 GitHub 的开发流程之前，我们先来看一看由软件开发者们组成的团队要想最大限度地发挥出他们的能力需要具备哪些前提条件。</p>
        <h3 id="nav_point_193">
          <strong>一切从简</strong>
        </h3>
        <p>面向企业发售的开发者工具或协作工具往往拥有十分丰富的功能。某些企业为使用这些丰富功能，会专门为其制定软件开发规则。然而不妨反思一下，我们所处的开发现场真的需要这么多功能和规则吗？</p>
        <p>GitHub 的各项功能都非常简单，就是因为在实际的软件开发中，往往用不到那些复杂度极高的功能。</p>
        <h4 id="sigil_toc_id_162">
          <strong>……项目管理工具与 GitHub 的区别</strong>
        </h4>
        <p>比如图 9.1 所示的著名开源项目管理工具 Redmine 的新建问题页，从繁多的可输入项目中我们就可以看出其功能的丰富程度。而且 Redmine 还有众多插件，可以为其进一步添加功能。然而 GitHub 的 New
          Issue 页却如图 9.2 所示，非常简单。</p>
        <p class="图"><img src="Image00125.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.1　Redmine 的新建问题页</strong>
        </p>
        <p class="图"><img src="Image00126.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.2　GitHub 的 New Issue 页</strong>
        </p>
        <p>为什么会有如此差距呢？</p>
        <h4 id="sigil_toc_id_163">
          <strong>……项目管理工具与 GitHub 相异的原因</strong>
        </h4>
        <p>Redmine 等项目管理工具是以管理项目为目的的，势必要考虑管理人员会输入哪些信息，以及需要提醒管理人员输入哪些信息，所以会拥有众多可输入项目。</p>
        <p>而 GitHub 是一款为软件开发者提供支持的工具，与项目管理工具相比，它更注重辅助开发者高速开发高品质软件。要知道，往往事物越是简单，人们实施起来就越快。</p>
        <p>在这里，笔者要向准备使用 GitHub 的各位开发者提个建议。GitHub 本身相较于各位正在使用的项目管理工具确实会有功能方面的不足。但是，先不要急着用其他工具来强行弥补，不妨试着大胆放弃这些功能。</p>
        <p>GitHub 的这些简单功能，完全能够应对软件开发中的需要。想让团队最大限度发挥实力，建议剔除复杂规则，只以最简单的规则进行开发。</p>
        <h3 id="nav_point_194">
          <strong>不 Fork 仓库的方法</strong>
        </h3>
        <p>已经将 GitHub 利用到开源软件开发中的读者们想必会以下面的流程进行 Pull Request。</p>
        <p>❶ 在 GitHub 上进行 Fork</p>
        <p>❷ 将❶的仓库 clone 至本地开发环境</p>
        <p>❸ 在本地环境中创建特性分支</p>
        <p>❹ 对特性分支进行代码修改并进行提交</p>
        <p>❺ 将特性分支 push 到❶的仓库中</p>
        <p>❻ 在 GitHub 上对 Fork 来源仓库发送 Pull Request</p>
        <p>在无法给不特定的多数人赋予提交权限的公开软件开发中，这种流程能够防止仓库收到计划之外的提交。</p>
        <p>然而在公司企业的开发中，开发者每天都要见面，要经常互相发送 Pull Request，这种流程就显得有些繁琐了。因此，下面我们要介绍一个不需要 Fork
          仓库的工作流程。这种方法可以让每一名开发者都掌握着一个本地仓库和一个远程仓库，使整个开发流程变得简单（图 9.3）。</p>
        <p class="图"><img src="Image00127.jpg" alt="" width="65%" style="width: 65%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.3　不进行 Fork 的开发流程</strong>
        </p>
        <h2 id="nav_point_195">
          <strong>9.2　GitHub Flow——以部署为中心的开发模式</strong>
        </h2>
        <p>下面我们为各位讲解 GitHub 公司正在实践的一个十分简单的开发流程（图 9.4）<span class="注释编号">1</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a
            href="http://zachholman.com/talk/how-github-uses-github-to-build-github/">http://zachholman.com/talk/how-github-uses-github-to-build-github/</a>
        </p>
        <p class="图"><img src="Image00128.jpg" alt="" width="50%" style="width: 50%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.4　GitHub Flow 的概要</strong>
        </p>
        <p>这是一个以部署 <span class="注释编号">2</span>
          为中心的开发流程。在实际开发中往往 1 天之内会实施几十次部署，而支撑这一切的，就是足够简单的开发流程以及完全的自动化。简单的开发流程能够让问题应对变得更加灵活。正在使用 GitHub 的各位，请务必尝试这一开发流程。
        </p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          即在正式环境中配置源代码并试运行。
        </p>
        <p>正因为这一开发流程十分简单，所以无论大小团队都可以取得不错的效果。在 GitHub 公司，大致会让 15 至 20 人组成团队，利用这一流程进行同一项目的开发 <span class="注释编号">3</span>
          。以笔者的经验，由 20 人左右的团队使用这个流程来共同开发一个项目，基本不会出现什么大问题。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          <a
            href="http://scottchacon.com/2011/08/31/github-flow.html">http://scottchacon.com/2011/08/31/github-flow.html</a>
        </p>
        <h2 id="nav_point_196">
          <strong>9.3　GitHub Flow 的流程</strong>
        </h2>
        <p>整个开发流程大致如下。</p>
        <p>❶ 令 master 分支时常保持可以部署的状态</p>
        <p>❷ 进行新的作业时要从 master 分支创建新分支，新分支名称要具有描述性</p>
        <p>❸ 在❷新建的本地仓库分支中进行提交</p>
        <p>❹ 在 GitHub 端仓库创建同名分支，定期 push</p>
        <p>❺ 需要帮助或反馈时创建 Pull Request，以 Pull Request 进行交流</p>
        <p>❻ 让其他开发者进行审查，确认作业完成后与 master 分支合并</p>
        <p>❼ 与 master 分支合并后立刻部署</p>
        <p>
          以上便是这一流程的全部内容。由于流程中基本只需为特定作业创建特定分支，从开始作业到进行部署之间的过程十分简单，可以降低开发者学习开发流程的成本。而且正由于其简单，所以大量开发者可以迅速将其利用到开发之中，并且可以借助它来灵活处理一些细微的代码变更。
        </p>
        <p>下面我们按顺序一步步进行讲解。</p>
        <h3 id="nav_point_197">
          <strong>随时部署，没有发布的概念</strong>
        </h3>
        <p>这个流程必须遵守“令 master 分支随时保持可以部署的状态”这一规则。每隔几小时进行一次部署，可以有效防止同时出现多个严重 BUG。</p>
        <p>虽然有时仍会有一些小 BUG 出现，但只要将相应的提交 revert 或者提交修正过的代码即可轻松应对。这一流程要以小时甚至分钟为单位持续地进行部署，所以不存在发布的概念。因此，不会出现让 HEAD
          返回去指向很久之前的提交 <span class="注释编号">4</span>
          ，借以取消整个作业内容的情况。</p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          相当于 Git 的 git reset 命令。
        </p>
        <p>由于 master 分支时常保持着可以部署的状态，所以开发者可以随时创建新的分支。</p>
        <p>要注意，没有进行过测试或者测试未通过的代码绝不可以合并到 master 分支。因此势必要用到持续集成等手段。</p>
        <h3 id="nav_point_198">
          <strong>进行新的作业时要从 master 分支创建新分支</strong>
        </h3>
        <p>进行新的作业时要从 master 分支创建新分支，无论是添加新功能还是修复 BUG 都是如此。此外，新分支的名称要具有描述性。</p>
        <p>所谓具有描述性的名称，是指该名称能直观正确地表达这个分支的特性，比如以下几种。</p>
        <ul>
          <li>
            <p>user-content-cache-key</p>
          </li>
          <li>
            <p>submodules-init-task</p>
          </li>
          <li>
            <p>redis2-transition</p>
          </li>
        </ul>
        <p>其他开发者可以通过这些名字清楚地了解到该分支正在进行什么工作。</p>
        <p>采用这一方式，开发者在查看远程仓库的分支列表时，能够对当前团队正在实施的任务一目了然。另外，由于分支名明确描述了工作内容，即便开发者需要先去做其他工作，回来时也能很快想起该分支的工作目标。</p>
        <p>查看 GitHub 的分支列表页面 <span class="注释编号">5</span>
          还可以轻松掌握各分支与 master 分支的差别。</p>
        <p class="注释内容">
          <span class="注释编号下">5</span>
          <a
            href="https://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D/branches">https://github.com/用户名/仓库名/branches</a>
        </p>
        <h3 id="nav_point_199">
          <strong>在新创建的分支中进行提交</strong>
        </h3>
        <p>在前面的步骤中，开发者为了进行新的更改而创建了新分支，并且明确了在这个分支中应该做哪些工作。接下来就可以在这个分支中修改代码，并进行提交了。修改代码时要注意，绝对不能进行与该分支工作内容无关的修改。</p>
        <p>在这一阶段，开发者要在提交的粒度上多花心思。有意识地减小提交的规模，一方面便于清楚地表达目的，另一方面有助于其他开发者对 Pull Request 进行审查。</p>
        <p>比如在添加一个方法时，确认添加位置以及类之后，开发者往往还需要进行下面的操作。</p>
        <ul>
          <li>
            <p>修正附近代码的缩进问题</p>
          </li>
          <li>
            <p>发现变量单词拼写错误并进行修正</p>
          </li>
          <li>
            <p>添加本次作业中需要添加的方法</p>
          </li>
        </ul>
        <p>如果将上述工作在一次提交中完成，那么一个差别将包含 3 种含义，这种提交的粒度就有些不妥。如果将 3 个工作分为 3 次提交，那么每个差别就有了更清晰的含义。</p>
        <p>在分支中修改代码与发送提交时只需注意以上几点，其余方面皆可按照往常的方式进行。</p>
        <h3 id="nav_point_200">
          <strong>定期 push</strong>
        </h3>
        <p>在这一开发流程中，由于除了 master 分支之外都是作业中的分支，所以 push 作业分支时不需要有太多顾虑。在开发过程中，建议开发者定期将本地仓库中创建的分支以同名形式 push 到 GitHub 端的远程仓库。
        </p>
        <p>这样一来不仅可以备份代码，还会定期给开发者团队创造交流的机会。其他开发者在做什么工作，是否需要帮助等，团队成员可以通过 GitHub 的分支列表页面一目了然。</p>
        <p>在开发过程中，最好让其他开发者能够看到自己编写的代码，同时养成积极查看其他人代码的习惯。通过代码进行交流是开发者的特权，我们没有理由不去利用。</p>
        <h3 id="nav_point_201">
          <strong>使用 Pull Request</strong>
        </h3>
        <p>Pull Request 不一定非要在与 master 分支合并时才使用。既然是团队开发，完全可以尽早创建 Pull Request 让其他开发者进行审查，一边听取反馈一边编写代码，没必要等到与 master
          分支合并时再进行。</p>
        <p>Pull Request 具有显示差别以及对单行代码插入评论的功能，开发者可以利用这些进行交流。另外，如果希望得到特定开发者的反馈或建议，可以在评论中加入“@ 用户名”，给该用户发送
          Notifications。对方注意到之后，照例都会以某种形式进行反馈。</p>
        <h3 id="nav_point_202">
          <strong>务必让其他开发者进行审查</strong>
        </h3>
        <p>
          一个分支的作业结束后，需要注明作业已完成，让其他开发者进行审查。找其他开发者看一看自己编写的代码，可以有效防止想当然的错误或者低级失误。审查时要选择没有参与编写的人，被指出有问题时，要积极进行修改。当然，这一切的大前提是该部分代码已经通过所有自动测试。
        </p>
        <p>审查之后如果认为可以与 master 分支合并，则需要明确地告知对方。按照 GitHub 的文化，这里会用到“:+1:”或“:shipit:”等表情（图 9.5）。偶尔也会见到 LGTM 的字样，这是 Looks
          good to me 的简写。</p>
        <p class="图"><img src="Image00129.jpg" alt="" width="95%" style="width: 95%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.5　通过表情表达意见</strong>
        </p>
        <p>征得多个人同意后，便可找个适当的时机让其他开发者将该分支与 master 分支进行合并。</p>
        <h3 id="nav_point_203">
          <strong>合并后立刻部署</strong>
        </h3>
        <p>代码合并至 master 分支并且通过所有自动测试之后，需要立刻进行部署。在部署之后，需要确认刚刚合并的代码是否存在问题。</p>
        <h2 id="nav_point_204">
          <strong>9.4　实践 GitHub Flow 的前提条件</strong>
        </h2>
        <p>至此，相信各位已经对这一开发流程有了大体印象。接下来我们需要考虑实践这一开发流程所需的前提条件。</p>
        <h3 id="nav_point_205">
          <strong>部署作业完全自动化</strong>
        </h3>
        <p>首先，部署的相关作业必须实现自动化。这一开发流程在一天当中需要多次部署，以旧有开发模式按部署文档进行部署作业会浪费相当多的时间，同时还很可能发生操作失误，作为一名程序员，不应该每天为这些工作花费精力。</p>
        <h4 id="sigil_toc_id_164">
          <strong>……使用部署工具</strong>
        </h4>
        <p>于是，我们要使用 Capistrano 等部署工具，让部署时所需的一系列流程自动化。一旦实现自动化，部署工作就能够简化成一条指令，同时大幅减少粗心大意导致的人为失误，让所有参与开发的人都能够放心地实施部署工作。</p>
        <p>另外，这类部署工具都有回滚功能。不小心部署了有问题的代码时，只需一条指令就可以将版本回滚至部署之前。为此，最好让所有参与开发的人都能进行回滚操作。</p>
        <p>显而易见，只需将以往用来编写操作顺序手册和进行维护的时间拿出一点来编写部署工具的代码，就可以换来众多好处。</p>
        <h4 id="sigil_toc_id_165">
          <strong>……通过 Web 界面进行部署的工具</strong>
        </h4>
        <p>Capistrano 等部署工具需要使用命令行执行操作，开发者以外的人很难实施部署。而 Webistrano 和 Strano 等工具则提供了通过 Web
          执行部署指令的界面，能够帮助团队成员解决这个问题。一个团队除了开发者以外，往往还包含美工或 HTML 编辑等人，在开发过程中，创建一个让团队所有相关人员都能放心部署的环境至关重要。表 9.1
          中列出了几种具有代表性的部署工具。</p>
        <p>
          <strong>表 9.1　具有代表性的部署工具</strong>
        </p>
        <table class="table table-bordered table-striped table-condensed" width="90%" border="1">
          <tbody>
            <tr>
              <th>名称</th>
              <th>URL</th>
              <th>备注</th>
            </tr>
            <tr>
              <td>Capistrano</td>
              <td></td>
              <td>Ruby 开发的代表性部署工具</td>
            </tr>
            <tr>
              <td>Mina</td>
              <td></td>
              <td>Ruby 开发的部署工具</td>
            </tr>
            <tr>
              <td>Fabric</td>
              <td></td>
              <td>Python 开发的部署工具</td>
            </tr>
            <tr>
              <td>Cinnamon</td>
              <td></td>
              <td>Perl 开发的部署工具</td>
            </tr>
            <tr>
              <td>Webistrano<sup>※</sup>
              </td>
              <td></td>
              <td>可通过 Web 执行 Capistrano 的工具</td>
            </tr>
            <tr>
              <td>Strano</td>
              <td></td>
              <td>可通过 Web 执行 Capistrano 的工具，与 Webistrano 采用的中间件不同</td>
            </tr>
          </tbody>
        </table>
        <p>
          <sup>※ 由于开发方已经停止开发，这里仅介绍 Fork 版。</sup>
        </p>
        <h4 id="sigil_toc_id_166">
          <strong>……导入开发时的注意事项</strong>
        </h4>
        <p>随着团队人数增多以及成熟度提高，开发速度会越来越快。这时往往一个部署尚未完成，另一名开发者就已经处理完下一个 Pull
          Request，开始实施下一个部署了。在这种情况下，一旦正式环境中出现问题，很难分辨是哪个部署造成的影响。为了应对这种情况，建议在部署实施过程中通过工具上锁，或者在实施部署时通知整个团队等，通过严格贯彻这类规则来消除隐患。
        </p>
        <h3 id="nav_point_206">
          <strong>重视测试</strong>
        </h3>
        <h4 id="sigil_toc_id_167">
          <strong>……让测试自动化</strong>
        </h4>
        <p>如果每次部署到正式环境前都需要在测试环境中手动进行测试，那这一开发流程也就无从谈起了。所以必须让测试自动化，令其自动检测是否有代码被意外破坏，以及是否出现 BUG。</p>
        <h4 id="sigil_toc_id_168">
          <strong>……编写测试代码，通过全部测试</strong>
        </h4>
        <p>每一名开发者都必须编写测试代码。成品代码的 Pull Request 中如果不包含测试代码，是不可以合并至 master 分支中的。只有包含测试代码并且通过了所有测试的成品代码才可以被合并至 master 分支。
        </p>
        <p>开发者确认代码在本地环境中通过了所有测试后，将其 push 到远程仓库。随后 Jenkins 或 Travis CI 等 CI 工具会自动对其进行测试，测试结果由 CI
          工具第一时间通知开发者。经过这一流程，系统能够自动检测出软件是否遭到破坏。我们在 8.6 节中已经详细讲解过如何构建与 GitHub 集成的 Jenkins 环境，各位可加以参考。</p>
        <h4 id="sigil_toc_id_169">
          <strong>……维护测试代码</strong>
        </h4>
        <p>要注意的是，测试代码必须时常进行维护，以保证能够在开发流程可承受的速度范围内完成所有测试。顺便一提，GitHub 公司可以在 200 秒内实施 14 000 个自动测试 <span
            class="注释编号">6</span>
          。这么短的时间内完成如此多的测试项目，效率实在惊人。</p>
        <hr />
        <p class="注释内容">
          <span class="注释编号下">6</span>
          <a href="http://zachholman.com/posts/how-github-works/">http://zachholman.com/posts/how-github-works/</a>
        </p>
        <p>这一工作流程以部署为中心，通过简单的功能和规则，持续且高速安全地进行部署。至此相信各位都已经有了一定程度的理解。</p>
        <p>不论是添加新功能还是修正小 BUG，全都通过同一流程进行。它的高效正源于它的简单。从结果上看，简单的构造让这一开发流程兼具了高速度与灵活性。</p>
        <p>各位不妨也让自己的团队试着采用这一开发流程。</p>
        <h2 id="nav_point_207">
          <strong>9.5　模拟体验 GitHub Flow</strong>
        </h2>
        <p>通过前面的讲解，各位对开发者实施 GitHub Flow 的步骤应该有了一个具体的了解。现在就让我们一起来结合 GitHub 上的交流体验这一流程。</p>
        <p>现在假设各位是负责给某软件开发功能的开发者，并且所在团队正在实践 GitHub Flow。账户名为 ituring，仓库名为 fizzbuzz。我们即将讲解的软件已经公开了代码，请各位将其仓库 Fork 至自己的
          GitHub 账户下，与我们一起动手尝试。</p>
        <p>下面我们将“Fizzbuzz 问题”<span class="注释编号">7</span>
          作为编程的题材。</p>
        <p class="注释内容">
          <span class="注释编号下">7</span>
          <a href="http://en.wikipedia.org/wiki/Fizz_buzz">http://en.wikipedia.org/wiki/Fizz_buzz</a>
        </p>
        <h3 id="nav_point_208">
          <strong>Fizzbuzz 的说明</strong>
        </h3>
        <p>假设我们的团队已经开发了一款名叫 Fizzbuzz 的软件。</p>
        <p>这一软件在输出 1 至 100 的数字时会如下显示。</p>
        <ul>
          <li>
            <p>3 的倍数时显示 fizz</p>
          </li>
          <li>
            <p>5 的倍数时显示 buzz</p>
          </li>
          <li>
            <p>3 与 5 的公倍数时显示 fizzbuzz</p>
          </li>
          <li>
            <p>除上述情况外直接显示数字</p>
          </li>
        </ul>
        <p>就是这样一个简单的软件。</p>
        <pre class="代码无行号">
<code>$ ruby exec.rb
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
 省略

</code>
</pre>
        <p>现在就来讲解我们作为这个软件开发团队的一员，实践 GitHub Flow 时的情景。</p>
        <h3 id="nav_point_209">
          <strong>添加新功能</strong>
        </h3>
        <p>现在我们被分配了新工作，那就是添加下面这个新功能。</p>
        <ul>
          <li class="第1级无序列表">含有 7 的数字时显示 GitHub</li>
        </ul>
        <p>看起来应该很简单，我们这就动手吧。</p>
        <h3 id="nav_point_210">
          <strong>创建新的分支</strong>
        </h3>
        <p>在 GitHub Flow 中，无论是实现新功能还是修正 BUG，都需要从能正常运行的最新 master 分支中新建一个分支。所有实际修改都在这个新建的分支中进行。</p>
        <h4 id="sigil_toc_id_170">
          <strong>……如果尚未 clone 仓库</strong>
        </h4>
        <p>首先需要 Fork 已经公开的仓库 <span class="注释编号">8</span>
          。如果尚未获取仓库，则需要使用下面的命令进行 clone。各位请将仓库路径替换为自己的对应路径。</p>
        <p class="注释内容">
          <span class="注释编号下">8</span>
          <a href="https://github.com/ituring/fizzbuzz">https://github.com/ituring/fizzbuzz</a>
        </p>
        <pre class="代码无行号">
<code>$ git clone git@github.com:ituring/fizzbuzz.git
Cloning into 'fizzbuzz'...
remote: Counting objects: 18, done.
remote: Compressing objects: 100% (12/12), done.
remote: Total 18 (delta 2), reused 17 (delta 1)
Receiving objects: 100% (18/18), done.
Resolving deltas: 100% (2/2), done.
$ cd fizzbuzz

</code>
</pre>
        <p>在 fizzbuzz 目录下新建了一个仓库，这个仓库与远程仓库拥有相同状态。</p>
        <h4 id="sigil_toc_id_171">
          <strong>……如果之前 clone 过仓库</strong>
        </h4>
        <p>假设本地已经有之前 clone 来的仓库，现在正在开发途中并不需要重新 clone，那么我们应该将 master 分支更新成远程仓库最新 master 分支的状态。流程很简单，只需切换到本地仓库的 master
          分支，然后将远程仓库的 master 分支 pull 到本地即可。</p>
        <pre class="代码无行号">
<code>$ git checkout master
Switched to branch 'master'
        　
$ git pull
First, rewinding head to replay your work on top of it...
Fast-forwarded master to 51412d2d518af30deaa8fd5e6469c9376ee1f447.

</code>
</pre>
        <p>通过以上操作，我们手头就有了最新状态的 master 分支。</p>
        <h4 id="sigil_toc_id_172">
          <strong>……创建特性分支</strong>
        </h4>
        <p>现在我们已经完成了从 master 分支创建新分支的所有准备工作。我们将新分支的名字定为 7-case-output-github。</p>
        <p>在 master 分支中使用下述命令创建新分支，并切换到新分支。</p>
        <pre class="代码无行号">
<code>$ git checkout -b 7-case-output-github
Switched to a new branch '7-case-output-github'

</code>
</pre>
        <p>为方便团队其他人通过分支名称知道我们在做什么，我们在 GitHub 端的远程仓库中创建一个同名分支。</p>
        <pre class="代码无行号">
<code>$ git push -u origin 7-case-output-github
Total 0 (delta 0), reused 0 (delta 0)
To git@github.com:ituring/fizzbuzz.git
 * [new branch]      7-case-output-github -&gt; 7-case-output-github
Branch 7-case-output-github set up to track remote branch 7-case-output
-github from origin.

</code>
</pre>
        <p>创建分支大概就是这个步骤。今后我们可以每当工作告一段落时，定期将这个特性分支 push 到远程仓库。</p>
        <h3 id="nav_point_211">
          <strong>实现新功能</strong>
        </h3>
        <p>现在我们来实现新功能——含有数字 7 时显示 GitHub。原本的代码（fizzbuzz.rb）如下，</p>
        <pre class="代码无行号">
<code>class Fizzbuzz
  def calculate number
    if number % 3 == 0 &amp;&amp; number % 5 == 0
      'fizzbuzz'
    elsif number % 3 == 0
      'fizz'
    elsif number % 5 == 0
      'buzz'
    else
      number
    end
  end
end

</code>
</pre>
        <p>现在我们添加含有数字 7 时的代码，diff 如下。</p>
        <pre class="代码无行号">
<code>@@ -6,6 +6,8 @@ class Fizzbuzz
       'fizz'
     elsif number % 5 == 0
       'buzz'
+      elsif number.to_s.include? '7'
+      'GitHub'
     else
       number
     end

</code>
</pre>
        <p>我们试着执行一下，结果运行正常。</p>
        <pre class="代码无行号">
<code>$ ruby exec.rb
1
2
fizz
4
buzz
fizz
GitHub
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
GitHub

</code>
</pre>
        <p>提交本次实现的内容。</p>
        <pre class="代码无行号">
<code>$ git commit -am "Add output GitHub"
[7-case-output-github 676c64d] Add output GitHub
 1 file changed, 2 insertions(+)

</code>
</pre>
        <p>新功能已经顺利实现，现在将其 push 到远程仓库。</p>
        <pre class="代码无行号">
<code>$ git push
Counting objects: 7, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 385 bytes, done.
Total 4 (delta 2), reused 0 (delta 0)
To git@github.com:ituring/fizzbuzz.git
   ca9ebf6..676c64d 7-case-output-github -&gt; 7-case-output-github

</code>
</pre>
        <p>GitHub 端远程仓库中的分支应该已经被更新。我们打开 GitHub 的分支列表页面，能看到该远程分支与 master 分支的差别（图 9.6）。点击之后可以查看差别的详细内容。</p>
        <p class="图"><img src="Image00130.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.6　分支列表页面</strong>
        </p>
        <h3 id="nav_point_212">
          <strong>创建 Pull Request</strong>
        </h3>
        <p>至此，我们已经顺利实现了新功能，接下来就是从 7-case-output-github 分支创建一个 Pull Request 发送给 master 分支，请求与 master 合并（图 9.7）<span
            class="注释编号">9</span>
          。创建 Pull Request 的相关操作请参照第 6 章。</p>
        <p class="注释内容">
          <span class="注释编号下">9</span>
          Pull Request 在创建时会默认指向 Fork 来源的仓库，由于本书在获取示例仓库时进行了 Fork，所以这里我们需要更改目标仓库的路径。正式采用 GitHub Flow 的开发现场是不需要进行 Fork
          操作的，所以在实际应用中不需要修改目标路径的操作。
        </p>
        <p class="图"><img src="Image00131.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.7　向 master 分支发送的 Pull Request</strong>
        </p>
        <p>在 Pull Request 中写明希望得到审查。如果想让特定的人来进行审查，可以在评论中加入“@ 用户名”，这样该用户就会收到 Notifications。</p>
        <p>现在我们已经创建并发送了 Pull Request，只需等待其他开发者的反馈即可。</p>
        <h3 id="nav_point_213">
          <strong>接收反馈</strong>
        </h3>
        <p>距离发送 Pull Request 已经过了几个小时，我们再次登录 GitHub。此时已有其他开发者已经发来了反馈（图 9.8）。</p>
        <p class="图"><img src="Image00132.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.8　其他开发者的反馈</strong>
        </p>
        <p>对方为我们指出了 2 个问题。</p>
        <ul>
          <li>
            <p>缩进不正常</p>
          </li>
          <li>
            <p>没有测试代码</p>
          </li>
        </ul>
        <p>点击“缩进好像不太对”所指的链接，我们可以看到如图 9.9 所示的页面，其中清楚地显示出评论所指代码的位置。确实与前面 elsif 的缩进没有对齐。</p>
        <p class="图"><img src="Image00133.jpg" alt="图像说明文字" />
        </p>
        <p class="p-img-title">
          <strong>图 9.9　被评论代码所在的位置</strong>
        </p>
        <p>至于测试代码，我们确实在添加新功能时没有添加相应的测试代码，对方指出的问题确实存在。接下来，我们要着手处理这 2 个问题。</p>
        <h3 id="nav_point_214">
          <strong>修正缩进</strong>
        </h3>
        <p>下面，我们来修正对方指出的代码缩进问题。修正后的 diff 如下所示。</p>
        <pre class="代码无行号">
<code>@@ -6,7 +6,7 @@ class Fizzbuzz
       'fizz'
     elsif number % 5 == 0
       'buzz'
-      elsif number.to_s.include? '7'
+    elsif number.to_s.include? '7'
       'GitHub'
     else
       number

</code>
</pre>
        <p>然后将修改提交至本地的 7-case-output-github 分支。</p>
        <pre class="代码无行号">
<code>$ git commit -am "Fix indent"
[7-case-output-github f15fe2e] Fix indent
 1 file changed, 1 insertion(+), 1 deletion(-)

</code>
</pre>
        <p>接下来将该分支 push 到 GitHub 端的远程仓库，为远程仓库分支添加这项修改。</p>
        <pre class="代码无行号">
<code>$ git push
Counting objects: 7, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 335 bytes, done.
Total 4 (delta 2), reused 0 (delta 0)
To git@github.com:github-book/fizzbuzz.git
   676c64d..f15fe2e 7-case-output-github -&gt; 7-case-output-github

</code>
</pre>
        <p>这时我们再打开 GitHub 查看 Pull Request，会发现这个用于修正的提交已经添加至 Pull Request（图 9.10）。</p>
        <p class="图"><img src="Image00134.jpg" alt="图像说明文字" />
        </p>
        <p class="p-img-title">
          <strong>图 9.10　缩进的修正已经添加至 Pull Request</strong>
        </p>
        <h3 id="nav_point_215">
          <strong>添加测试</strong>
        </h3>
        <p>在 GitHub Flow 中，不可以将没有测试代码的成品代码加入 master 分支。因此我们被其他开发者指出没有编写测试代码了。</p>
        <p>一般来说应该是下面这样的顺序。</p>
        <ul>
          <li>
            <p>将 master 分支更新到最新状态</p>
          </li>
          <li>
            <p>在自己的开发环境中确认通过所有测试</p>
          </li>
          <li>
            <p>从 master 分支创建新分支</p>
          </li>
          <li>
            <p>编写测试代码</p>
          </li>
          <li>
            <p>编写实现目标功能的代码</p>
          </li>
          <li>
            <p>确认通过所有测试并且没有出现退步（Regression）现象</p>
          </li>
          <li>
            <p>发送 Pull Request 请求合并至 master 分支</p>
          </li>
        </ul>
        <p>也就是应该先编写目标功能的测试代码，以保证测试代码全部通过为基准编写功能代码。这个操作顺序能够极力减少出现 BUG
          的可能，并且可以随时修改功能代码。由于本次我们直接编写了功能的功能代码，所以需要回过头来再为其添加一份测试代码。</p>
        <p>根据已有的测试代码为本次实现的功能编写测试代码时，我们突然有了一个疑问。</p>
        <p>例如 75 这个数字，它既是 3 的倍数也是 5 的倍数，按照旧功能会显示为 fizzbuzz，那么在添加新功能后它应该显示为 GitHub 吗？还是说应该显示成 fizzbuzzGitHub
          这种组合形式呢？关于这种情况我们并没有接到说明，所以保险起见，我们通过 Pull Request 确认一下。</p>
        <p>在 Pull Request 中写下如图 9.11 所示的评论。</p>
        <p class="图"><img src="Image00135.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.11　通过评论询问规范</strong>
        </p>
        <p>不久，我们收到了其他开发者的反馈（图 9.12）。</p>
        <p class="图"><img src="Image00136.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.12　对规范相关问题的回答</strong>
        </p>
        <p>按照反馈的指示，我们在 fizzbuzz_spec.rb 中添加测试代码。</p>
        <pre class="代码无行号">
<code>context 'GitHub number' do
  it { subject.calculate(17).should eq 'GitHub' }
  it { subject.calculate(27).should eq 'GitHub' }
  it { subject.calculate(75).should eq 'GitHub' }
  it { subject.calculate(77).should eq 'GitHub' }
end

</code>
</pre>
        <p>我们添加了具有以下意图的测试。</p>
        <ul>
          <li>
            <p>17 与 77 中包含 7，所以显示 GitHub</p>
          </li>
          <li>
            <p>27 虽然是 3 的倍数，但仍然显示 GitHub</p>
          </li>
          <li>
            <p>75 既是 3 的倍数也是 5 的倍数，但仍然显示 GitHub</p>
          </li>
        </ul>
        <p>然后执行测试。</p>
        <pre class="代码无行号">
<code>$ rspec
...........FF.
        　
Failures:
        　
  1) Fizzbuzz GitHub number
     Failure/Error: it { subject.calculate(27).should eq 'GitHub' }
        　
       expected: "GitHub"
            got: "fizz"
        　
      (compared using ==)
    # ./spec/fizzbuzz_spec.rb:25:in `block (3 levels) in &lt;top (required)&gt;'
        　
  2) Fizzbuzz GitHub number
     Failure/Error: it { subject.calculate(75).should eq 'GitHub' }
        　
       expected: "GitHub"
            got: "fizzbuzz"
        　
       (compared using ==)
     # ./spec/fizzbuzz_spec.rb:26:in `block (3 levels) in &lt;top (required)&gt;'
        　
Finished in 0.00373 seconds
14 examples, 2 failures
        　
Failed examples:
        　
rspec ./spec/fizzbuzz_spec.rb:25 # Fizzbuzz GitHub number
rspec ./spec/fizzbuzz_spec.rb:26 # Fizzbuzz GitHub number

</code>
</pre>
        <p>从上面我们可以看到，27 与 75 时并没有显示 GitHub，因此代码需要进行修正。修正后的差别如下。</p>
        <pre class="代码无行号">
<code>@@ -1,13 +1,13 @@
 class Fizzbuzz
   def calculate number
-    if number % 3 == 0 &amp;&amp; number % 5 == 0
+    if number.to_s.include? '7'
+      'GitHub'
+    elsif number % 3 == 0 &amp;&amp; number % 5 == 0
       'fizzbuzz'
     elsif number % 3 == 0
       'fizz'
     elsif number % 5 == 0
       'buzz'
-    elsif number.to_s.include? '7'
-      'GitHub'
     else
       number
     end

</code>
</pre>
        <p>我们将判定是否显示 GitHub 的语句换了个位置。这段代码理所当然地通过了所有测试。</p>
        <pre class="代码无行号">
<code>$ rspec
..............
        　
Finished in 0.00353 seconds
14 examples, 0 failures

</code>
</pre>
        <p>至此，我们添加了测试代码，成品代码也能按照预期顺利执行了。</p>
        <h3 id="nav_point_216">
          <strong>培育 Pull Request</strong>
        </h3>
        <p>为了将我们编写的新功能合并到 master 分支中，要进行提交并 push。</p>
        <pre class="代码无行号">
<code>$ git commit -am "Fix output GitHub"
[7-case-output-github 5d1daae] Fix output GitHub
 2 files changed, 9 insertions(+), 3 deletions(-)
    　
$ git push
Counting objects: 11, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 531 bytes, done.
Total 6 (delta 3), reused 0 (delta 0)
To git@github.com:ituring/fizzbuzz.git
   f15fe2e..5d1daae 7-case-output-github -&gt; 7-case-output-github

</code>
</pre>
        <p>确认 Pull Request 没有问题之后，便可以通过评论请求与 master 合并了（图 9.13）。</p>
        <p class="图"><img src="Image00137.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.13　在 Pull Request 中添加评论</strong>
        </p>
        <p>这一系列反馈与代码更新的过程，我们称作培育 Pull Request。</p>
        <h3 id="nav_point_217">
          <strong>Pull Request 被合并</strong>
        </h3>
        <p>随后，我们的代码通过了其他开发者的审查，被顺利合并至 master 分支（图 9.14）。</p>
        <p class="图"><img src="Image00138.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.14　被合并至 master 分支后的情景</strong>
        </p>
        <p>合并完成后，这个 master 分支将被立刻部署至正式环境 <span class="注释编号">10</span>
          。</p>
        <hr />
        <p class="注释内容">
          <span class="注释编号下">10</span>
          这一系列交流可以在 GitHub 上阅览。<br />
          <a href="https://github.com/ituring/fizzbuzz/pull/1">https://github.com/ituring/fizzbuzz/pull/1</a>
        </p>
        <p>通过创建 Pull Request 获取反馈并逐渐培育 Pull Request 的过程想必各位已经有了初步的了解。在实际开发现场，会有更多开发者共同参与到这个交流过程中。</p>
        <p>习惯了在 Pull Request 上进行交流后，我们将能更精确地表达出代码的意图，审查的效率也会越来越快。熟练运用 Pull Request 是这一开发流程成功的关键。</p>
        <p>希望各位能将这一开发流程应用到自己的开发现场，以便更加灵活地使用 GitHub。</p>
        <h2 id="nav_point_218">
          <strong>9.6　团队实践 GitHub Flow 时的几点建议</strong>
        </h2>
        <p>至此，相信各位已经清楚 GitHub Flow 需要以什么样的流程来实施。但是在开发现场实际采用这一流程时，还会遇到一些令人苦恼的问题。在这里，笔者将从自身经验出发，为各位介绍几个成功运用这一开发流程的窍门。</p>
        <h3 id="nav_point_219">
          <strong>减小 Pull Request 的体积</strong>
        </h3>
        <p>很多团队在开发时，喜欢将一个功能放到一个分支中进行开发。这里各位不妨思考一下，这一个功能是不是还能继续细分？</p>
        <p>比方说接下来的一个新功能我们预计要花 2 周来实现。试想一下，大约 2 周时间编写出来的代码，即便最后顺利进入 Pull Request 阶段，这个代码量也会给代码审查方带来非常重的负担。</p>
        <p>开发时间越长或者代码量越大，代码审查时的成本就越高。过长的开发时间让审查者难以了解开发该功能时的背景，过大的代码量会让审查者难以阅读到代码的每个细节。这样一来 BUG
          更容易出现，久而久之整个团队的代码审查都会漏洞频出。</p>
        <p>在这种团队状态及环境下，要把经过漫长时间编写出来的代码突然部署到正式环境中，将会是一个让人畏手畏脚的高风险工作。其结果便是导致整个开发速度减缓。</p>
        <p>与开发了 2 周的分支相比，只开发了 1 周的分支的代码量更少，审查者在理解代码时的成本也更小，相对而言能更快合入 master 分支。以此类推，花 3 天时间开发出的代码会怎样？花 1
          天时间开发出的代码又会怎样？相信各位可以想象得出。</p>
        <p>在刚刚采用这一开发流程，对整个流程还不是很习惯时，建议各位将目标功能细分，尽量缩小 Pull Request 的体积，保证每几小时至几天向 master 分支发送一次 Pull
          Request，通过多次合并来实现一个功能。这样一来不但能有一个很好的开发节奏，软件的成长过程也能够更加安全可靠。</p>
        <p>所以各位在创建新的分支之前，不妨先对目标功能或内容进行讨论，看看是否能分割成几个更小的 Pull Request。</p>
        <h3 id="nav_point_220">
          <strong>准备可供试运行的环境</strong>
        </h3>
        <p>不管我们写了多少测试代码，只要该分支中包含了对软件关键部分的修改，在将其部署到正式环境时都需要极大的勇气，而且这时还伴随着很高的风险。</p>
        <p>于是，我们不妨创建一个与正式环境高度相似的预演（Staging）环境，在这个预演环境中部署关键修改，借以确认代码的实际运行状况。当然，向预演环境的部署也需要实现自动化。</p>
        <p>
          如果分支中包含“对数据库进行了大幅修改”“实施了大规模重构”“对充值处理部分进行了大幅修改”这类对系统有重大影响的关键性修改，为安全起见最好先将其部署到预演环境中进行试运行。但要注意，不要把所有修改都拿到预演环境中进行试运行，免得画蛇添足。
        </p>
        <p>近来的 Web 应用程序往往会先对部分用户（通常是 1%）进行部署，通过 Twitter 等 SNS 监控是否出现了重大影响。</p>
        <p>如果出于不安总想把部署向后搁置，不如准备一个环境来消除不安，让代码可以迅速部署到正式环境中。</p>
        <h3 id="nav_point_221">
          <strong>不要让 Pull Request 中有太多反馈</strong>
        </h3>
        <p>笔者在接到 Pull Request 时遇到过下面这种情况：代码存在多处问题，进行多次指正和修改后仍然无法达到与 master 分支合并的水准。出现这种情况大概有两个原因。</p>
        <p>一是交流不足。如果创建 Pull Request 的理由没有获得认同，那就不要通过 Pull Request 进行讨论，而是应该选择其他手段进行交流。最好的解决途径是直接面谈。</p>
        <p>
          另一个原因是技术或能力不足。如果代码经常被指出问题，那么不是编程能力方面有问题，就是团队编写代码时没有一个明确的规则。为避免在无用的讨论上浪费时间，团队应该制定一个最低限度的编程规则，并且告知每一名团队成员。如果在开发过程中还需要其他规则，可以将这些规则整合到
          Wiki 中，便于阅览及修改。</p>
        <p>如果在类的设计、方法的实现、变量的命名等方面频繁出现问题，不妨实施一些能提高开发者编码技术的措施，效果要远好于一遍遍反复指正。</p>
        <ul>
          <li>
            <p>结对编程</p>
          </li>
          <li>
            <p>组织学习小组共享知识</p>
          </li>
          <li>
            <p>共享可供参考的资料</p>
          </li>
        </ul>
        <p>不知各位的团队中是否实施了这些措施。在这些措施之中，结对编程收效最佳。</p>
        <p>GitHub Flow 是以部署为中心的开发流程，所以要求团队中每一名开发者都能编写出高品质的代码，以便顺利通过审查，迅速完成从合并到部署的过程。因此需要锻炼开发者，保证每一名团队成员都能达到这一水平。</p>
        <h3 id="nav_point_222">
          <strong>不要积攒 Pull Request</strong>
        </h3>
        <p>在以部署为中心的开发流程中，如果总有大量 Pull Request 处于等待审查或等待修正的状态，会导致长期无法部署，引发严重问题。</p>
        <p>如果每一名开发者都在忙于实现各自的新功能，把所有精力都放在编写代码和创建 Pull Request 上，势必会忽视审查与反馈工作。时间一长，无法部署的 Pull Request 就会堆积如山。</p>
        <p>为防止这一情况发生，建议团队制定一个新的规则：想创建 Pull Request 的人要先去对其他人的 Pull Request 进行审查及反馈，并在可以部署时及时部署。</p>
        <p>这样一来，自己想创建 Pull Request 时必须先处理其他人的 Pull Request，就可以有效避免 Pull Request 堆积的情况发生。</p>
        <h2 id="nav_point_223">
          <strong>9.7　GitHub Flow 的小结</strong>
        </h2>
        <p>笔者根据自身经验，提出了一些开发现场容易出现的问题。各位在开发的过程中必然还会遇到其他恼人的问题。对于这些问题，请遵循以下这两点去寻找解决方案。</p>
        <ul>
          <li>
            <p>开发流程以部署为中心</p>
          </li>
          <li>
            <p>高速源于简单</p>
          </li>
        </ul>
        <p>只要不偏离这两点，各位一定能找到适合自己开发现场的解决方案。</p>
        <h2 id="nav_point_224">
          <strong>9.8　Git Flow——以发布为中心的开发模式</strong>
        </h2>
        <p>荷兰程序员 Vincent Driessen 曾发表了一篇博客 <span class="注释编号">11</span>
          ，让一个分支策略广为人知，那就是 A successful Git branching model。这里我们将向各位介绍一个以它为基础，组合了 GitHub 的开发流程。</p>
        <p class="注释内容">
          <span class="注释编号下">11</span>
          <a
            href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/</a>
        </p>
        <p>在这个开发流程中，每个分支都显示出代码的当前状态。流程中设置了负责管理软件发布 Release 的发布管理员，适用于以发布为中心的软件开发。</p>
        <p>通过整体的流程图（图 9.15），我们不难看出该流程分支间的代码流向十分复杂。关于每部分的详细内容我们将在稍后进行讲解。</p>
        <p class="图"><img src="Image00139.jpg" alt="" width="90%" style="width: 90%" />
        </p>
        <p>
          <sup>※ Vincent Driessen“A successful Git branching model-nvie.com”（<a
              href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/</a>
            ）</sup>
        </p>
        <p class="p-img-title">
          <strong>图 9.15　A successful Git branching model</strong>
        </p>
        <h3 id="nav_point_225">
          <strong>便于理解的标准流程</strong>
        </h3>
        <p>从软件开发者的角度观察这一开发流程时会发现，该流程用分支名表示标准软件开发中开发状态的迁移。</p>
        <p>❶ 从开发版的分支（develop）创建工作分支（feature branches），进行功能的实现或修正</p>
        <p>❷ 工作分支（feature branches）的修改结束后，与开发版的分支（develop）进行合并</p>
        <p>❸ 重复上述❶和❷，不断实现功能直至可以发布</p>
        <p>❹ 创建用于发布的分支（release branches），处理发布的各项工作</p>
        <p>❺ 发布工作完成后与 master 分支合并，打上版本标签（Tag）进行发布</p>
        <p>❻ 如果发布的软件出现 BUG，以打了标签的版本为基础进行修正（hotfixes）</p>
        <p>整个流程看上去应该比较好理解。这一流程最大的亮点在于考虑了紧急的 BUG 应对措施。</p>
        <h3 id="nav_point_226">
          <strong>有时显得过于复杂</strong>
        </h3>
        <p>这个开发流程的问题在于需要记忆的分支状态很多，在实施之前必须对整个开发流程进行系统地学习。虽然团队成员可以通过我们即将讲到的 git-flow<span class="注释编号">12</span>
          等工具得到辅助，但很多情况下，流程整体对于我们的实际开发现场来说仍然显得过于复杂。</p>
        <p class="注释内容">
          <span class="注释编号下">12</span>
          <a href="https://github.com/nvie/gitflow">https://github.com/nvie/gitflow</a>
        </p>
        <p>
          在这个流程中，程序员必须理解自己正在进行的修改会对哪些分支产生影响。一个分支的工作结束后，有时需要与多个目标分支合并。这些是该流程中最为复杂的部分，需要团队谨慎处理。同时由于其复杂程度高，容易出现操作失误等人为错误。所以团队需要使用
          git-flow 等工具进行辅助，时刻保证开发不偏离流程。</p>
        <p>考虑到上述种种因素，各位的团队在采用这一开发流程之前必须进行系统学习，充分掌握其优势与劣势。下面，我们先为该流程的辅助工具构筑环境，再通过 Git 与 GitHub 的操作向各位进行详细讲解。</p>
        <h2 id="nav_point_227">
          <strong>9.9　导入 Git Flow 前的准备</strong>
        </h2>
        <h3 id="nav_point_228">
          <strong>安装 git-flow</strong>
        </h3>
        <p>现在我们要安装 git-flow，各位请根据自己当前的环境进行安装。git-flow 是一款辅助 Git Flow
          的工具，虽然不安装它也可以实施该开发流程，但那样一来所有工作都必须手动完成。为防止出现人为失误，这里还是建议各位安装这个工具。</p>
        <h4 id="sigil_toc_id_173">
          <strong>……Mac 下的安装</strong>
        </h4>
        <p>如果已经安装了 Homebrew，可以用下面的命令轻松完成 git-flow 的安装。</p>
        <pre class="代码无行号">
<code>$ brew install git-flow

</code>
</pre>
        <p>如果安装了 MacPorts，则使用下面的命令。</p>
        <pre class="代码无行号">
<code>$ sudo port install git-flow

</code>
</pre>
        <h4 id="sigil_toc_id_174">
          <strong>……Linux 下的安装</strong>
        </h4>
        <p>Ubuntu 和 Debian GNU/Linux 等已经为用户准备好了相应软件包，可以用下面的命令直接安装。</p>
        <pre class="代码无行号">
<code>$ sudo apt-get install git-flow

</code>
</pre>
        <p>如果尚未导入包管理工具，可以用下面的方式安装。</p>
        <pre class="代码无行号">
<code>$ wget --no-check-certificate -q -O - https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | sudo bash  实际为1行

</code>
</pre>
        <h4 id="sigil_toc_id_175">
          <strong>……确认运行状况</strong>
        </h4>
        <p>如果能像下面例子中一样顺利运行 <code>git-flow</code>
          命令，就证明 git-flow 已经成功安装了。</p>
        <pre class="代码无行号">
<code>$ git flow
usage: git flow &lt;subcommand&gt;
        　
Available subcommands are:
   init      Initialize a new git repo with support for the branching model.
   feature   Manage your feature branches.
   release   Manage your release branches.
   hotfix    Manage your hotfix branches.
   support   Manage your support branches.
   version   Shows version information.

</code>
</pre>
        <h3 id="nav_point_229">
          <strong>仓库的初始设置</strong>
        </h3>
        <p>为方便讲解这个流程，我们假设自己正在开发博客软件。</p>
        <h4 id="sigil_toc_id_176">
          <strong>……创建仓库</strong>
        </h4>
        <p>首先要在 GitHub 上新建一个 Git 仓 库。我们创建了一个附带 README.md 文件的名为 blog 的仓库。紧接着我们来 clone 这个仓库。</p>
        <p>本次示例中我们的账户名为 hirocaster，仓库名为 blog。</p>
        <pre class="代码无行号">
<code>$ git clone git@github.com:hirocaster/blog.git
Cloning into 'blog'...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (3/3), done.
Checking connectivity... done.

</code>
</pre>
        <h4 id="sigil_toc_id_177">
          <strong>……进行 git flow 的初始设置</strong>
        </h4>
        <p>下面我们为 git flow 进行初始设置。由于我们不打算更改默认值，所以在命令后附上 <code>- d</code>
          参数。执行以下命令后，仓库中会自动生成开发流程所需的分支。各位在执行 <code>git clone</code>
          后请务必记得执行一次这个命令。</p>
        <pre class="代码无行号">
<code>$ cd blog
$ git flow init -d
Using default branch names.
        　
Which branch should be used for bringing forth production releases?
   - master
Branch name for production releases: [master]
Branch name for "next release" development: [develop]
        　
How to name your supporting branch prefixes?
Feature branches? [feature/]
Release branches? [release/]
Hotfix branches? [hotfix/]
Support branches? [support/]
Version tag prefix? []

</code>
</pre>
        <p>查看已创建的分支。</p>
        <pre class="代码无行号">
<code>$ git branch -a
* develop
  master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master

</code>
</pre>
        <p>可以看到 develop 分支已经创建完毕，现在我们已经切换到这一分支。</p>
        <h4 id="sigil_toc_id_178">
          <strong>……在远程仓库中也创建 develop 分支</strong>
        </h4>
        <p>目前我们在本地环境中拥有 master 和 develop 两个分支，但是 GitHub 端的远程仓库 <span class="注释编号">13</span>
          中仍然只有 master 分支。所以我们进行 push 操作，在 GitHub 端的远程仓库中也创建一个 develop 分支。</p>
        <p class="注释内容">
          <span class="注释编号下">13</span>
          GitHub 端的远程仓库为 remotes/origin
        </p>
        <pre class="代码无行号">
<code>$ git push -u origin develop
Total 0 (delta 0), reused 0 (delta 0)
To git@github.com:hirocaster/blog.git
 * [new branch]      develop -&gt; develop
Branch develop set up to track remote branch develop from origin.
        　
$ git branch -a
* develop  ←本地的develop分支
  master   ←本地的master分支
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/develop  ←GitHub端的develop分支
  remotes/origin/master   ←GitHub端的master分支

</code>
</pre>
        <p>现在 GitHub 端的仓库中也有了 develop 分支。</p>
        <hr />
        <p>今后团队会以 GitHub 端的 develop 分支作为开发中的最新代码，包括我们在内的所有团队成员都要以这个分支为基础进行开发。</p>
        <p>开发的基本操作流程很简单。我们先在本地仓库中对代码进行修改，然后 push 到 GitHub 端更新远程仓库，其他开发者再从 GitHub 端的远程仓库获取最新代码到本地进行开发。</p>
        <p>开发者要时刻注意，对分支进行任何操作之前都必须先执行 pull 获取最新代码，修改完毕后应尽快进行 push 操作，保证 GitHub 端远程仓库内的代码为最新状态。</p>
        <h2 id="nav_point_230">
          <strong>9.10　模拟体验 Git Flow</strong>
        </h2>
        <p>接下来，我们开始实践 Git Flow。</p>
        <h3 id="nav_point_231">
          <strong>master 分支与 develop 分支的区别</strong>
        </h3>
        <p>下面我们先给各位讲一讲 master 分支与 develop 分支的相关内容。在 Git Flow 中这两个分支至关重要，它们会贯彻整个流程始终，绝对不会被删除。</p>
        <h4 id="sigil_toc_id_179">
          <strong>……master 分支</strong>
        </h4>
        <p>master 分支时常保持着软件可以正常运行的状态。由于要维持这一状态，所以不允许开发者直接对 master 分支的代码进行修改和提交。</p>
        <p>其他分支的开发工作进展到可以发布的程度后，将会与 master 分支进行合并，而且这一合并只在发布成品时进行。发布时会附加包含版本编号的 Git 标签（Tag）。这部分的详细内容我们将在后面进行讲解。</p>
        <h4 id="sigil_toc_id_180">
          <strong>……develop 分支</strong>
        </h4>
        <p>develop 分支是开发过程中的代码中心分支。与 master 分支一样，这个分支也不允许开发者直接进行修改和提交。</p>
        <p>程序员要以 develop 分支为起点新建 feature 分支，在 feature 分支中进行新功能的开发或者代码的修正。也就是说，develop 分支维持着开发过程中的最新源代码，以便程序员创建 feature
          分支进行自己的工作。</p>
        <h3 id="nav_point_232">
          <strong>在 feature 中进行的工作</strong>
        </h3>
        <p>feature 分支以 develop 分支为起点，是开发者直接更改代码发送提交的分支。开发以下述流程进行。</p>
        <p>❶ 从 develop 分支创建 feature 分支</p>
        <p>❷ 在 feature 分支中实现目标功能</p>
        <p>❸ 通过 GitHub 向 develop 分支发送 Pull Request</p>
        <p>❹ 接受其他开发者审查后，将 Pull Request 合并至 develop 分支</p>
        <p>与 develop 分支合并后，已经完成工作的 feature 分支就失去了作用，可以在适当的时候删除。</p>
        <p>为方便进行具体讲解，现在假设我们要给软件实现一个添加用户的功能。</p>
        <h4 id="sigil_toc_id_181">
          <strong>……创建分支</strong>
        </h4>
        <p>上面我们提到过 develop 分支是 feature 分支的起点，所以我们要从最新状态的 develop 分支新建一个 feature 分支，在这个分支中实现添加用户的功能。这里我们将分支名定为 add-user。
        </p>
        <p>首先要将 develop 分支更新至最新状态。我们从 GitHub 的远程仓库进行 pull 操作。这一操作要在 develop 分支下进行。</p>
        <pre class="代码无行号">
<code>$ git pull
Already up-to-date.

</code>
</pre>
        <p>由于我们本地的 develop 分支已经是 GitHub 端远程分支的最新状态，所以执行 git pull 命令后没有任何变化。如果远程分支被其他开发者更新过，那么我们的本地 develop
          分支将会通过这一操作获取到最新 代码。</p>
        <p>创建 feature 分支 add-user，用来实现添加用户的功能。</p>
        <pre class="代码无行号">
<code>$ git flow feature start add-user
Switched to a new branch 'feature/add-user'
        　
Summary of actions:
- A new branch 'feature/add-user' was created, based on 'develop'
- You are now on branch 'feature/add-user'
        　
Now, start committing on your feature. When done, use:
        　
     git flow feature finish add-user

</code>
</pre>
        <p>我们已经创建并切换到了 feature/add-user 分支。保险起见，让我们来确认一下。</p>
        <pre class="代码无行号">
<code>$ git branch
  develop
* feature/add-user
  master

</code>
</pre>
        <p>结果显示我们处于 feature/add-user 分支下。现在的状态正如图 9.16 所示。</p>
        <p class="图"><img src="Image00140.jpg" alt="" width="55%" style="width: 55%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.16　创建 feature 分支后的状态</strong>
        </p>
        <h4 id="sigil_toc_id_182">
          <strong>……在分支中进行作业</strong>
        </h4>
        <p>接下来在刚刚创建的 feature/add-user 分支中实现目标功能并进行提交。实际编写代码以及提交的过程在此就不再赘述。进行几次提交后，就会呈现图 9.17 的状态。</p>
        <p class="图"><img src="Image00141.jpg" alt="" width="55%" style="width: 55%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.17　提交后的状态</strong>
        </p>
        <h3 id="nav_point_233">
          <strong>发送 Pull Request</strong>
        </h3>
        <p>功能实现之后，需要通过 GitHub 发送 Pull Request，请求 develop 分支合并 feature/add-user 分支的内容。请注意，这里不能与本地的 Git 仓库进行合并，而是要利用
          GitHub 的 Pull Request
          功能接受代码审查，然后再合并到远程仓库的分支中。这样可以让其他开发者看到我们的代码，从而指出其中的问题。如果在设计上有不同意见还可以进行讨论，以便写出更高品质的代码。通过这些措施，可以有效提高代码质量。</p>
        <p>首先我们将 feature/add-user 分支 push 到 GitHub 端远程仓库。</p>
        <pre class="代码无行号">
<code>$ git push origin feature/add-user
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (5/5), 452 bytes | 0 bytes/s, done.
Total 5 (delta 1), reused 0 (delta 0)
To git@github.com:hirocaster/blog.git
 * [new branch]      feature/add-user -&gt; feature/add-user

</code>
</pre>
        <p>如果是与其他开发者共同开发同一个 feature 分支，那么远程仓库的 add-user 分支可能已经被更新，要记得通过 pull 操作获取 add-user 分支的最新代码。另外，在我们开发这个 feature
          分支的过程中，develop 分支可能有了最新版本，所以要养成在 push 之前先获取最新 develop 分支的习惯。确保上述两点之后再进行 push。</p>
        <p>现在打开 GitHub 的仓库页面，切换到 feature/add-user 分支（图 9.18）。</p>
        <p class="图"><img src="Image00142.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.18　显示 feature/add-user 分支</strong>
        </p>
        <p>点击切换分支菜单左侧的绿色图标，进入查看差别的页面。先要确认一下页面中显示的是否为 develop 分支和 feature/add-user 分支。如果发现是 master 等其他分支，需要点击右侧的 Edit
          按钮进行切换（图 9.19）。</p>
        <p class="图"><img src="Image00143.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.19　切换分支的按钮</strong>
        </p>
        <p>确认页面中显示的对象为“develop...feature/add-user”后，点击 Click to create a pull request for this comparison。随后会出现录入 Pull
          Request 信息的页面，供我们发送 Pull Request。</p>
        <p>发送 Pull Request 之后，便是图 9.20 所示的状态。</p>
        <p class="图"><img src="Image00144.jpg" alt="" width="48%" style="width: 48%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.20　发送 Pull Request 后分支的状态</strong>
        </p>
        <h3 id="nav_point_234">
          <strong>通过代码审查提高代码质量</strong>
        </h3>
        <p>发送 Pull Request 之后，通过下列步骤利用 Pull Request 从其他开发者那里获取反馈，不断精炼代码。</p>
        <p>❶ 由其他开发者进行代码审查，在 Pull Request 中提供反馈</p>
        <p>❷ 修正代码以反映反馈内容（在本地 feature/add-user 分支中）</p>
        <p>❸ 将 feature/add-user 分支 push 到远程仓库（自动添加至之前的 Pull Request）</p>
        <p>❹ 重复前三步</p>
        <p>❺ 确认 Pull Request 没有问题后，由其他开发者将其合并至 develop 分支</p>
        <p>下面是几个反馈的要点。</p>
        <ul>
          <li>
            <p>没有测试 or 测试未通过</p>
          </li>
          <li>
            <p>违反编码规则</p>
          </li>
          <li>
            <p>代码品质过低（命名不明确，方法冗长等）</p>
          </li>
          <li>
            <p>还有重构的余地</p>
          </li>
          <li>
            <p>有重复部分</p>
          </li>
        </ul>
        <p>如果发现代码品质仍有提高空间，建议先进行反馈，不要急着合并。</p>
        <p>能否按照以上要点在代码审查中追求高品质，直接影响到一个团队编写代码的能力。经常在审查时敷衍了事随意合并，最后成品软件的质量不可能过硬。Pull Request 的反馈并不只属于发送 Pull Request
          的人，它可以由整个团队共享，促进相互学习。另外，不特别限定 Pull Request 的代码审查者，让各个成员都主动进行审查，能够帮助团队维持高品质高效率的开发。</p>
        <h3 id="nav_point_235">
          <strong>更新本地的 develop 分支</strong>
        </h3>
        <p>我们发送的 Pull Request 在 GitHub 端与 develop 合并后，为让其反映到本地的 develop 分支中，我们需要进行以下操作。</p>
        <ul>
          <li>
            <p>切换至 develop 分支</p>
          </li>
          <li>
            <p>执行 git pull（fetch &amp; merge）</p>
          </li>
        </ul>
        <p>这样一来，本地 develop 分支就从 GitHub 端仓库获取了最新状态。</p>
        <pre class="代码无行号">
<code>$ git checkout develop
Switched to branch 'develop'
        　
$ git pull
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
From github.com:hirocaster/blog
   ad139da..9299f28  develop    -&gt; origin/develop
Updating ad139da..9299f28
Fast-forward
 add-user-1 | 0
 add-user-2 | 0
 2 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 add-user-1
 create mode 100644 add-user-2

</code>
</pre>
        <p>每当需要从 develop 分支创建 feature 等分支时，记得一定要先执行上述操作，保证 develop 分支处于最新状态。</p>
        <p>在实际开发中，我们会不断重复之前这一系列流程，不断为 develop 分支添加功能。当功能积攒到足以发布时，就会用到 release 分支。</p>
        <p>下面我们假设软件已经可以发布，将要使用 release 分支。</p>
        <h3 id="nav_point_236">
          <strong>在 release 分支中进行的工作</strong>
        </h3>
        <p>现在假设我们已经通过 feature 分支为 develop 分支添加了数个功能，软件进入了发布阶段。在这一阶段，我们要实现所有要发布的功能，发送 Pull Request 并且与 develop 分支合并。</p>
        <p>接下来给软件分配一个版本号进行发布。今后对这个版本的软件只做 BUG
          修复，不再进行其他支持。如果发布所需的工作尚未全部完成，那么绝对不可以进入我们即将讲解的工作阶段。我们接下来要讲解的操作，都需要发布管理员负起责任认真执行。</p>
        <blockquote>
          <p>
            <strong>专栏：设置默认分支</strong>
          </p>
          <p>如果每次发送 Pull Request 时都要从 master 分支手动切换到 develop 分支，显然容易出现操作失误。对此，我们可以更改 GitHub 的仓库设置，指定 develop 分支为发送 Pull
            Request 时的默认分支，省去手动修改的麻烦。</p>
          <p>在 GitHub 仓库的 Settings 页面可以找到图 a所示的 Default Branch 项目。只要将这里改为 develop，我们再通过浏览器访问仓库时就会默认显示 develop 分支，发送 Pull
            Request 时也会默认指向 develop 分支。</p>
          <p class="图"><img src="Image00145.jpg" alt="{%}" />
          </p>
          <p class="p-img-title">
            <strong>图 a　默认分支的设置页面</strong>
          </p>
        </blockquote>
        <h4 id="sigil_toc_id_183">
          <strong>……创建分支</strong>
        </h4>
        <p>我们从最新的 develop 分支着手，开始 1.0.0 版本的 release 工作。</p>
        <pre class="代码无行号">
<code>切换至develop分支
$ git checkout develop
Switched to branch 'develop'
        　
获取最新develop分支的代码
$ git pull
Already up-to-date.
        　
开始release分支
$ git flow release start '1.0.0'
Switched to a new branch 'release/1.0.0'
        　
Summary of actions:
- A new branch 'release/1.0.0' was created, based on 'develop'
- You are now on branch 'release/1.0.0'
        　
Follow-up actions:
- Bump the version number now!
- Start committing last-minute fixes in preparing your release
- When done, run:
        　
     git flow release finish '1.0.0'

</code>
</pre>
        <p>release/1.0.0 分支已经成功创建，它就是这次的 release 分支（图 9.21）。</p>
        <p class="图"><img src="Image00146.jpg" alt="" width="75%" style="width: 75%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.21　release 分支创建后的状态</strong>
        </p>
        <h4 id="sigil_toc_id_184">
          <strong>……分支内的工作</strong>
        </h4>
        <p>在这个分支中，我们只处理与发布前准备相关的提交。比如版本编号变更等元数据的添加工作。如果软件部署到预演环境后经测试发现
          BUG，相关的修正也要提交给这个分支。但要记住，该分支中绝对不可以包含需求变更或功能变更等重大修正。这一阶段的提交数应该限制到最低。</p>
        <h4 id="sigil_toc_id_185">
          <strong>……进行发布与合并</strong>
        </h4>
        <p>发布前的修正全部处理完后，我们结束这一分支。</p>
        <pre class="代码无行号">
<code>$ git flow release finish '1.0.0'

</code>
</pre>
        <p>当前状态如图 9.22 所示。</p>
        <p class="图"><img src="Image00147.jpg" alt="" width="70%" style="width: 70%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.22　release finish 之后</strong>
        </p>
        <p>release 分支将合并至 master 分支。分支在合并时会询问提交信息，如果没有需要特别声明的事项，可以直接保持默认状态。</p>
        <pre class="代码无行号">
<code>Merge branch 'release/1.0.0'
        　
# Please enter a commit message to explain why this merge is necessary,
# especially if it merges an updated upstream into a topic branch.
#
# Lines starting with '#' will be ignored, and an empty message aborts
# the commit.

</code>
</pre>
        <p>接下来，合并后的 master 分支会加入一个与版本号相同编号的标签。</p>
        <pre class="代码无行号">
<code>Release 1.0.0
#
# Write a tag message
# Lines starting with '#' will be ignored.
#

</code>
</pre>
        <p>在这里我们需要输入这一版本的相关提交信息。当前状态如图 9.23 所示。</p>
        <p class="图"><img src="Image00148.jpg" alt="" width="85%" style="width: 85%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.23　master 分支添加标签后的状态</strong>
        </p>
        <p>随后，将 release 分支的状态合并至 develop 分支。如果出现合并提交，则系统会询问提交信息。</p>
        <pre class="代码无行号">
<code>Merge branch 'release/1.0.0' into develop
        　
# Please enter a commit message to explain why this merge is necessary,
# especially if it merges an updated upstream into a topic branch.
#
# Lines starting with '#' will be ignored, and an empty message aborts
# the commit.

</code>
</pre>
        <p>全部工作结束后，会显示如下字样。</p>
        <pre class="代码无行号">
<code>$ git flow release finish '1.0.0'
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 3 commits.
  (use "git push" to publish your local commits)
Merge made by the 'recursive' strategy.
 release | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 release
Switched to branch 'develop'
Your branch is up-to-date with 'origin/develop'.
Merge made by the 'recursive' strategy.
 release | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 release
Deleted branch release/1.0.0 (was 9a754a2).
        　
Summary of actions:
- Latest objects have been fetched from 'origin'
- Release branch has been merged into 'master'
- The release was tagged '1.0.0'
- Release branch has been back-merged into 'develop'
- Release branch 'release/1.0.0' has been deleted

</code>
</pre>
        <p>当前的状态如图 9.24 所示。</p>
        <p class="图"><img src="Image00149.jpg" alt="" width="80%" style="width: 80%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.24　release 分支合并到 develop 分支后的状态</strong>
        </p>
        <h4 id="sigil_toc_id_186">
          <strong>……查看版本标签</strong>
        </h4>
        <p>通过前面一系列操作，我们创建了与发布版本号相同的 Git 标签。</p>
        <pre class="代码无行号">
<code>$ git tag
1.0.0

</code>
</pre>
        <p>今后如果遇到什么问题，只要指定这个标签，就可以将软件回溯到相应版本。</p>
        <h3 id="nav_point_237">
          <strong>更新到远程仓库</strong>
        </h3>
        <p>至此我们对多个分支进行了修改，所以需要利用 push 操作将修改更新到 GitHub 端的远程仓库。我们先从 develop 分支开始。</p>
        <pre class="代码无行号">
<code>$ git push origin develop
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 360 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)
To git@github.com:hirocaster/blog.git
   9299f28..c8add0a develop -&gt; develop

</code>
</pre>
        <p>然后是 master 分支。</p>
        <pre class="代码无行号">
<code>$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 5 commits.
  (use "git push" to publish your local commits)
    　
$ git push origin master
Counting objects: 1, done.
Writing objects: 100% (1/1), 227 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:hirocaster/blog.git
   ad139da..5651cfd master -&gt; master

</code>
</pre>
        <p>再 push 标签信息。</p>
        <pre class="代码无行号">
<code>$ git push --tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 163 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:hirocaster/blog.git
 * [new tag]         1.0.0 -&gt; 1.0.0

</code>
</pre>
        <p>版本号 1.0.0 的标签信息已经 push 完毕，现在只要发布 master 分支，整个发布工作就结束了。</p>
        <h3 id="nav_point_238">
          <strong>在 hotfix 分支中进行的工作</strong>
        </h3>
        <p>hotfix 分支并不是预期中计划出现的分支。它是一个紧急应对措施，只有当前发布的版本中出现 BUG 或漏洞，而且其严重程度要求开发方必须立刻处理，无法等到下一个版本发布时，hotfix 分支才会被创建。</p>
        <p>因此，hotfix 分支都是以发布版本的标签或 master 分支为起点。借助 hotfix 分支，可以在不影响 develop 分支正常开发的情况下，由其他开发者处理成品的修正工作。</p>
        <p>图 9.25 是该分支迁移过程的示意图。</p>
        <p class="图"><img src="Image00150.jpg" alt="" width="68%" style="width: 68%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.25　hotfix 分支的迁移</strong>
        </p>
        <h4 id="sigil_toc_id_187">
          <strong>……创建分支</strong>
        </h4>
        <p>遇到下述情况时需要创建 hotfix 分支进行应对。</p>
        <ul>
          <li>
            <p>最新的 1.0.0 版中发现了 BUG 或漏洞</p>
          </li>
          <li>
            <p>develop 分支正在开发新功能，无法面向用户进行发布</p>
          </li>
          <li>
            <p>漏洞需要及早处理，无法等到下一次版本发布</p>
          </li>
        </ul>
        <p>假设修复 BUG 后的版本升至 1.0.1。</p>
        <p>如果本地仓库尚未从 GitHub 端远程仓库获取标签信息 <span class="注释编号">14</span>
          ，则需要先进行获取操作。当然，如果该标签就是由本地仓库创建，那么就不必进行该操作了。不过为了保险起见，还是建议各位将远程仓库的最新信息获取到本地，确认标签的版本编号是否有误。以下命令可以在任何分支中执行。</p>
        <p class="注释内容">
          <span class="注释编号下">14</span>
          相当于本示例中 1.0.0 的信息
        </p>
        <pre class="代码无行号">
<code>$ git fetch origin
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 1 (delta 0)
Unpacking objects: 100% (1/1), done.
From github.com:hirocaster/blog
 * [new tag]         1.0.0      -&gt; 1.0.0

</code>
</pre>
        <p>现在以 1.0.0 的标签信息为起点，创建名为 1.0.1 的 hotfix 分支。</p>
        <pre class="代码无行号">
<code>$ git flow hotfix start '1.0.1' '1.0.0'
Switched to a new branch 'hotfix/1.0.1'
            　
Summary of actions:
- A new branch 'hotfix/1.0.1' was created, based on '1.0.0'
- You are now on branch 'hotfix/1.0.1'
            　
Follow-up actions:
- Bump the version number now!
- Start committing your hot fixes
- When done, run:
            　
     git flow hotfix finish '1.0.1'

</code>
</pre>
        <p>以 1.0.0 标签为起点成功创建了 hotfix/1.0.1 分支。我们在这个分支中修复软件的漏洞并进行提交。</p>
        <p>修复等工作全部结束后，将 hotfix 分支 push 到 GitHub 端远程仓库，并向 master 分支发送 Pull Request。</p>
        <pre class="代码无行号">
<code>$ git push origin hotfix/1.0.1
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 242 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To git@github.com:hirocaster/blog.git
 * [new branch]      hotfix/1.0.1 -&gt; hotfix/1.0.1

</code>
</pre>
        <h4 id="sigil_toc_id_188">
          <strong>……创建标签和进行发布</strong>
        </h4>
        <p>假设我们发送的 Pull Request 经过了其他开发者的审查，并且已经与 master 分支合并。现在就该利用 GitHub 的功能创建 1.0.1 的标签了。</p>
        <p>访问 GitHub 的仓库页面，从菜单中选择 release，打开该仓库的发布信息（图 9.26）。页面中显示了我们之前创建的 1.0.0 标签的相关信息（图 9.27）。我们可以在这个页面查看以及创建标签的相关信息。
        </p>
        <p class="图"><img src="Image00151.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.26　显示发布信息</strong>
        </p>
        <p class="图"><img src="Image00152.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.27　标签 1.0.0 的信息</strong>
        </p>
        <p>接下来我们要为本次 hotfix 创建 1.0.1 标签。先点击 Draft a new release 按钮，再输入标签的相关信息（图 9.28）。在 Tag version 中输入 1.0.1，在 Target
          中指定 master 分支，此时的 master 分支已经合并了 hotfix 1.0.1 分支的修改。Release title 和 Describe this release
          并不是必填项目，各位可以根据自身情况简明扼要地输入所需信息。最后点击 Publish release 便可完成创建标签的工作（图 9.29）。</p>
        <p class="图"><img src="Image00153.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.28　创建 1.0.1 标签</strong>
        </p>
        <p class="图"><img src="Image00154.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 9.29　1.0.1 创建后的状态</strong>
        </p>
        <p>这个 1.0.1 版本发布后，之前发布的成品也就完成了生命周期。</p>
        <p>现在我们让本地仓库再获取一次标签，确认 1.0.1 标签是否成功创建。</p>
        <pre class="代码无行号">
<code>$ git fetch origin
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
From github.com:hirocaster/blog
 5651cfd..af97962 master      -&gt; origin/master
 * [new tag]        1.0.1        -&gt; 1.0.1
        　
$ git tag
1.0.0
1.0.1

</code>
</pre>
        <h4 id="sigil_toc_id_189">
          <strong>……从 hotfix 分支合并至 develop 分支</strong>
        </h4>
        <p>至此我们虽然已经修正了已发布代码的问题，但是开发中的 develop 分支仍存在这些漏洞和 BUG。因此我们需要将 1.0.1 版的修改合并至 develop 分支。具体操作很简单，只需登录 GitHub，从
          hotfix/1.0.1 分支向 develop 分支发送 Pull Request 即可。经过其他开发者的审查后，修改内容便会被合并到 develop 分支。</p>
        <p>如果合并后 develop 分支出现了异常，切记不要在 hotfix/1.0.1 分支中进行修正。此时应该先完成 hotfix 分支与 develop 分支的合并工作，然后在 develop
          分支中尽快修复相关问题。hotfix/1.0.1 只是针对 master 分支进行内容修改，如果再强行将 develop 分支考虑进去，很可能带来意料之外的 BUG。另外，如果成品软件中包含了本次 hotfix
          以外的多余修改，将来这个版本再需要 hotfix 时，我们就不得不考虑更多更复杂的问题。因此，一定要保证 hotfix 分支只对 master 分支的内容进行最小限度的修改。</p>
        <p>hotfix 分支与 master 分支和 develop 分支合并之后即完成了使命，可以被删除。</p>
        <p>以上便是 hotfix 分支的使用方法。至此我们所讲解的分支迁移正如图 9.30 所示。</p>
        <p class="图"><img src="Image00155.jpg" alt="" width="90%" style="width: 90%" />
        </p>
        <p class="p-img-title">
          <strong>图 9.30　hotfix 分支被合并后的状态</strong>
        </p>
        <h2 id="nav_point_239">
          <strong>9.11　Git Flow 的小结</strong>
        </h2>
        <p>这一开发流程在软件开发世界中存在已久，并没有什么太新颖的地方。但也正因如此，它更容易为软件开发者所理解。</p>
        <p>但是，由于在实际开发现场需要多人分工合作，这一开发流程往往会变得很复杂。建议各位把开发流程图 <span class="注释编号">15</span>
          放大并张贴在墙壁上，这样能够有效帮助团队成员理解流程内容。</p>
        <p class="注释内容">
          <span class="注释编号下">15</span>
          <a href="http://nvie.com/files/Git-branching-model.pdf">http://nvie.com/files/Git-branching-model.pdf</a>
        </p>
        <blockquote>
          <p>
            <strong>专栏：版本号的分配规则</strong>
          </p>
          <p>版本控制策略规定了软件版本号的分配规则，因此制定该策略时应当尽量简单易懂。</p>
          <p>比如在用 x.y.z 格式进行版本管理时的规则如下所示。</p>
          <ul>
            <li>
              <p>x 在重大功能变更或新版本不向下兼容时加 1，此时 y 与 z 的数字归 0</p>
            </li>
            <li>
              <p>y 在添加新功能或者删除已有功能时加 1，此时 z 的数字归 0</p>
            </li>
            <li>
              <p>z 只在进行内部修改后加 1</p>
            </li>
          </ul>
          <p>下面举个具体例子。</p>
          <ul>
            <li>
              <p>1.0.0：最初发布的版本</p>
            </li>
            <li>
              <p>1.0.1：修正了轻微 BUG</p>
            </li>
            <li>
              <p>1.0.2：修复漏洞</p>
            </li>
            <li>
              <p>1.1.0：添加新功能</p>
            </li>
            <li>
              <p>2.0.0：更新整体 UI 并添加新功能</p>
            </li>
          </ul>
          <p>这便是版本号的大致分配规则。</p>
          <p>如果团队采用了 Git Flow，那么成员在交流的时候会经常用到版本号，因此版本控制策略越早制定越好。</p>
        </blockquote>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_240">
          <strong>第 10 章　将GitHub应用到企业</strong>
        </h1>
        <p>本章中，我们将对企业等工作场所引入 GitHub 时的相关问题进行探讨。程序员应该将资源集中于编写优秀的软件上，GitHub 则是辅助这一过程的工具。因此，当今的软件开发企业理应积极引入
          GitHub。本章将为各位讲解一些有用的信息，帮助各位在企业引入 GitHub。</p>
        <h2 id="nav_point_241">
          <strong>10.1　将世界标准的开发环境引入企业现场</strong>
        </h2>
        <p>笔者认为，GitHub 已经称得上一种世界标准的开发环境。至少在开源世界，几乎所有的开源项目都在 GitHub 上公开过源代码。</p>
        <p>另外，已经有相当多的企业开始使用 OSS。相信在各位读者之中，相当一部分人都与开源世界有着不可分割的关联。</p>
        <h3 id="nav_point_242">
          <strong>企业引入 GitHub 的好处</strong>
        </h3>
        <p>打个比 方，很多程序员在业余时间经常使用 GitHub，如果将 GitHub 引入公司，这些人就可以按照自己习惯的方式进行开发，不会产生多余的压力。同样，让新入行的程序员在企业中使用
          GitHub，能使他们很快接触到开源开发世界，促使他们对 GitHub 上的众多软件项目产生兴趣。</p>
        <p>软件行业人才流动性很强，一般情况下，程序员半途加入项目需要先熟悉企业内部软件、项目以及代码的相关信息，从加入到发挥作用往往需要 2 ～ 4 周时间。</p>
        <p>然而，由于相当多程序员都在使用 GitHub，所以上述情况如果放在应用了 GitHub 的企业，很可能新员工进公司第一天就能开始编写代码并发送 Pull Request 了。要知道，GitHub 在全世界已经相当普及。
        </p>
        <p>另外，GitHub 还能省去维护内部仓库服务器的成本，让程序员们能全神贯注地开发软件。</p>
        <h3 id="nav_point_243">
          <strong>使用 Organization</strong>
        </h3>
        <p>企业导入 GitHub 时建议使用 Organization 账户 <span class="注释编号">1</span>
          。利用这一功能，可以让开发者们使用同一控制面板，还能够创建团队并统一管理权限。另外这一账户还为企业提供了用户管理和支付等便捷功能。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a
            href="https://github.com/blog/674-introducing-organizations">https://github.com/blog/674-introducing-organizations</a>
        </p>
        <p>费用与个人账户不同。具体情况请参考 GitHub 的 Organization Plans<span class="注释编号">2</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a href="https://github.com/pricing">https://github.com/pricing</a>
        </p>
        <h3 id="nav_point_244">
          <strong>确认 Github 的安全性</strong>
        </h3>
        <p>由于源代码相当于企业的财产，在企业中导入 GitHub 时势必会对信息安全体制有所顾虑。其实 GitHub 公司已经在网络上发布了安全保障的相关信息。</p>
        <p>用户的数据不仅被严密保管在 GitHub 公司的数据中心，该公司还给客服人员制定了严格的操作规范及相关权限。详细内容请查阅官方网站 <span class="注释编号">3</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          <a
            href="https://help.github.com/articles/github-security">https://help.github.com/articles/github-security</a>
        </p>
        <h3 id="nav_point_245">
          <strong>注意维护时间</strong>
        </h3>
        <p>GitHub 在一年内会有几次短时间的系统维护，国内的企业在这一点上需要加以注意。</p>
        <p>GitHub 的维护时间选在美国的深夜，因为时差的关系国内会是白天。也就是说，那几天我们可能会在工作时间中无法访问 GitHub。</p>
        <p>GitHub 方会在维护前发布系统广播，而且 Git 是分散型版本管理系统，服务器维护并不会导致项目开发彻底停滞。只是为了防止意外情况的发生，最好留意一下服务器维护的日期。</p>
        <p>GitHub 的大规模系统维护公告发布在官方博客的 Broadcasts<span class="注释编号">4</span>
          上。如图 10.1 所示，个人控制面板的右上方也会显示这个 Broadcasts。如果各位每天都使用 GitHub，那么基本不用担心漏看这一信息。</p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          <a href="https://github.com/blog/broadcasts">https://github.com/blog/broadcasts</a>
        </p>
        <p class="图"><img src="Image00156.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 10.1　控制面板上的 Broadcasts</strong>
        </p>
        <h3 id="nav_point_246">
          <strong>查看故障信息</strong>
        </h3>
        <p>GitHub 在官网上公开了故障信息（图 10.2）<span class="注释编号">5</span>
          。如果把一些细微故障算进去，GitHub 发生故障的频率还是相当高的。但是各位从故障信息记录中不难发现，其对故障的反应及处理也十分迅速。</p>
        <p class="注释内容">
          <span class="注释编号下">5</span>
          <a href="https://status.github.com/messages">https://status.github.com/messages</a>
        </p>
        <p class="图"><img src="Image00157.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 10.2　已公开的故障信息日志</strong>
        </p>
        <p>如果各位正在开发的软件需要在规定时间发布，建议事先构建一个 GitHub 之外的备用发布方案，以便在 GitHub 故障时能保证按时发布。</p>
        <p>另外，GitHub 还在官网上以图表形式公开了特定时间段内各项服务的性能及正常运行率等信息（图 10.3）<span class="注释编号">6</span>
          。各位在使用服务时可以拿来做参考。</p>
        <p class="注释内容">
          <span class="注释编号下">6</span>
          <a href="https://status.github.com/">https://status.github.com/</a>
        </p>
        <p class="图"><img src="Image00158.jpg" alt="" width="75%" style="width: 75%" />
        </p>
        <p class="p-img-title">
          <strong>图 10.3　一个月内各服务的运行情况</strong>
        </p>
        <h2 id="nav_point_247">
          <strong>10.2　GitHub Enterprise</strong>
        </h2>
        <p>GitHub 公司为需要内部部署 GitHub 的企业准备了 GitHub Enterprise（GHE）<span class="注释编号">7</span>
          。近年来，GitHub Enterprise 已被许多大型 IT 企业所采用。</p>
        <p class="注释内容">
          <span class="注释编号下">7</span>
          <a href="https://enterprise.github.com/">https://enterprise.github.com/</a>
        </p>
        <h3 id="nav_point_248">
          <strong>概述</strong>
        </h3>
        <p>应用 GitHub Enterprise 等同于将 GitHub 的所有服务全部搬到了企业内部，同时也不再限制非公开仓库的创建。另外作为面向企业的功能，账户管理可以与 LDAP/CAS
          集成。但要注意，这一服务需要根据用户数以年为单位购买许可证 <span class="注释编号">8</span>
          。</p>
        <p class="注释内容">
          <span class="注释编号下">8</span>
          <a href="https://enterprise.github.com/pricing">https://enterprise.github.com/pricing</a>
        </p>
        <p>GitHub 的功能升级时 GitHub Enterprise 也会接到相应通知。升级通知会发送给管理者，管理者可以任选时间将 GitHub Enterprise 切换至维护模式，暂停其全部服务并进行升级。</p>
        <p>因为升级时只需上传 GitHub Enterprise 文件及 License 文件，所以通过浏览器便可完成操作。不过由于升级过程中 GitHub Enterprise
          所有的服务都会暂停，所以企业内部要事先进行协调。根据笔者的经验，暂停服务进行升级的整个过程大概需要 10 分钟。</p>
        <p>GitHub Enterprise 的技术支持十分到位，工作日从上午 10 时至下午 6 时（太平洋标准时间）都有人负责回答。根据官网的描述，通常问题会在 1 个工作日内处理，GitHub Enterprise
          崩溃及无法运行等紧急情况会在 30 分钟内回复 <span class="注释编号">9</span>
          。笔者也曾数次使用普通技术支持，最快一次只过了 4 分钟便收到了回复，让人颇有好感。</p>
        <p class="注释内容">
          <span class="注释编号下">9</span>
          <a href="https://enterprise.github.com/support">https://enterprise.github.com/support</a>
        </p>
        <h3 id="nav_point_249">
          <strong>引入的好处</strong>
        </h3>
        <p>如果各位所在的企业是拥有大量程序员的国际型大企业，那么引入 GitHub Enterprise 将会带来巨大的收益。正如 GitHub 构筑了一个公开的社会化编程世界，GitHub Enterprise
          可以在企业这个封闭的世界中构筑社会化编程环境。</p>
        <p>如果企业内部的开发者们构筑起一个只属于该企业的社会化编程世界，那么这可能会成为企业诞生出更多新产品的契机，或者创造出整个企业通用的便捷新工具。</p>
        <p>因此，笔者尤其建议拥有大量程序员的企业引入 GitHub Enterprise。</p>
        <h3 id="nav_point_250">
          <strong>引入的弊端</strong>
        </h3>
        <p>GitHub Enterprise 同样存在弊端，其中最显著的就是运用方面的成本。这里的成本不单指许可证费用等金钱方面的成本，在实际运用时还要为其准备服务器，在服务器中安装 GitHub
          Enterprise，这些人力成本也必须考虑进去。而且在使用过程中免不了遇到服务器扩容或因故障需要更换等维护作业，而使用 GitHub 的话就不会有这些烦恼。</p>
        <p>不过话说回来，肯考虑引入 GitHub Enterprise 的企业必然具有一定的规模。这些企业内部或多或少都有自己的服务器或计算机需要维护，仅仅多一台 GitHub Enterprise
          服务器对他们来说也不会有太多的成本提升。</p>
        <h3 id="nav_point_251">
          <strong>适合引入 GitHub Enterprise 的几种情况</strong>
        </h3>
        <p>各企业引入 GitHub Enterprise 的理由各不相同，我们在这里介绍其中几个典型的情况给各位。如果各位所在的企业符合下述情况之一，不妨将采用 GitHub Enterprise 一事提上讨论日程。</p>
        <h4 id="sigil_toc_id_190">
          <strong>……源代码不可外传</strong>
        </h4>
        <p>在某些企业看来，源代码是属于企业的财产，不应该放到企业外部的网络上。这些企业适合采用 GitHub Enterprise。</p>
        <p>我们在使用 GitHub 时，虽然所有通信都经过 HTTPS 或 SSH 等协议的加密，但这仍无法改变源代码在网络上传输的事实。此外，源代码还要交由 GitHub 方进行保管。无论 GitHub
          公司内部的管理多么严格，在很多企业看来仍然存在安全风险。</p>
        <p>但是如果采用了 GitHub Enterprise，在企业内部网络中为其搭设一台服务器，就可以在隔绝外部网络的防火墙内侧构筑起一个独立的世界，并且拥有 GitHub
          的所有功能。这样一来，从网络面来看，源代码可以像以前一样通过代码仓库进行管理，避免了多余的安全风险。</p>
        <blockquote>
          <p>
            <strong>专栏：将 GitHub的仓库作为 Subversion仓库使用</strong>
          </p>
          <p>Subversion <span class="注释编号">10</span>
            作为一个热门版本管理系统，一直以来被大量系统所采用。相信很多读者之前也一直在使用 Subversion。GitHub 从名字上看总让人误以为其只支持 Git，但实际上 Subversion 也可以使用 GitHub。
          </p>
          <pre class="代码无行号">
<code>$ svn checkout https://github.com/用户名/仓库名

</code>
</pre>
          <p>上述命令可以以 Subversion 仓库的形式将 GitHub 端的仓库 checkout，提交操作也可以用类似方法进行，提交的修改内容会像往常一样反映在 GitHub 上。</p>
          <p>如果在开发过程中需要长期使用的系统仅支持 Subversion，那么可以通过上述方法在 GitHub 上集中管理 Subversion 仓库。</p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">10</span>
          <a href="http://subversion.apache.org/">http://subversion.apache.org/</a>
        </p>
        <p>从这一观点可以看出，应用 GitHub Enterprise 的一般都是大型企业。</p>
        <h4 id="sigil_toc_id_191">
          <strong>……希望维护与故障时间可控</strong>
        </h4>
        <p>关于 GitHub 系统维护与故障的相关注意事项，我们已经在本章的“注意维护时间”和“查看故障信息”两部分中为大家进行了介绍。由于 GitHub 是服务的提供方，所以维护与故障都不受我们控制。如果选用了 GitHub
          Enterprise，则可以在某种程度上控制这两点。</p>
        <p>如果正在开发的软件必须要在既定时间发布，那么使用 GitHub Enterprise 就能降低维护与故障的干 扰。当然，我们无法完全避免 GitHub Enterprise
          服务器自身故障导致停机等情况的发生，所以这类需要准时发布的软件仍需事先制定备用发布方案，以防 GitHub 或 GitHub Enterprise 在关键时刻出现问题。</p>
        <h2 id="nav_point_252">
          <strong>10.3　能实现 Git 托管的软件</strong>
        </h2>
        <p>有一些开源软件拥有与 GitHub 相类似的功能。</p>
        <p>例如下面几种都比较常用。</p>
        <ul>
          <li>
            <p>GitBucket<span class="注释编号">11</span>
            </p>
          </li>
          <li>
            <p>GitLab<span class="注释编号">12</span>
            </p>
          </li>
          <li>
            <p>Gitorious<span class="注释编号">13</span>
            </p>
          </li>
          <li>
            <p>RhodeCode<span class="注释编号">14</span>
            </p>
          </li>
        </ul>
        <p class="注释内容">
          <span class="注释编号下">11</span>
          <a href="https://github.com/takezoe/gitbucket">https://github.com/takezoe/gitbucket</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">12</span>
          <a href="http://gitlabhq.com">http://gitlabhq.com</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">13</span>
          <a href="https://gitorious.org/gitorious">https://gitorious.org/gitorious</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">14</span>
          <a href="https://rhodecode.com/">https://rhodecode.com/</a>
        </p>
        <p>如果想免费创建与 GitHub 类似的协作开发环境，那么选择上述类型的软件不失为一个好办法。不过，这些软件虽然提供了与 GitHub 类似的功能，但毕竟不是 GitHub
          本身，所以在使用之前要先确认其是否包含自己需要的功能。</p>
        <p>这类软件都有自己的 UI，所以在熟悉操作时需要花费一些学习成本。另外，在运用方面虽然省去了购买的开销，但软件终究无法提供 GitHub 的所有便捷服务，导致开发者在开发过程中需要时常注意其与 GitHub
          的不同之处。因此，如果要追求效率，还是建议选择 GitHub。</p>
        <blockquote>
          <p>
            <strong>专栏：Bitbucket</strong>
          </p>
          <p>Bitbucket 是 Atlassian 公司提供的一项服务<span class="注释编号">15</span>
            ，它所提供的功能与 GitHub 几乎完全相同。接触过 GitHub 的用户在使用 Bitbucket 时不必学习新的概念，但由于 UI 上的区别，所以需要一个习惯的过程。</p>
          <p>当初该服务主要为分散型版本管理系统 Mercurial <span class="注释编号">16</span>
            提供仓库托管服务，目前已经开始支持 Git。</p>
          <p>该服务对每个账户的仓库数量及单个仓库的容量都没有限制，而且公开与私有仓库都可以免费创建。</p>
          <p>可随意创建私有仓库这点确实很吸引人，但非公开仓库的可访问用户数需要付费购买。免费的情况下只允许 5 名用户拥有访问权限，多人共用一个仓库时势必需要支付一定费用。这方面详细信息请参考官方网站<span
              class="注释编号">17</span>
            。</p>
          <p>如果源代码仅供个人或有限几人使用，那么 Bitbucket 要比 GitHub 更能节省开支。</p>
        </blockquote>
        <p class="注释内容">
          <span class="注释编号下">15</span>
          <a href="https://bitbucket.org/">https://bitbucket.org/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">16</span>
          <a href="http://mercurial.selenic.com/">http://mercurial.selenic.com/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">17</span>
          <a href="https://bitbucket.org/plans">https://bitbucket.org/plans</a>
        </p>
        <h2 id="nav_point_253">
          <strong>10.4　小结</strong>
        </h2>
        <p>本章就企业导入 GitHub 时需要了解及考虑的问题进行了讲解。</p>
        <p>GitHub 给 OSS 世界的软件开发带来了变革，同样，它也一定能为各位所在企业的软件开发带来新的理念。以软件开发为主的企业不妨积极导入 GitHub，加以尝试。</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_254">
          <strong>附录 A　支持GitHub的GUI客户端</strong>
        </h1>
        <p>在企业中引入 GitHub 后，势必会有一些人不习惯 CLI 的操作。下面我们为这些读者介绍几款简单易用的 Git 的 GUI 客户端。</p>
        <p>相较于不常接触的 CLI 而言，GUI 客户端更容易入门。但要想做到运用自如，必须先理解 Git 的 clone、push、pull、合并等基本概念。建议各位读者在阅读本书的同时，尽量实际动手操作 GUI
          客户端，以便加深记忆。</p>
        <h2 id="nav_point_255">
          <strong>A.1　GitHub for Mac，GitHub for Windows</strong>
        </h2>
        <p>GitHub 公司提供了 Git 客户端来辅助用户使用 GitHub。该客户端有 Mac 版（图 A.1）<span class="注释编号">1</span>
          和 Windows 版（图 A.2）<span class="注释编号">2</span>
          两个版本。两个客户端提供的功能基本相同，只是由于 OS 不同，所以 UI 有些许差异。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a href="https://mac.github.com/">https://mac.github.com/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a href="https://windows.github.com/">https://windows.github.com/</a>
        </p>
        <p class="图"><img src="Image00159.jpg" alt="" width="95%" style="width: 95%" />
        </p>
        <p class="p-img-title">
          <strong>图 A.1　GitHub for Mac</strong>
        </p>
        <p class="图"><img src="Image00160.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 A.2　GitHub for Windows</strong>
        </p>
        <p>这两个客户端都提供如下功能。</p>
        <ul>
          <li>
            <p>从 GitHub 端 clone 仓库</p>
          </li>
          <li>
            <p>显示仓库的历史记录</p>
          </li>
          <li>
            <p>提交仓库的修改内容</p>
          </li>
          <li>
            <p>切换分支</p>
          </li>
          <li>
            <p>向 GitHub 端进行 push</p>
          </li>
        </ul>
        <p>另外，Mac 版还提供以下功能。</p>
        <ul>
          <li>
            <p>将通知发送至通知中心</p>
          </li>
          <li>
            <p>与 GitHub Enterprise 集成</p>
          </li>
        </ul>
        <p>Mac 客户端支持操作系统的通知中心功能，即使不通过 Mac 客户端对 GitHub 进行操作，我们也可以打开该应用程序，来实时地从 GitHub 获取通知并显示到通知中心，非常方便。</p>
        <p>这两个客户端不必进行繁琐的设置便可使用基本功能，非常适合团队中的设计师等并非是程序员的人使用。各位在决定是否安装之前不 妨先尝试一下。</p>
        <h2 id="nav_point_256">
          <strong>A.2　SourceTree</strong>
        </h2>
        <p>Atlassian 公司为用户提供了一款名为 SourceTree（图 A.3）<span class="注释编号">3</span>
          的应用程序。这一应用程序同时支持 Git 与 Mercurial，并且可以与 Atlassian 公司提供的 Bitbucket 以及内部部署中使用的 Stash<span class="注释编号">4</span>
          进行集成。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          <a href="http://www.sourcetreeapp.com/">http://www.sourcetreeapp.com/</a>
        </p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          <a href="https://www.atlassian.com/software/stash">https://www.atlassian.com/software/stash</a>
        </p>
        <p class="图"><img src="Image00161.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 A.3　SourceTree</strong>
        </p>
        <p>SourceTree 除了提供与 GitHub 官方客户端相同的功能之外，还可以为我们在 9.9 节中讲解的 git-flow 提供支持。如果各位所在的团队采用了 git-flow，那么相对于 GitHub
          的官方客户端，使用 SourceTree 能获得更好的效果。</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 id="nav_point_257">
          <strong>附录 B　通过Gist轻松实现代码共享</strong>
        </h1>
        <p>Gist<span class="注释编号">1</span>
          是一款简单的 Web 应用程序，常被开发者们用来共享示例代码和错误信息。开发者在线交流时难免会涉及软件日志的内容，但直接发送日志会占据很大的篇幅，给交流带来不便。这种情况下，笔者习惯把日志粘贴到 Gist，然后将 URL
          发送给对方。</p>
        <p class="注释内容">
          <span class="注释编号下">1</span>
          <a href="https://gist.github.com/">https://gist.github.com/</a>
        </p>
        <p>此外，Gist 还可以用在如下场合。</p>
        <ul>
          <li>
            <p>代替记事本记录简短代码段</p>
          </li>
          <li>
            <p>给对方发送示例代码</p>
          </li>
        </ul>
        <p>使用 Gist 处理这类情况可以省去不少麻烦。</p>
        <h2 id="nav_point_258">
          <strong>B.1　Gist 的特点</strong>
        </h2>
        <p>Gist 最大的特点是可以与其他人轻松分享示例代码。它使用 JavaScript 编写的 Ace<span class="注释编号">2</span>
          编辑器，只需打开浏览器便可编写简单代码。</p>
        <p class="注释内容">
          <span class="注释编号下">2</span>
          <a href="http://ace.c9.io/">http://ace.c9.io/</a>
        </p>
        <p>另外，Gist 中的文档都在版本管理系统的管理之下，用户可以放心编辑。而且由于其版本历史记录保管在 Git 仓库中，所以还可以通过 clone 操作将 Gist 获取至本地。共享 Gist 的人之间能够互相添加评论，
          所有交流都会被记录下来。</p>
        <p>Gist 支持多种语言的语法高亮，可以大幅增强代码可读性。可以说，这一工具就是专为程序员设计的。</p>
        <h2 id="nav_point_259">
          <strong>B.2　创建 Gist</strong>
        </h2>
        <p>下面我们通过实际演示为各位讲解 Gist。各位可以登录 GitHub 后点击上部菜单中的 Gist 或者直接访问 Gist 的 URL。随后我们可以看到如图 B.1 中所示的页面。</p>
        <p class="图"><img src="Image00162.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 B.1　Gist 的首页</strong>
        </p>
        <h3 id="nav_point_260">
          <strong>UI 讲解</strong>
        </h3>
        <p>接下来我们就各个项目分别进行讲解。</p>
        <h4 id="sigil_toc_id_192">
          <strong>……1 Gist description...</strong>
        </h4>
        <p>头像右侧的这个文本框用来对当前 Gist 所包含的文件进行简要的说明。说明内容应尽量简明扼要，让自己一看就知道是什么。当然，阅览者也能看到这里的信息。</p>
        <p>此项目并不是必填项，所以如果内容没有值得说明的地方，这一项大可不必填写。</p>
        <h4 id="sigil_toc_id_193">
          <strong>……2 name this file...</strong>
        </h4>
        <p>这一项可供用户指定文件名。系统能够自动识别扩展名，将右侧的语言自动设置为对应种类。比如我们输入“hello_gist.rb”，语言会自动设置为 Ruby。</p>
        <p>此项目不是必填项，缺省状态下会以“gistfile1. 扩展名”的形式自动分配名称。</p>
        <h4 id="sigil_toc_id_194">
          <strong>……3 language</strong>
        </h4>
        <p>这里可以给要创建的文件选择编程语言。如果前面没有指定文件名，那么缺省名称的扩展名将以这个设置为准。另外，文件中的代码会按照这里设置的语言进行语法高亮。</p>
        <p>下拉菜单中可以搜索语言（图 B.2），各位请选择适当的语言进行设置以提高可读性。</p>
        <p class="图"><img src="Image00163.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 B.2　查找编程语言</strong>
        </p>
        <p>如果不更改设置，则文件默认为文本格式。</p>
        <h4 id="sigil_toc_id_195">
          <strong>……4 ACE Editor</strong>
        </h4>
        <p>该复选框可以指定 Ace 是否有效。没有特殊情况还是建议各位设置为有效。这样一来，录入文件内容时就可以像普通编辑器一样进行插入 tab 等操作了。</p>
        <p>右侧是缩进的设置，可以选择用空格缩进还是 Tab 缩进。再右边是选择缩进幅度的下拉菜单。</p>
        <h4 id="sigil_toc_id_196">
          <strong>……5 文件</strong>
        </h4>
        <p>这个文本框用来编辑文件的内容，可以手动编写也可以从剪贴板粘贴。与我们常用的编辑器或 IDE 相同，这里的文件内容会根据所选语言即时语法高亮。（图 B.3）</p>
        <p class="图"><img src="Image00164.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 B.3　语法高亮</strong>
        </p>
        <p>如图 B.4 所示，Gist 可以将 Markdown 语法的标题以及编程语言的方法或函数折叠起来，以大纲形式显示内容。</p>
        <p class="图"><img src="Image00165.jpg" alt="" width="60%" style="width: 60%" />
        </p>
        <p class="p-img-title">
          <strong>图 B.4　大纲形式</strong>
        </p>
        <h4 id="sigil_toc_id_197">
          <strong>……6 Add another File</strong>
        </h4>
        <p>一个 Gist 中可以包含多个文件。点击这个按钮可以在下方添加新的文件信息录入框，供用户添加更多文件。</p>
        <h4 id="sigil_toc_id_198">
          <strong>……7 Create Secret Gist</strong>
        </h4>
        <p>通过这个按钮创建的 Gist 不会被公开，只有知道其 URL 的人可以阅览相关内容。使用这个方法能保证 Gist 只与特定几人共享。不过，此 Gist 的 URL 一定要妥善保管。</p>
        <h4 id="sigil_toc_id_199">
          <strong>……8 Create Public Gist</strong>
        </h4>
        <p>以当前内容创建 Gist。在 Discover Gists<span class="注释编号">3</span>
          上也可以看到创建好的 Gist。</p>
        <p class="注释内容">
          <span class="注释编号下">3</span>
          <a href="https://gist.github.com/discover/">https://gist.github.com/discover/</a>
        </p>
        <p>每个 Gist 在创建时都会被自动分配一个 URL。例如</p>
        <p>https://gist.github.com/hirocaster/8374839</p>
        <p>我们可以通过这一 URL 与其他开发者共享该 Gist。</p>
        <h2 id="nav_point_261">
          <strong>B.3　查看 Gist</strong>
        </h2>
        <p>这一节我们将从 Gist 读者的角度出发进行讲解。已创建的 Gist 如图 B.5 所示。</p>
        <p class="图"><img src="Image00166.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 B.5　已创建的 Gist</strong>
        </p>
        <p>登录 Github 后可以在 Gist 中添加评论。当然也可以对自己的 Gist 进行编辑。</p>
        <h3 id="nav_point_262">
          <strong>Gist 的菜单</strong>
        </h3>
        <p>Gist 页菜单的右侧部分有两种模式，在自己的 Gist 下（图 B.6）与其他人的 Gist 下（图 B.7）显示的内容有所不同。</p>
        <p class="图"><img src="Image00167.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 B.6　自己创建的 Gist 的菜单</strong>
        </p>
        <p class="图"><img src="Image00168.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 B.7　其他人创建的 Gist 的菜单</strong>
        </p>
        <p>在自己的 Gist 中有 Edit（编辑）和 Delete（删除）按钮。</p>
        <p>在两者共有的 Advanced Options 中，可以通过 Report as Abuse 来举报不良的 Gist 内容。将 Gist 标记为 Star 后，可以在 Your Gists 的 Starred
          页快速找到这一 Gist。Your Gists 的相关内容我们将在后面讲到。</p>
        <p>在其他人的 Gist 下有 Fork 按钮，用户可以根据其他人的 Gist 创建自己的 Gist。但是这个 Fork 与 GitHub 不同，不可以进行 Pull Request。</p>
        <p>下面我们就 Gist 的每个页面进行讲解。</p>
        <h4 id="sigil_toc_id_200">
          <strong>……1 Gist Detail</strong>
        </h4>
        <p>访问 Gist 的 URL 时会显示这个页面。在这里可以查看 Gist 的文件内容以及评论等详细信息。</p>
        <h4 id="sigil_toc_id_201">
          <strong>……2 Revisions</strong>
        </h4>
        <p>可以查看 Gist 的变更历史记录及差别。</p>
        <h4 id="sigil_toc_id_202">
          <strong>……3 Download Gist</strong>
        </h4>
        <p>将 Gist 以 tar.gz 格式下载。</p>
        <h4 id="sigil_toc_id_203">
          <strong>……4 Clone this gist</strong>
        </h4>
        <p>显示 clone 所需的路径。如果是自己的 Gist，在本地编辑后还可以进行 push 等操作。</p>
        <h4 id="sigil_toc_id_204">
          <strong>……5 Embed this gist</strong>
        </h4>
        <p>显示将 Gist 分享至博客时所需的 HTML。各位想在博客上分享语法高亮的代码时可以利用这一功能。</p>
        <h4 id="sigil_toc_id_205">
          <strong>……6 Link to this gist</strong>
        </h4>
        <p>显示当前 Gist 的 URL。分享 Gist 时可以直接将这个 URL 告诉对方。</p>
        <h3 id="nav_point_263">
          <strong>文件的菜单</strong>
        </h3>
        <p>各文件上方都有如图 B.8 所示的菜单，从左至右依次是文件名，指定的语言种类，永久链接，raw 的链接。如果想将 Gist 中的一个文件获取到本地，使用永久链接会比较便捷。</p>
        <p class="图"><img src="Image00169.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 B.8　文件的菜单</strong>
        </p>
        <h2 id="nav_point_264">
          <strong>B.4　Your Gists</strong>
        </h2>
        <p>点击 Gist 首页右上角的 Your Gists 按钮或者直接访问 URL 都可以进入 Your Gists 页面 <span class="注释编号">4</span>
          。在这里可以查看自己的 Gist 列表。</p>
        <p class="注释内容">
          <span class="注释编号下">4</span>
          <a href="https://gist.github.com/%E7%94%A8%E6%88%B7%E5%90%8D/">https://gist.github.com/用户名/</a>
        </p>
        <p class="图"><img src="Image00170.jpg" alt="{%}" />
        </p>
        <p class="p-img-title">
          <strong>图 B.9　Your Gists 页面</strong>
        </p>
        <p>左侧菜单的 Forked 选项中显示通过 Fork 创建的 Gist，Starred 选项中显示已经标记 Star 的 Gist。文字右侧的数字代表每一类中 Gist 的数量。</p>
        <h2 id="nav_point_265">
          <strong>B.5　小结</strong>
        </h2>
        <p>本部分中我们对 Gist 进行了讲解。通过这款应用，我们可以轻松共享笔记、错误信息以及一些没必要放入仓库的代码片段。各位不妨在日常中多加利用，与其他人共享琐碎信息。</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
        <h1 class="not-in-toc" id="sigil_toc_id_206">看完了</h1>
        <p>如果您对本书内容有疑问，可发邮件至contact@turingbook.com，会有编辑或作译者协助答疑。也可访问图灵社区，参与本书讨论。</p>
        <p>如果是有关电子书的建议或问题，请联系专用客服邮箱：ebook@turingbook.com。</p>
        <p>在这里可以找到我们：</p>
        <ul>
          <li class="第1级无序列表">微博 @图灵教育 : 好书、活动每日播报</li>
          <li class="第1级无序列表">微博 @图灵社区 : 电子书和好文章的消息</li>
          <li class="第1级无序列表">微博 @图灵新知 : 图灵教育的科普小组</li>
          <li class="第1级无序列表">微信 图灵访谈 : ituring_interview，讲述码农精彩人生</li>
          <li class="第1级无序列表">微信 图灵教育 : turingbooks 　　</li>
        </ul>
        <hr />
        <p>图灵社区会员 张海川（zhanghaichuan@ptpress.com.cn） 专享 尊重版权</p>
        <br style="page-break-after:always" />
        <div data-amznpagebreak="always"></div>
      </div>
    </div>
  </div>
</body>

</html>